Function List
AIInterface
Functions

void  AI_ClearCaptureImportanceBonus( ModPlayer* pPlayer, Entity* pEntity )
 	
This clears the importance bonus on this capture point 

 
void  AI_ClearImportance( ModPlayer* pPlayer, Entity* pEntity )
 	
This clears the importance override on this military point 

 
AIObjective*  AI_CreateObjective( ModPlayer* pPlayer, uint32_t objectiveType )
 	
Create a new objective for player 

 
void  AI_DebugAttackEncounterPositionScoringEnable( bool enable )
 	
Enables/disables debugging of AI Attack Objective Encounter Position Scoring 

 
bool  AI_DebugAttackEncounterPositionScoringIsEnabled( Void  )
 	
Returns true if AI Attack Objective Encounter Position Scoring is enabled 

 
void  AI_DebugLuaEnable( bool enable )
 	
Enables/disables AI Lua Debugging 

 
bool  AI_DebugLuaIsEnabled( Void  )
 	
Returns true if AI Lua Debugging is enabled 

 
void  AI_DebugRatingEnable( bool enable )
 	
Enables/disables AI Construction Debugging 

 
bool  AI_DebugRatingIsEnabled( Void  )
 	
Returns true if AI Construction Debugging is enabled 

 
void  AI_DebugRenderAllTaskChildrenEnable( bool enable )
 	
Enables/disables AI Rendering of All Task Children 

 
bool  AI_DebugRenderAllTaskChildrenIsEnabled( Void  )
 	
Returns true if AI Rendering of All Task Children is enabled 

 
void  AI_DebugSkirmishCaptureEnable( bool enable )
 	
Enables/disables AI Skirmish Capture Debugging 

 
bool  AI_DebugSkirmishCaptureIsEnabled( Void  )
 	
Returns true if AI Skirmish Capture Debugging is enabled 

 
void  AI_DebugSkirmishCombatTargetEnable( bool enable )
 	
Enables/disables AI Skirmish Combat Target Debugging 

 
bool  AI_DebugSkirmishCombatTargetIsEnabled( Void  )
 	
Returns true if AI Skirmish Combat Target Debugging is enabled 

 
void  AI_DebugSkirmishObjectiveEnable( bool enable )
 	
Enables/disables AI Skirmish Objective Debugging 

 
bool  AI_DebugSkirmishObjectiveIsEnabled( Void  )
 	
Returns true if AI Skirmish Objective Debugging is enabled 

 
void  AI_DisableAllEconomyOverrides( ModPlayer* pPlayer )
 	
Disable all of the economy overrides for the AI player 

 
void  AI_Enable( ModPlayer* pPlayer, bool enable )
 	
Enables or Disables an AI player 

 
void  AI_EnableAll( bool enable )
 	
Enables or Disables all AI players 

 
void  AI_EnableEconomyOverride( ModPlayer* pPlayer, const char* overrideName, bool enable )
 	
Enable or disable the economy override for the AI player 

 
int  AI_GetDifficulty( ModPlayer* pPlayer )
 	
Gets the difficulty level of this AI player 

Levels can be one of: AD_Easy, AD_Standard, AD_Hard, AD_Hardest

 
const char*  AI_GetPersonality( ModPlayer* pPlayer )
 	
Get the personality name of this AI player 

 
const char*  AI_GetPersonalityLuaFileName( ModPlayer* pPlayer )
 	
Get the personality lua file name of this AI player 

 
bool  AI_IsAIPlayer( ModPlayer* pPlayer )
 	
Returns true if player is an AI player 

 
bool  AI_IsEnabled( ModPlayer* pPlayer )
 	
Returns true if player is a AIPlayer and is enabled 

 
void  AI_LockEntity( ModPlayer* pPlayer, Entity* pEntity )
 	
Locks the entity and disables its tactics (if any) and the AI will no longer use this object 

 
void  AI_LockSquad( ModPlayer* pPlayer, Squad* pSquad )
 	
Locks the squad and disables its tactics (if any) and the AI will no longer use this object 

 
void  AI_LockSquads( ModPlayer* pPlayer, SGroup* squads )
 	
Locks the squads and disables its tactics (if any) and the AI will no longer use these objects 

 
void  AI_RestoreDefaultPersonalitySettings( ModPlayer* pPlayer )
 	
Restores the default personality and difficulty settings of this AI player 

 
void  AI_SetCaptureImportanceBonus( ModPlayer* pPlayer, Entity* pEntity, float importanceBonus )
 	
This sets importance bonus of the given capture point 

 
void  AI_SetDifficulty( ModPlayer* pPlayer, int difficultyLevel )
 	
Set the difficulty level of this AI player 

Levels can be one of: AD_Easy, AD_Standard, AD_Hard, AD_Hardest

 
void  AI_SetImportance( ModPlayer* pPlayer, Entity* pEntity, float importance )
 	
This overrides the default importance of the given military point 

 
void  AI_SetPersonality( ModPlayer* pPlayer, const char* personalityName )
 	
Set the personality name of this AI player 

 
void  AI_UnlockAll( ModPlayer* pPlayer )
 	
Unlocks all designer locked squads for player 

 
void  AI_UnlockEntity( ModPlayer* pPlayer, Entity* pEntity )
 	
Unlocks this entity so that AI can use it again 

 
void  AI_UnlockSquad( ModPlayer* pPlayer, Squad* pSquad )
 	
Unlocks the given squad so the AI can use it again 

 
void  AI_UnlockSquads( ModPlayer* pPlayer, SGroup* squads )
 	
Locks the squads and disables its tactics (if any) and the AI will no longer use these objects 

 
void  AI_UpdateStatics( ModPlayer* pPlayer )
 	
Re-updates the AI in regards to all the static objects in the world (if SCAR creates new strategic points dynamically this will need to be called) 

 
void  AIAbilityObjective_AbilityGuidance_SetAbilityPBG( AIObjective* pObjective, const PropertyBagGroup* abilityPBG )
 	
Set ability for ability objective 

 
void  AIObjective_Cancel( AIObjective* pObjective )
 	
Ends the objective and deletes it. 

 
void  AIObjective_CombatGuidance_EnableCombatGarrison( AIObjective* pObjective, bool enable )
 	
Enables/disables squads in combat garrisoning. 

 
void  AIObjective_CombatGuidance_EnableRetaliateAttacks( AIObjective* pObjective, bool enable )
 	
Enables/disables allowing squads to retaliate against attacking enemies outside the allowed leash area 

 
void  AIObjective_CombatGuidance_SetRetaliateAttackTargetAreaRadius( AIObjective* pObjective, float radius )
 	
Sets the target area radius for the maximum range an enemy can be for a retaliate attack 

 
void  AIObjective_DefenseGuidance_AddFacingPosition( AIObjective* pObjective, ScarPosition pos )
 	
Add facing position to objective; used to determine good defensive setup positions. 

 
void  AIObjective_DefenseGuidance_EnableIdleGarrison( AIObjective* pObjective, bool enable )
 	
Enables/disables idle squads garrisoning. 

 
void  AIObjective_DefenseGuidance_ResetFacingPositions( AIObjective* pObjective )
 	
Remove all facing positions from objective. 

 
void  AIObjective_EngagementGuidance_EnableAggressiveEngagementMove( AIObjective* pObjective, bool enable )
 	
Enable / disable aggressive move into engagement area 

 
void  AIObjective_EngagementGuidance_SetAllowReturnToPreviousStages( AIObjective* pObjective, bool enable )
 	
Enable objective to return to previous stages if they fail to meet conditions for current stage. 

 
void  AIObjective_EngagementGuidance_SetCoordinatedSetup( AIObjective* pObjective, bool enable )
 	
Enable coordinated arrival or setup of squads at engagement area. 

 
void  AIObjective_EngagementGuidance_SetMaxEngagementTime( AIObjective* pObjective, float seconds )
 	
Sets max time, in seconds, to accomplish objective, once the target is engaged. 

 
void  AIObjective_EngagementGuidance_SetMaxIdleTime( AIObjective* pObjective, float seconds )
 	
Sets max time, in seconds, to remain idle at objective target, once engaged. 

 
void  AIObjective_FallbackGuidance_EnableRetreatOnPinned( AIObjective* pObjective, bool enable )
 	
Enable retreat to break supression. 

 
void  AIObjective_FallbackGuidance_EnableRetreatOnSuppression( AIObjective* pObjective, bool enable )
 	
Enable retreat to break supression. 

 
void  AIObjective_FallbackGuidance_SetEntitiesRemainingThreshold( AIObjective* pObjective, float value )
 	
Set entities remaining threshold of encounter [0-N] to fallback at. 

 
void  AIObjective_FallbackGuidance_SetFallbackCapacityPercentage( AIObjective* pObjective, float value )
 	
Set health threshold [0-1] to fallback at. 

 
void  AIObjective_FallbackGuidance_SetFallbackCombatRatingPercentage( AIObjective* pObjective, float value )
 	
Set health threshold [0-1] to fallback at. 

 
void  AIObjective_FallbackGuidance_SetFallbackSquadHealthPercentage( AIObjective* pObjective, float value )
 	
Set combat rating threshold of area [0-1] to fallback at. 

 
void  AIObjective_FallbackGuidance_SetFallbackVehicleHealthPercentage( AIObjective* pObjective, float value )
 	
Set health threshold [0-1] to fallback at. 

 
void  AIObjective_FallbackGuidance_SetGlobalFallbackPercentage( AIObjective* pObjective, float value )
 	
Set global fallback threshold (0.0f for individual squad). 

 
void  AIObjective_FallbackGuidance_SetGlobalFallbackRetreat( AIObjective* pObjective, bool value )
 	
Set global retreat type (true for retreat; false for fallback). 

 
void  AIObjective_FallbackGuidance_SetRetreatCapacityPercentage( AIObjective* pObjective, float value )
 	
Set combat rating threshold of area [0-1] to fallback at. 

 
void  AIObjective_FallbackGuidance_SetRetreatCombatRatingPercentage( AIObjective* pObjective, float value )
 	
Set combat rating threshold of area [0-1] to fallback at. 

 
void  AIObjective_FallbackGuidance_SetRetreatHealthPercentage( AIObjective* pObjective, float value )
 	
Set combat rating threshold of area [0-1] to fallback at. 

 
void  AIObjective_FallbackGuidance_SetTargetPosition( AIObjective* pObjective, ScarPosition pos )
 	
Set fallback target. 

 
bool  AIObjective_IsValid( AIObjective* pObjective )
 	
Determines if objective is still valid. Must be true before calling any other of the AIObjective_* function. Return true if valid, false otherwise. 

 
void  AIObjective_MoveGuidance_EnableAggressiveMove( AIObjective* pObjective, bool enable )
 	
Enable / disable aggressive movements on way to engagement targets 

 
void  AIObjective_MoveGuidance_ResetPathingLengthFactor( AIObjective* pObjective )
 	
Reset preference for shorter paths on way to engagement targets, to defaults 

 
void  AIObjective_MoveGuidance_ResetSafePathingWeight( AIObjective* pObjective )
 	
Reset preference for safe movements on way to engagement targets, to defaults 

 
void  AIObjective_MoveGuidance_SetPathingLengthFactor( AIObjective* pObjective, float weight )
 	
Set preference for shorter paths on way to engagement targets 

 
void  AIObjective_MoveGuidance_SetSafePathingWeight( AIObjective* pObjective, float weight )
 	
Set preference for safe movements on way to engagement targets 

 
void  AIObjective_MoveGuidance_SetSquadCoherenceRadius( AIObjective* pObjective, float radius )
 	
Set radius (follow distance) for coordinated move phase (<= 0 disables coordinated movement) 

 
void  AIObjective_Notify_ClearCallbacks( AIObjective* pObjective )
 	
Clears all notification callbacks for objective 

 
void  AIObjective_Notify_SetPlayerEventObjectiveID( AIObjective* pObjective, uint32_t id )
 	
Sets the ID for the notification event sent out by objective 

 
void  AIObjective_ResourceGuidance_ClearSquads( AIObjective* pObjective )
 	
Removes all resource squads from objective. 

 
void  AIObjective_ResourceGuidance_SquadGroup( AIObjective* pObjective, SGroup* squads )
 	
Sets the resource squads for objective. 

 
void  AIObjective_SetName( AIObjective* pObjective, const char* name )
 	
Set objective name for debugging. 

 
void  AIObjective_TacticFilter_DisableAbility( AIObjective* pObjective, const PropertyBagGroup* ability )
 	
Disable ability for all squads in objective 

 
void  AIObjective_TacticFilter_DisableAbilityForSquadGroup( AIObjective* pObjective, SGroup* squads, const PropertyBagGroup* ability )
 	
Disable ability for squads in objective 

 
void  AIObjective_TacticFilter_EnableCloseGround( AIObjective* pObjective, float priority )
 	
Enable close ground behaviour (3-stage TACTIC_RushAtTarget) for all squads in objective, running at priority (1..1000) 

 
void  AIObjective_TacticFilter_Reset( AIObjective* pObjective )
 	
Reset all tactic filters for objective 

 
void  AIObjective_TacticFilter_ResetAbilityGuidance( AIObjective* pObjective )
 	
Reset all tactic ability constraints for objective 

 
void  AIObjective_TacticFilter_ResetPriority( AIObjective* pObjective, AITacticType tactic )
 	
Reset tactic priority for all squads in objective 

 
void  AIObjective_TacticFilter_ResetTacticGuidance( AIObjective* pObjective )
 	
Reset all tactic constraints for objective 

 
void  AIObjective_TacticFilter_ResetTargetGuidance( AIObjective* pObjective )
 	
Reset all tactic target constraints for objective 

 
void  AIObjective_TacticFilter_SetAbilityGuidance( AIObjective* pObjective, const PropertyBagGroup* ability, int32_t maxCasters, float retrySecs, float waitSecs, float timeoutSecs, bool initialWait, float maxRange )
 	
Set tactic ability constraints for objective 

 
void  AIObjective_TacticFilter_SetDefaultAbilityGuidance( AIObjective* pObjective, int32_t maxCasters, float retrySecs, float waitSecs, float timeoutSecs, bool initialWait, float maxRange )
 	
Set default tactic ability constraints for objective (ability specific guidance takes priority over defaults) 

 
void  AIObjective_TacticFilter_SetDefaultTacticGuidance( AIObjective* pObjective, int32_t maxUsers, float retrySecs, float waitSecs, float timeoutSecs, bool initialWait, float maxRange )
 	
Set default tactic constraints for objective (tactic specific guidance takes priority over defaults) 

 
void  AIObjective_TacticFilter_SetDefaultTargetGuidance( AIObjective* pObjective, int32_t maxAttackers )
 	
Set default target constraints for objective (target specific guidance takes priority over defaults) 

 
void  AIObjective_TacticFilter_SetPriority( AIObjective* pObjective, AITacticType tactic, float priority )
 	
Set tactic priority for all squads in objective; negative priority disables 

 
void  AIObjective_TacticFilter_SetPriorityForSquadGroup( AIObjective* pObjective, SGroup* squads, AITacticType tactic, float priority )
 	
Set tactic priority for squads in objective 

 
void  AIObjective_TacticFilter_SetTacticGuidance( AIObjective* pObjective, AITacticType tactic, int32_t maxUsers, float retrySecs, float waitSecs, float timeoutSecs, bool initialWait, float maxRange )
 	
Set tactic constraints for objective 

 
void  AIObjective_TacticFilter_SetTargetPolicy( AIObjective* pObjective, TargetPreference policy )
 	
Set tactic target priority for objective 

 
void  AIObjective_TargetGuidance_SetTargetArea( AIObjective* pObjective, float radius )
 	
Sets engagement area radius around the target.  

 
void  AIObjective_TargetGuidance_SetTargetEntity( AIObjective* pObjective, Entity* entity )
 	
Sets target Entity for objective 

 
void  AIObjective_TargetGuidance_SetTargetLeash( AIObjective* pObjective, float radius )
 	
Sets leash radius around target where squads should stay within.  

 
void  AIObjective_TargetGuidance_SetTargetPathByName( AIObjective* pObjective, const char* pathName, float delaySecs )
 	
Sets target patrol path for objective 

 
void  AIObjective_TargetGuidance_SetTargetPathWander( AIObjective* pObjective, float delaySecs )
 	
Sets random wander target patrol for objective; delaySecs is the time in secs to pause at each random point 

 
void  AIObjective_TargetGuidance_SetTargetPosition( AIObjective* pObjective, ScarPosition pos )
 	
Sets target position for objective 

 
void  AIObjective_TargetGuidance_SetTargetSquad( AIObjective* pObjective, Squad* squad )
 	
Sets target Squad for objective 

 
 

 

BeginnerHint
Functions

OpportunityID  BeginnerHint_AddOpportunity( Pos/Group/Table where, AbilityID/Table ability[, Bool repeating, LocText message, String icon, HPAT arrow, GD max_difficulty, Bool ignore_timers] )
 	
Add an opportunity that may get highlighted by the hint manager system on easier difficulty modes. THIS IS NOT MP-SAFE! 

 
Void  BeginnerHint_RemoveAllOpportunities( )
 	
Remove all opportunities in one fell swoop! 

 
Void  BeginnerHint_RemoveOpportunity( Pos/OpportunityID where )
 	
Remove an opportunity, either by ID or all opportunities at a location 

 
 

 

Blueprint
Functions

ScarAbilityPBG  BP_GetAbilityBlueprint( const char* pbgShortname )
 	
Returns an ability property bag group. 

 
ScarCamouflageStancePBG  BP_GetCamouflageStanceBlueprint( const char* pbgShortname )
 	
Returns a camouflage stance property bag group. 

 
ScarCriticalPBG  BP_GetCriticalBlueprint( const char* pbgShortname )
 	
Returns a critical property bag group. 

 
ScarEntityPBG  BP_GetEntityBlueprint( const char* pbgShortname )
 	
Returns an entity property bag group. 

 
uint32_t  BP_GetID( const PropertyBagGroup* pbg )
 	
Returns an ID that uniquely identifies this pbg 

 
ScarMoveTypePBG  BP_GetMoveTypeBlueprint( const char* pbgShortname )
 	
Returns a move type property bag group. 

 
const char*  BP_GetName( const PropertyBagGroup* pbg )
 	
Return the short name of the group 

Example name would be "ally_mad_minute_ability"

 
int  BP_GetPropertyBagGroupCount( LuaBinding::StackVar type )
 	
Return the number of property bag groups of the same type 

Example type would be PBG_Critical

 
const char*  BP_GetPropertyBagGroupPathName( LuaBinding::StackVar type, size_t index )
 	
Return the path name of the group at the specified index 

Example name would be "abilities\ally_mad_minute_ability"

 
ScarSlotItemPBG  BP_GetSlotItemBlueprint( const char* pbgShortname )
 	
Returns a slot item property bag group. 

 
ScarSquadPBG  BP_GetSquadBlueprint( const char* pbgShortname )
 	
Returns a squad property bag group. 

 
ScarUpgradePBG  BP_GetUpgradeBlueprint( const char* pbgShortname )
 	
Returns an upgrade property bag group. 

 
ScarWeaponPBG  BP_GetWeaponBlueprint( const char* pbgShortname )
 	
Returns a weapon property bag group. 

 
bool  EBP_Exists( const char* pbgShortname )
 	
Returns true if an entity blueprint exists with the given name. 

 
bool  SBP_Exists( const char* pbgShortname )
 	
Returns true if a squad blueprint exists with the given name. 

 
 

 

Camera
Functions

Void  Camera_CyclePositions( Table list[, Boolean pan, Float panRate, ScarFn callback] )
 	
Moves the camera through a list of positions. 

 
Void  Camera_Follow( Variable var )
 	
Set the camera to follow an sgroup/squad/egroup/entity. 

The camera will follow them until the player takes control again.

 
Void  Camera_MoveTo( Variable var[, Boolean pan, Float panRate, Boolean keepInputLocked, Boolean resetToDefault] )
 	
Move the camera to an entity/marker/pos/egroup/sgroup/squad 

This function canNOT be called through a CTRL object in NISlets.

 
Void  Camera_MoveToIfClose( Variable var )
 	
Slightly refocus the camera to rest on an entity/squad/squad/sgroup/egroup/pos/marker if it's close by. 

This function can be called through a CTRL object in NISlets.

 
Void  Camera_SetDefault( Float height, Float declination, Float angle )
 	
Helper function to set the default camera parameters 

If the parameter is nil, the particular property is not modified

 
 

 

Command
Functions

Void  Cmd_AbandonTeamWeapon( SGroupID sgroupid[, Boolean preserveCrew, Boolean queued] )
 	
Order a squad group to abandon their current team weapon if they have it and they could (tuning value in attribute editor) 

 
Void  Cmd_Ability( PlayerID/EGroupID/SGroupID user, AbilityBlueprint blueprint, [Position/SGroupID/EGroupID target, Position direction, Bool skipCostPrereq, Bool queued] )
 	
Sends an ability command to a player, egroup or sgroup. extra parameters are provided if the ability requires them. 

 
Void  Cmd_AttachSquads( SGroupID sgroup, SGroupID sgroupAttachee )
 	
Attach the squad from sgroupnameAttachee to sgroupname. Both SGroups must contain only one squad. 

 
Void  Cmd_Attack( SGroupID sgroup, SGroup/EGroup/Pos/Marker target[, Boolean queued, Boolean stationary, String plan] )
 	
Issues an attack command to an SGroup 

 
Void  Cmd_AttackMove( SGroupID sgroup, Position targetposition[, Boolean queued, String plan, Real coverSearchRadius, MarkerID deleteWhenNearMarker] )
 	
Order a squad group to attack move to a position (anything whose position can be queried). can be queued, can follow a plan, can search for cover within a radius 

 
Void  Cmd_AttackMoveThenCapture( SGroupID attacker, EGroupID target, [!Boolean!queued ] )
 	
Command attacker sgroup to attack move to strategic point target; when it is capturable, the sgroup would capture it 

 
Void  Cmd_CaptureTeamWeapon( SGroupID sgroupid, EGroupID targetid, [Boolean queued] )
 	
Order a squad group to capture team weapon entity group. 

 
Void  Cmd_Construct( SGroup sgroupid, Entity blueprint, EGroupID/Position/Marker targetid[, Position Facing, Boolean queued] )
 	
Orders a squad to contruct a building at specified position, or to continue construction on an existing building. 

The command also checks to see if a building already exists at the location, and the squad will continue building it, if it is of the correct type.

 
Void  Cmd_CriticalHit( PlayerID playerid, SGroupID/EGroupID/Squad/Entity target, CriticalID criticalid, Real removeAtHealth )
 	
Applies critical hit to entity/squad/sgroup/egroup 

Player id doesn't have to be the owner as the applied entities but need to make sure the player is still alive

 
Void  Cmd_DetonateDemolitions( PlayerID player, EGroupID target[, Boolean queued] )
 	
Detonates a building's demolitions 

 
Void  Cmd_EjectOccupants( EGroupID/SGroupID fromgroupid[, Position destination, Boolean queued] )
 	
Orders an EGroup or SGroup to kick out its occupants. If no position is specified, the occupants stay at the exit. 

 
EntityID or SquadID id of the destination  Cmd_Garrison( SGroupID fromsgroupid, EGroupID/SGroupID togroupid, [Bool overload, Bool queued, Bool instant] )
 	
Order a squad group to load at a random entity or squad of the group 

overload is a flag that will allow the hold entity to ignore maximum slot check

 
Void  Cmd_InstantReinforceUnit( SGroupID sgroup, Integer count )
 	
Sends a instant reinforce command to all squads in a group. count represents the number of commands to send. 

Note: This function bypasses pre-reqs, costs and the production queue

 
Void  Cmd_InstantReinforceUnitPos( SGroupID sgroup, Integer count, MarkerID/Pos spawnlocation[, Integer checktype[, Integer failtype]] )
 	
Sends a instant reinforce command to all squads in a group. count represents the number of commands to send. spawnlocation is where the reinforced unit will spawn. You can optionally find a hidden position by specifying a checktype (CHECK_OFFCAMERA, CHECK_IN_FOW or CHECK_BOTH), and what to do if a hidden position can't be found (SPAWN_ATMARKER, SPAWN_ATSQUAD, or DO_NOTHING) - SPAWN_ATMARKER is the default. 

Note: This function bypasses pre-reqs and costs and the production queue

 
Void  Cmd_InstantSetupTeamWeapon( SGroupID sgroupid, [Boolean queued] )
 	
Order a squad group to instant setup their team weapon 

 
Void  Cmd_InstantUpgrade( PlayerID/EGroupID/SGroupID target, UpgradeBlueprint/Table blueprint[, Integer count] )
 	
Sends an instant upgrade command to a player, egroup or sgroup. accepts a single upgrade or table of upgrades. 

 
Void  Cmd_Move( SGroupID sgroup, Pos/SGroupID/EGroupID/MarkerID position, [Boolean queued, MarkerID deleteWhenNearMarker, Position facing, Integer offset, Real distance, Real coverSearchRadius] )
 	
Move a squad group to a given position. 

Supports facing, 'offset' movement, and can find cover. The sgroup can be deleted when in proximity of a marker (it assumes a proximity of 5 if you forget to set one on the marker)

 
Void  Cmd_MoveAwayFromPos( SGroupID sgroup, Pos position, Int radius, [Boolean queued] )
 	
Move a squad group out of a position to a certain radius 

All squads in the group will move away from the centre position from its current position

 
Void  Cmd_MoveToAndDespawn( SGroupID sgroup, MarkerID marker, boolean queued )
 	
Moves a squad group to the indicated Marker and destroys it. 

 
markerID  Cmd_MoveToClosestMarker( SGroupID sgroup, Table markertable )
 	
Moves a squad group to the closest marker in a list/table of MarkerIDs. 

 
Void  Cmd_MoveToThenCapture( SGroupID attacker, EGroupID target, [!Boolean!queued ] )
 	
Command attacker sgroup to attack move to strategic point target; when it is capturable, the sgroup would capture it 

 
Void  Cmd_RecrewVehicle( SGroupID sgroupid, EGroupID targetid, [Boolean queued] )
 	
Order a squad group to recrew an abandoned vehicle. 

 
Void  Cmd_ReinforceUnit( SGroupID sgroup, Integer count )
 	
Sends a reinforce command to all squads in a group. count represents the number of commands to send. 

Note: To reinforce squad bypassing the pre-reqs and costs use Cmd_InstantReinforceUnit.

 
Void  Cmd_ReinforceUnitPos( SGroupID sgroup, Integer count, MarkerID/Pos spawnlocation[, Integer checktype[, Integer failtype]] )
 	
Sends a reinforce command to all squads in a group. count represents the number of commands to send. spawnlocation is where the reinforced unit will spawn. You can optionally find a hidden position by specifying a checktype (CHECK_OFFCAMERA, CHECK_IN_FOW or CHECK_BOTH), and what to do if a hidden position can't be found (SPAWN_ATMARKER, SPAWN_ATSQUAD, or DO_NOTHING) - SPAWN_ATMARKER is the default. 

To reinforce squads bypassing the pre-reqs and costs use Cmd_InstantReinforceUnit

 
Void  Cmd_Retreat( SGroupID sgroup[, Position location, MarkerID deleteWhenNearMarker, Boolean queued, Boolean saveEncountersk, Boolean vulnerableRetreat] )
 	
Order a squad group to retreat, optionally to a specific location. The sgroup can be deleted when in proximity of a marker (it assumes a proximity of 5 if you forget to set one on the marker) 

vulnerableRetreat will make retreating squads take more damage

 
Void  Cmd_RevertOccupiedBuilding( SGroupID sgroupid, EGroupID targetid, [Boolean queued] )
 	
Order a squad group to revert occupied building 

 
Void  Cmd_SetDemolitions( SGroupID sgroupid, EGroupID targetid[, Boolean skipCostPrereq, Boolean queued] )
 	
Orders a squad group to place demolition charges on a building (egroup). Function does nothing if egroup cannot be detonated, or player can't afford the demolitions 

 
Void  Cmd_SquadCamouflageStance( SGroupID sgroup, CamouflageStanceID stanceid )
 	
Sends an camouflage stance command to all squads in a group. stanceid should be the number returned by Util_GetCamouflageStanceID( stancename ) 

 
Void  Cmd_SquadPath( SGroupID sgroup, String pathName, Boolean bFromClosest, Integer loop, Boolean bAttackMove, Float pauseTime[, MarkerID deleteWhenNearMarker, Boolean queued, Boolean bMoveForward] )
 	
Send a command to the squad to follow a path. Can wait at each waypoint. The sgroup can be deleted when in proximity of a marker if you pass in the marker as the 7th argument (it assumes a proximity of 5 if you forget to set one on the marker) 

loop can be: LOOP_NONE, LOOP_NORMAL, LOOP_TOGGLE_DIRECTION

 
Void  Cmd_SquadPatrolMarker( SGroupID sgroup, MarkerID marker )
 	
Causes a squad to patrol a marker attacking any enemies that come within its radius. If used on circular markers, the radius must be at least 5. To stop the squad from patrolling the marker, use Cmd_Stop. 

 
Void  Cmd_StaggeredRetreat( SGroupID sgroup, Table markers, [Integer maxTries, Boolean vulnerableRetreat] )
 	
Retreats large numbers of units in a staggered, realistic manner. 

vulnerableRetreat will make retreating squads take more damage

 
Void  Cmd_Stop( EGroupID/SGroupID group )
 	
Sends a stop command to egroup or sgroup. 

 
Void  Cmd_Surrender( SGroup!sgroupid [, Integer actionpoints, Position exitpos, Boolean deleteAtExit, Boolean removeWeapon] )
 	
Orders a squad to surrender and awards the local player with an appropriate number of action points 

The command will also overwrite the exit position as well, if you do not want the squads to exit at the map entry point.

 
Void  Cmd_UngarrisonSquad( SGroupID sgroupid[, Position destination, Boolean queued] )
 	
Orders an sgroup to exit the building or vehicle that it's in. If no position is specified, the sgroup stays at the exit. 

 
Void  Cmd_Upgrade( PlayerID/EGroupID/SGroupID user, UpgradeBlueprint/Table blueprint[, Integer count, Boolean instant] )
 	
Sends an upgrade command to a player, egroup or sgroup. accepts a single upgrade or table of upgrades. 

 
void  Command_Entity( Player* player, EGroup* egroup, EntityCommandType entityCommand )
 	
Send a entity command to a entity group(CMD_DefaultAction, CMD_Stop, CMD_Destroy, CMD_BuildSquad, CMD_CancelProduction, CMD_RallyPoint, CMD_AttackForced) 

Entity commands are mostly used for buildings etc. If you need to issue commands to units, use the Squad_Command function.

 
void  Command_EntityAbility( Player* player, EGroup* egroup, ScarAbilityPBG abilityPBG, bool skipCostPrereq, bool queued )
 	
Send an entity ability command (CMD_Ability) to an entity 

 
void  Command_EntityBuildSquad( Player* player, EGroup* egroup, ScarSquadPBG squadPbg )
 	
Send a squad command to a entity group with custom data 

 
void  Command_EntityEntity( Player* player, EGroup* egroup, EntityCommandType entityCommand, EGroup* target )
 	
Send a entity-based command to an entity group. 

Use this function to issue orders that require a entity to an entity group (eg. order a building to attack another building)<BR/> See Command_Entity for a list of all the possible entityCommands.

 
void  Command_EntityExt( Player* player, EGroup* egroup, EntityCommandType entityCommand, uint32_t cmdparam, bool queued )
 	
Send a squad command to a squad group with custom data 

 
void  Command_EntityPos( Player* player, EGroup* egroup, EntityCommandType entityCommand, ScarPosition target )
 	
Send a position command to an entity group. 

Use this function to issue orders that require a position to an entity group (eg. set a rally point for a building)<BR/> See Command_Entity for a list of all the possible entityCommands.

 
void  Command_EntityPosAbility( Player* player, EGroup* egroup, ScarPosition pos, ScarAbilityPBG abilityPBG, bool skipCostPrereq, bool queued )
 	
Send a positional ability command (CMD_Ability) to an entity 

Use this function to issue ability orders that require a position to player

 
void  Command_EntityPosDirAbility( Player* player, EGroup* egroup, ScarPosition pos, ScarPosition dir, ScarAbilityPBG abilityPBG, bool skipCostPrereq, bool queued )
 	
Send a positional/directional ability command (CMD_Ability) to an entity 

Use this function to issue ability orders that require a position and a direction to player

 
void  Command_EntityPosSquad( Player* player, EGroup* egroup, EntityCommandType entityCommand, ScarPosition target, SGroup* sgroup )
 	
Send a dual target (position and squad) command to an entity group. 

Use this function to issue orders that require a position and a squad to an entity group (eg. unloading squad from hold)<BR/> See Command_Entity for a list of all the possible entityCommands.

 
void  Command_EntitySquad( Player* player, EGroup* egroup, EntityCommandType entityCommand, SGroup* target )
 	
Send a squad-based command to an entity group. 

Use this function to issue orders that require a squad to an entity group (eg. order a building to attack a squad)<BR/> See Command_Entity for a list of all the possible entityCommands.

 
void  Command_EntityTargetEntityAbility( Player* player, EGroup* egroup, Entity* entityTarget, ScarAbilityPBG abilityPBG, bool skipCostPrereq, bool queued )
 	
Send an entity-targeting ability command (CMD_Ability) to an entity 

Use this function to issue ability orders that require an entity target to an entity

 
void  Command_EntityTargetSquadAbility( Player* player, EGroup* egroup, Squad* squadTarget, ScarAbilityPBG abilityPBG, bool skipCostPrereq, bool queued )
 	
Send an squad-targeting ability command (CMD_Ability) to an entity 

Use this function to issue ability orders that require an entity target to an entity

 
void  Command_EntityUpgrade( Player* player, EGroup* egroup, ScarUpgradePBG upgrade, bool instant, bool queued )
 	
Send a squad command to a entity group with custom data 

 
void  Command_Player( Player* player, Player* dest, PlayerCommandType playerCommand )
 	
Send a player command to a player 

PCMD_Ability

 
void  Command_PlayerAbility( Player* player, Player* dest, ScarAbilityPBG abilityPBG, bool skipCostPrereq )
 	
Send a player ability command (PCMD_Ability) to a player 

 
void  Command_PlayerEntity( Player* player, Player* dest, PlayerCommandType playerCommand, EGroup* target )
 	
Send an entity command to a player. 

 
void  Command_PlayerEntityCriticalHit( Player* player, EGroup* egroup, PlayerCommandType playerCommand, ScarCriticalPBG criticalPBG, float removeAtHealth, bool queued )
 	
Send a player command to itself to act upon single with custom parameter and index data (PCMD_CriticalHit) 

This is a special command for SCAR and debug feature

 
void  Command_PlayerExt( Player* player, Player* dest, PlayerCommandType playerCommand, uint32_t cmdparam, bool queued )
 	
Send a player command to a player with a custom flag 

 
void  Command_PlayerPos( Player* player, Player* dest, PlayerCommandType playerCommand, ScarPosition pos )
 	
Send a position command to a player. 

Use this function to issue orders that require a position to player)<BR/> See Command_Player for a list of all the possible playerCommands.

 
void  Command_PlayerPosAbility( Player* player, Player* dest, ScarPosition pos, ScarAbilityPBG abilityPBG, bool skipCostPrereq )
 	
Send a positional ability command (PCMD_Ability) to a player 

Use this function to issue ability orders that require a position to player

 
void  Command_PlayerPosDirAbility( Player* player, Player* dest, ScarPosition pos, ScarPosition dir, ScarAbilityPBG abilityPBG, bool skipCostPrereq )
 	
Send a positional/directional ability command (PCMD_Ability) to a player 

Use this function to issue ability orders that require a position and a direction to player

 
void  Command_PlayerPosExt( Player* player, Player* dest, PlayerCommandType playerCommand, ScarPosition pos, uint32_t cmdparam, bool queued )
 	
Send a position command to a player with extra info 

Use this function to issue orders that require a position to player<BR/> See Command_Player for a list of all the possible playerCommands.

 
void  Command_PlayerSquadConstructBuilding( Player* player, SGroup* sgroup, ScarEntityPBG ebp, ScarPosition position, ScarPosition facing, bool queued )
 	
Send a player command to itself to order squads in the sgroup to construct the building at specific position and facing 

structureBlueprint must be a valid building that can be constructed by the sgroup. This building would cost nothing and does not effect population and availability This is a special command for SCAR use

 
void  Command_PlayerSquadConstructFence( Player* player, SGroup* sgroup, ScarEntityPBG ebp, ScarPosition posStart, ScarPosition posEnd, bool queued )
 	
Send a player command to itself to order squads in the sgroup to construct fences from posStart to posEnd 

structureBlueprint must be a valid building that can be constructed by the sgroup. This building would cost nothing and does not effect population and availability This is a special command for SCAR use

 
void  Command_PlayerSquadConstructField( Player* player, SGroup* sgroup, ScarEntityPBG ebp, ScarPosition posStart, ScarPosition posEnd, bool queued )
 	
Send a player command to itself to order squads in the sgroup to construct a field ranging from posStart to posEnd 

structureBlueprint must be a valid building that can be constructed by the sgroup. This building would cost nothing and does not effect population and availability This is a special command for SCAR use

 
void  Command_PlayerSquadCriticalHit( Player* player, SGroup* sgroup, PlayerCommandType playerCommand, ScarCriticalPBG criticalPBG, float removeAtHealth, bool queued )
 	
Send a player command to itself to act upon all entities in the sgroup with custom parameter and index data (PCMD_CriticalHit) 

This is a special command for SCAR & debug use

 
void  Command_PlayerUpgrade( Player* player, ScarUpgradePBG upgrade, bool instant, bool queued )
 	
Sends an upgrade command to a player 

 
void  Command_Squad( Player* player, SGroup* sgroup, SquadCommandType squadCommand, bool queued )
 	
Send a squad command to a squad group 

SCMD_DefaultAction, SCMD_Move, SCMD_Stop, SCMD_Destroy, SCMD_BuildStructure, SCMD_Capture, SCMD_Attack, SCMD_ReinforceUnit, SCMD_Upgrade, SCMD_CancelProduction SCMD_AttackMove, SCMD_Ability SCMD_Load,SCMD_UnloadSquads, SCMD_DoPlan SCMD_SlotItemRemove, SCMD_InstantReinforceUnit, SCMD_InstantUpgrade

 
void  Command_SquadAbility( Player* player, SGroup* sgroup, ScarAbilityPBG abilityPBG, bool skipCostPrereq, bool queued )
 	
Send a ability command (SCMD_Ability) to a squad 

 
void  Command_SquadAttackMovePos( Player* player, SGroup* sgroup, SquadCommandType squadCommand, ScarPosition target, const char* planName, bool queued )
 	
Send a position ATTACK MOVE command to a squad group with custom data 

 
void  Command_SquadDoCustomPlan( Player* player, SGroup* sgroup, const char* planFile, bool queued )
 	
Send a custom squad AI plan command to the squad to execute the plan specified towards the position 

 
void  Command_SquadDoCustomPlanTarget( Player* player, SGroup* sgroup, ScarPosition pos, const char* planFile, bool queued )
 	
Send a custom squad AI plan command to the squad to execute the plan specified towards the position 

 
void  Command_SquadEntity( Player* player, SGroup* sgroup, SquadCommandType squadCommand, EGroup* target, bool queued )
 	
Send an entity command to a squad group. 

Use this function to isssue an entity-based command to a squad group.<BR/> See Command_Squad for a list of all the possible squadCommands

 
void  Command_SquadEntityAbility( Player* player, SGroup* sgroup, EGroup* target, ScarAbilityPBG abilityPBG, bool skipCostPrereq, bool queued )
 	
Send a entity ability command (SCMD_Ability) to a squad 

 
void  Command_SquadEntityAttack( Player* player, SGroup* sgroup, EGroup* target, bool bCheckFOW, bool bStationary, const char* planName, bool queued )
 	
Send an entity command ATTACK to a squad group. 

Use this function to issue an entity-based command to a squad group with custom FOW check flag. (eg. order a squad to attack a building)<BR/> planName is the name of the custom plan file to execute. Pass in empty string to use the default<BR/> stationary flag uses SCMD_StationaryAttack instead where plan file is ignored and squad does not pursue its target See Command_Squad for a list of all the possible squadCommands

 
void  Command_SquadEntityBool( Player* player, SGroup* sgroup, SquadCommandType squadCommand, EGroup* target, bool cmdparam, bool queued )
 	
Send a entity command to a squad group with custom BOOLEAN data 

 
void  Command_SquadEntityExt( Player* player, SGroup* sgroup, SquadCommandType squadCommand, EGroup* target, uint32_t cmdparam, bool queued )
 	
Send a entity command to a squad group with custom data 

 
void  Command_SquadEntityLoad( Player* player, SGroup* sgroup, SquadCommandType squadCommand, EGroup* target, bool bOverLoad, bool queued )
 	
Send special squad command to a squad group with squad load parameters 

This is a special command for loading squads into building (entity) holds (SCMD_Load, SCMD_InstantLoad)

 
void  Command_SquadExt( Player* player, SGroup* sgroup, SquadCommandType squadCommand, uint32_t cmdparam, bool queued )
 	
Send a squad command to a squad group with custom data 

 
void  Command_SquadMovePos( Player* player, SGroup* sgroup, ScarPosition target, bool queued, bool reverseMove )
 	
Send a move to position command for a squad group. 

Use this function to issue move orders that require a position to a squad group

 
void  Command_SquadMovePosFacing( Player* player, SGroup* sgroup, ScarPosition target, ScarPosition facing, bool queued, bool reverseMove )
 	
Send a move-facing command to a squad group 

 
void  Command_SquadPos( Player* player, SGroup* sgroup, SquadCommandType squadCommand, ScarPosition target, bool queued )
 	
Send a position command to a squad group. 

Use this function to issue orders that require a position to a squad group (eg. order a squad to move to position, or attack position)<BR/> See Command_Squad for a list of all the possible squadCommands.

 
void  Command_SquadPosAbility( Player* player, SGroup* sgroup, ScarPosition pos, ScarAbilityPBG abilityPBG, bool skipCostPrereq, bool queued )
 	
Send a positional ability command (SCMD_Ability) to a squad 

 
void  Command_SquadPosExt( Player* player, SGroup* sgroup, SquadCommandType squadCommand, ScarPosition target, uint32_t cmdparam, bool queued )
 	
Send a position command to a squad group with custom data 

 
void  Command_SquadPositionAttack( Player* player, SGroup* sgroup, ScarPosition target, bool bCheckFOW, bool bStationary, const char* planName, bool queued )
 	
Send an position command ATTACK to a squad group. 

Use this function to issue an position-based command to a squad group with custom FOW check flag. (eg. order a squad to attack a building)<BR/> planName is the name of the custom plan file to execute. Pass in empty string to use the default<BR/> stationary flag uses SCMD_StationaryAttack instead where plan file is ignored and squad does not pursue its target See Command_Squad for a list of all the possible squadCommands

 
void  Command_SquadSquad( Player* player, SGroup* sgroup, SquadCommandType squadCommand, SGroup* target, bool queued )
 	
Send an squad-based command to a squad group. 

Use this function to issue a squad-based command to a squad group. <BR/> See Command_Squad for a list of all the possible squadCommands

 
void  Command_SquadSquadAbility( Player* player, SGroup* sgroup, SGroup* target, ScarAbilityPBG abilityPBG, bool skipCostPrereq, bool queued )
 	
Send a squad ability command (SCMD_Ability) to a squad 

 
void  Command_SquadSquadAttack( Player* player, SGroup* sgroup, SGroup* target, bool bCheckFOW, bool bStationary, const char* planName, bool queued )
 	
Send an squad-based command to a squad group. 

Use this function to issue a squad-based command to a squad group with special boolean flag. (eg. order a squad to attack another squad)<BR/> If bCheckFOW is set to false, the squad would be able to attack other squads hidden in FOW <BR/> planName is the name of the custom plan file to execute. Pass in empty string to use the default<BR/> stationary flag uses SCMD_StationaryAttack instead where plan file is ignored and squad does not pursue its target See Command_Squad for a list of all the possible squadCommands

 
void  Command_SquadSquadExt( Player* player, SGroup* sgroup, SquadCommandType squadCommand, SGroup* target, uint32_t cmdparam, bool queued )
 	
Send a squad command to a squad group with custom data 

 
void  Command_SquadSquadLoad( Player* player, SGroup* sgroup, SquadCommandType squadCommand, SGroup* target, bool bOverLoad, bool queued )
 	
Send special squad command to a squad group with squad load parameters 

This is a special command for loading squads into vehicle (squad) holds (SCMD_Load, SCMD_InstantLoad)

 
void  Command_SquadUpgrade( Player* player, SGroup* sgroup, ScarUpgradePBG upgrade, bool instant, bool queued )
 	
Sends an upgrade command to a squad group. 

 
 

 

DesignerLib
Functions

Void  AutoCinematic( Boolean in/out, Real seconds )
 	
Toggles all cinematic related settings. true = go to cinematic, false = go back to normal 

 
Void  AutoReinforce_AddSGroup( SGroupID sgroup, Variable origin )
 	
Adds an SGroup to the auto-reinforce functions 

 
Void  AutoReinforce_RemoveAll( )
 	
Stops monitoring all squads from the auto-reinforce functions 

 
Void  AutoReinforce_RemoveSGroup( SGroupID sgroup )
 	
Removes an SGroup from the auto-reinforce functions 

 
Void  AutoRetreat_AddSGroup( SGroupID sgroup, MarkerID/Position/EGroupID destination[, Real threshold, LuaFunction onTrigger] )
 	
Sets an sgroup to retreat to the given destination or building once pinned for a certain duration, or reduced to a third of it's original size 

The optional threshold value should be a percentage (between 0.0 and 1.0) - when the member count drops below this, they retreat

 
Void  AutoRetreat_RemoveAll( )
 	
Stops monitoring all squads from the auto-retreat functions 

 
Void  AutoRetreat_RemoveSGroup( SGroupID sgroup )
 	
Removes a squad from being monitored by the auto-retreat functions 

 
Void  BridgeTerritory_Add( EGroupID bridge_egroup, EGroupID bridgepoint, EGroupID bank1point, EGroupID bank2point )
 	
Add a bridge to the Bridge Territory Manager.  

bridgepoint, bank1point and bank2point should be egroups each containing one territory flag

 	Source: [coh2\BIA\root\CoH2\Data\Scar/DesignerLib.scar] (1006) 
References: [Bridge+Territory+Manager]

Void  Ceasefire_AddSGroup( SGroupID sgroup[, LuaFunction function] )
 	
Stops an SGroup from auto-targetting, until one of their members is explicity given an attack order or Ceasefire_RemoveSGroup() is called (at which point they all start firing again) 

You can optionally specify a function that will be called when the ceasefire is broken by the game (rather than by calling Ceasefire_RemoveSGroup)

 
Void  Ceasefire_RemoveSGroup( SGroupID sgroup )
 	
Removes the ceasefire effect from an sgroup. This may already have been removed by issuing an attack order directly to the group. 

 
Void  FireTargettingArtillery( SGroupID/Player caster, SGroupID target, Table targettingData )
 	
Uses targettingData to determine if a target has moved or not and progressively homes-in on it. 

See DesignerLib.scar for details on targettingData values.

 
Void  Game_DefaultGameRestore( )
 	
Restores various aspects of the single player game after loading a mission from a save game 

 
Void  Game_GetGameRestoreCallbackExists( Function callback )
 	
Checks whether a callback  

 
Void  Game_RemoveGameRestoreCallback( Function callback )
 	
Removes a callback from being called on game restore 

 
Void  Game_SetGameRestoreCallback( Function callback )
 	
Adds a function and set of arguments to be automatically called during restore from a saved game. Maxiumum of 9 parameters. Callback will be called like this: Callback(arg[1], arg[2], ...) 

 
Void  Resources_Disable( )
 	
Disables any resource income - useful to stop resources accruing during the opening movie 

 
Void  Resources_Enable( )
 	
Re-enables resource income.  

 
Void  ShootTheSky_AddSyncWeapon( SyncWeaponID syncweapon, PlayerID player )
 	
Forces a sync weapon to shoot at the sky, so long as it's manned by a given player. 

 
Void  ShootTheSky_RemoveAll( )
 	
Stops all sync weapons from going through their "shooting at the sky" routine. 

 
Void  ShootTheSky_RemoveSyncWeapon( SyncWeaponID syncweapon )
 	
Removes a sync weapon from the "shoot at the sky" system. It can then target people again. 

 
Void  SmokeEntrance_Do( MarkerID marker )
 	
Triggers smoke to come in from the map edge, at the position and direction of the given marker 

 
Boolean  Table_Contains( LuaTable OriginalTable, Item item )
 	
Checks if a table contains the specified item  

 
LuaTable  Table_Copy( LuaTable OriginalTable )
 	
Copies the contents of the original table returns a new table with the contents of that table  

 
Item/Table  Table_GetRandomItem( Table table[, Integer numberofitems] )
 	
Returns a random item from a table. You can return multiple items (without duplicates) by passing in an optional number parameter. 

 
Void  TeamWeapon_AddGroup( SGroupID/EGroupID group, Table facingdirections, Integer currentfacing, Boolean threatarrow, Integer turnTime, Integer totalResponses] )
 	
Add a gun to the gun manager. The manager will take care of turning it around to attack units. Turntime is how often the weapon can turn (default 10 seconds), Total Responses is how many times he will adjust before stopping. 

If you pass in an EGroup, it will automatically find or create a corresponding SGroup with sg_ instead of the eg_ prefix.

 	Source: [coh2\BIA\root\CoH2\Data\Scar/DesignerLib.scar] (1126) 
References: [AT+Gun+Manager]

Void  TeamWeapon_RemoveDirections( SGroupID/EGroupID/SyncWeaponID gun )
 	
Remove's the direction settings for a gun, turning it into a fire-at-anything type.  

Use this if you are relocating a gun. Also removes any special first-trigger speech if you have any hooked up, as it may no longer be suitable if you're moving it.

 	Source: [coh2\BIA\root\CoH2\Data\Scar/DesignerLib.scar] (1214) 
References: [AT+Gun+Manager]

Void  TeamWeapon_RemoveGroup( SGroupID/EGroupID/SyncWeaponID gun )
 	
Remove a gun from the gun manager. 

 	Source: [coh2\BIA\root\CoH2\Data\Scar/DesignerLib.scar] (1182) 
References: [AT+Gun+Manager]

 

 

EGroup
Functions

void  EGroup_Add( EGroup* group, Entity* entity )
 	
Adds an entity to the end of a group if the group doesnt already have it. 

 
void  EGroup_AddEGroup( EGroup* group, EGroup* grouptoadd )
 	
Appends the entities in one group to another group.  

All entities from 'grouptoadd' will be added to 'group'.<BR/> If 'group' already contains an entity from 'grouptoadd' it will not be added.<BR/> This function does not clear the contents of 'grouptoadd'.<BR/> Example: Add group2 (0, 10, 11, 22) to group1 (1, 11, 20) --> group1 would now be (1, 11, 20, 0, 10, 22)<BR/>

 
Boolean  EGroup_CanSeeEGroup( EGroupID egroup, EGroupID targetegroup, Boolean all )
 	
Returns true if ALL or ANY entities in a group can see ALL or ANY entities in a given egroup. 

 
Boolean  EGroup_CanSeeSGroup( EGroupID egroup, SGroupID targetsgroup, Boolean all )
 	
Returns true if ALL or ANY entities in a group can see ALL or ANY squads in a given sgroup. 

 
void  EGroup_Clear( EGroup* egroup )
 	
Removes all entities from a group 

 
bool  EGroup_Compare( EGroup* group1, EGroup* group2 )
 	
Returns true if the contents of the two groups are equal. Order of the entities does not matter. 

 
Boolean  EGroup_ContainsBlueprints( EGroupID egroup, BP/Table blueprint, Boolean all )
 	
Check if a group contains ALL or ANY of the blueprints. 

 
Boolean  EGroup_ContainsEGroup( EGroupID egroup1, EGroupID egroup2, Boolean all )
 	
Returns true if EGroup1 contains ANY or ALL of EGroup2 

 
Boolean  EGroup_ContainsEntity( EGroupID egroup, EntityID entity )
 	
Returns true if EGroup contains a particular EntityID 

 
int  EGroup_Count( EGroup* egroup )
 	
Returns the total number of spawned and despawned entities in a group. 

 
int  EGroup_CountAlive( EGroupID egroup )
 	
Get the number of alive entities (both spawned and despawned) 

 
int  EGroup_CountDeSpawned( EGroup* egroup )
 	
Returns the number of despawned entities in a group. 

 
int  EGroup_CountSpawned( EGroup* egroup )
 	
Returns the number of spawned entities in a group. 

 
EGroup*  EGroup_Create( const char* name )
 	
Returns a new entity group with the given name. 

Entity groups are used for buildings and objects such as rocks and trees.<BR/> If you need to issue orders to a group vehicles or units you must use a SquadGroupObs.

 
EGroupID  EGroup_CreateIfNotFound( String egroupname )
 	
Find a entity group from name. Creates a new one with given name if it doesnt exist. 

 
Void  EGroup_CreateKickerMessage( EGroupID group, LocString textid )
 	
Create and display kicker message on the each entity in the egroup to the player 

 
Void  EGroup_DeSpawn( EGroupID egroup )
 	
Despawn all spawned entities in a group. 

 
void  EGroup_Destroy( EGroup* egroup )
 	
Manually destroy a group that you dont need anymore. 

 
Void  EGroup_DestroyAllEntities( EGroupID egroup )
 	
Destroys all spawned and despawned entities in a group. 

Be careful not to confuse this with EGroup_Destroy which destroys the group and NOT the items it contains. This function will destroy spawned and despawned items in a group

 
Void  EGroup_Duplicate( EGroupID egroupid1, EGroupID egroupid2 )
 	
Duplicates an EGroup 

Creates a copy of egroup1 in egroup2. The function will clear egroup2 beforehand if necessary.

 
Void  EGroup_EnableMinimapIndicator( EGroupID egroup, Boolean enable )
 	
Enables or disables the minimap indicator for all entities in a group 

 
Void  EGroup_EnableUIDecorator( SGroupID group, Boolean enable, Boolean enableSelection )
 	
Enable or disable decorators on all entities in the egroup. Sets selection visuals as well unless enableSelection is specified. 

 
bool  EGroup_Exists( const char* name )
 	
Returns true if the entity group with the given name exists 

 
Void  EGroup_Filter( EGroupID egroup, String/ID/Table blueprint, Integer filtertype )
 	
Filters an EGroup by blueprint. 

Blueprints can be provided by name or by ID, and in a table if you want to filter on more than one type. Setting filtertype to FILTER_KEEP results in the group only containing entities of the types listed in the blueprint table. Setting filtertype to FILTER_REMOVE will strip those same entities out and leave those that aren't of the types listed.

 
Void  EGroup_FilterUnderConstruction( EGroupID egroup, Integer filtertype )
 	
Filters an EGroup by construction status. 

Setting filtertype to FILTER_KEEP results in the group only containing those entities that are in the process of being built. Setting filtertype to FILTER_REMOVE will strip those same entities out and leave those that are complete.

 
bool  EGroup_ForEach( EGroup* egroup, LuaBinding::StackVarFunction f )
 	
Call a lua function for each item in a group. Function will recieve (groupid, itemindex, itemid) and should return true to break or false to continue. 

function Rule_Test( )<BR/> <TAB/>local DespawnEntity = function( egroupid, itemindex, entityID )<BR/> <TAB/><TAB/>Entity_Despawn( entityID )<BR/> <TAB/>end<BR/><BR/> <TAB/>EGroup_ForEach( EGroup_FromName("eg_PlayersHQ"), DespawnEntity )<BR/> end<BR/> Note: This function iterates over SPAWNED ENTITIES ONLY.

 
bool  EGroup_ForEachAllOrAny( EGroup* egroup, bool all, LuaBinding::StackVarFunction f )
 	
Call a lua function for each item in a group. Function will receive (groupid, itemindex, itemid) and should return a bool. 

Only use this to TEST conditions on entities. DO NOT use this to perform operations on all entities, since it may not call your function on all entities (due to short circuit evaluation). This is used for checking if ALL or ANY items in a group match a given predicate. (eg. Are all items in a group chaos marines)<BR/> Note: This function iterates over SPAWNED ENTITIES ONLY.

 
bool  EGroup_ForEachAllOrAnyEx( EGroup* egroup, bool all, LuaBinding::StackVarFunction f, bool spawned, bool despawned )
 	
Same as EGroup_ForEachAllOrAny except you have a choice to iterate over spawned entities, despawned entities, or both. 

 
bool  EGroup_ForEachEx( EGroup* egroup, LuaBinding::StackVarFunction f, bool spawned, bool despawned )
 	
Same as EGroup_ForEach except you have a choice to iterate over spawned entities, despawned entities, or both. 

 
EGroup*  EGroup_FromName( const char* name )
 	
Find an entity group with a given name. 

 
Real  EGroup_GetAvgHealth( EGroupID egroup )
 	
Returns the average health of all units in a entity group. 

This uses the "proper" measure of health for panel buildings, so should accurately reflect what the user sees.

 
Entity*  EGroup_GetDeSpawnedEntityAt( EGroup* group, unsigned int index )
 	
Returns the despawned entity at the given index. 

Use EGroup_GetSpawnedEntityAt if you want the spawned items in the group<BR/> Use index 1 to get the first entity in the group.<BR/> It is an error if index > EGroup_GetCountDeSpawned()<BR/>

 
Boolean  EGroup_GetInvulnerable( EGroupID egroup, Boolean all )
 	
Check invulnerablity state for ALL or ANY entity in an entity group. 

Set all param to true to check for ALL or set to false to check for ANY.

 
Void  EGroup_GetLastAttacker( EGroup EGroupVictim, SGroup SGroupAttacker )
 	
Gets the last attacker(s) for all the entities in an EGroup Gets the last attacker for all the squads in an SGroup and stores that in SGroupAttacker 

 
const char*  EGroup_GetName( EGroup* egroup )
 	
Returns the name of a given entity group. 

 
Position  EGroup_GetOffsetPosition( EGroupID egroup, Integer offset, Real value )
 	
Returns a position (a certain distance away) relative to an entity's current position/orientation. see LuaConsts.scar for explanation of 'offset' parameter 

 
ScarPosition  EGroup_GetPosition( EGroup* group )
 	
Returns the center position of an entity group. 

 
EntityID  EGroup_GetRandomSpawnedEntity( EGroup egroupid )
 	
Get a random spawned entity from egroup 

 
Table  EGroup_GetSequence( String name )
 	
Builds a table of EGroupIDs that are named in a sequence. i.e. a name of "eg_building" will find groups "eg_building1", "eg_building2" and so on, up until it looks for a group that isn't there. 

 
Entity*  EGroup_GetSpawnedEntityAt( EGroup* group, unsigned int index )
 	
Returns the spawned entity at the given index. 

Use EGroup_GetDeSpawnedEntityAt if you want the despawned items in the group<BR/> Use index 1 to get the first entity in the group.<BR/> It is an error if index > EGroup_GetCountSpawned()<BR/>

 
EntityID or NIL if none met condition  EGroup_GetSpawnedEntityFilter( EGroup egroupid, function condition(entity) )
 	
Get the first spawned entity from egroup that meets the condition (a function that takes an entity) 

 
Real  EGroup_GetSpread( EGroupID egroup )
 	
Returns the distance from the centre of the group of the entity that furthest out.  

 
Void  EGroup_GetSquadsHeld( EGroupID egroup, SGroupID sgroupRecipient )
 	
Returns an sgroup containing all squads held by any entities in an egroup 

 
Boolean  EGroup_HasUpgrade( EGroupID egroup, UpgradeID upgrade, Boolean all )
 	
Returns whether ANY or ALL entities in an EGroup have the specified upgrade 

 
Void  EGroup_Hide( EGroupID egroup, Bool hide )
 	
Hide or show all entities in an EGroup 

Bool should be true to hide, false to show

 
Void  EGroup_InstantCaptureStrategicPoint( EGroupID egroup, PlayerID player )
 	
Change the ownership of a Strategic Point 

 
Void  EGroup_InstantRevertOccupiedBuilding( EGroupID egroup )
 	
Reverts an occupied building 

 
void  EGroup_Intersection( EGroup* group, EGroup* grouptointersect )
 	
Performs a group intersection.  

Only entities that are in both groups will be added to 'group'.<BR/> The contents of 'grouptointersect' will not be changed.<BR/> Example: group = (1,2,3,4,5,6) grouptointersect = (2,4,6,8,10) --> group will now equal (2,4,6)

 
Boolean  EGroup_IsBurning( EGroupID egroup, Boolean ALL )
 	
Checks if ANY or ALL entities in an egroup are on fire (ignition threshold exceeded) 

 
Boolean  EGroup_IsCapturedByPlayer( EGroupID egroup, PlayerID playerId, Boolean all )
 	
Returns true if all or any strategic points in a group have been captured. Use ANY or ALL. 

This function will ignore all entities that cannot be captured and will return false if no entities in the group can be captured.

 
Boolean  EGroup_IsCapturedByTeam( EGroupID egroup, TeamID teamId, Boolean all )
 	
Returns true if all or any strategic points in a group have been captured. Use ANY or ALL. 

This function will ignore all entities that cannot be captured and will return false if no entities in the group can be captured.

 
Boolean  EGroup_IsDoingAttack( EGroupID egroup, Boolean all, Float time )
 	
Returns true if ALL or ANY entities are attacking within the time 

 
Boolean  EGroup_IsEmpty( EGroupID egroup )
 	
Returns true if a named entity group contains no spawned or despawned entities 

 
Void  EGroup_IsHoldingAny( EGroupID egroup )
 	
Returns whether any entity in an EGroup has a hold on anything 

 
Boolean  EGroup_IsInCover( EGroupID egroup, Boolean all )
 	
Returns true if ALL or ANY entities are in cover. 

 
Boolean  EGroup_IsMoving( EGroupID egroupid, Boolean all )
 	
Returns true if ANY or ALL entities in an EGroup are moving. 

 
Bool  EGroup_IsOnScreen( PlayerID player, EGroupID group, Bool all[, Float percent] )
 	
Returns true if ANY or ALL (use those keywords) of the enities in the group are present onscreen. You can pass in a percentage of the screen to check, so 0.8 would be a centered rectangle occupying 80% of the screen. 

 
Boolean  EGroup_IsProducingSquads( EGroupID egroup, Boolean all )
 	
Returns true if ALL or ANY entities in a group are currently producing squads 

Set all to true to check for ALL or set to false to check for ANY

 
Boolean  EGroup_IsSpawned( EGroupID egroup, Boolean ALL )
 	
Checks if ANY or ALL entities in an group are currently spawned or not. 

 
Boolean  EGroup_IsUnderAttack( EGroupID egroup, Boolean all, Float time )
 	
Returns true if ALL or ANY entities are under attack within the time 

 
Bool  EGroup_IsUnderAttackByPlayer( EGroupID group, PlayerID attackerplayer, Float duration )
 	
Check if the entities are attacked by the player 

 
Boolean  EGroup_IsUnderAttackFromDirection( EGroupID egroup, Boolean all, Integer/Table offset, Float time )
 	
Returns true if ALL or ANY entities are under attack from a direction within the time. see LuaConsts.scar for types of directions. you can pass in a table of offsets 

 
Boolean  EGroup_IsUsingAbility( EGroupID egroup, Boolean ALL )
 	
Checks if ANY or ALL squads within an EGroup are using an ability 

also used for emplacements/entities that are built but function through the use of squads. Does not check WHAT ability a squad is using.

 
Void  EGroup_Kill( EGroupID egroup )
 	
Kill all entities in an EGroup 

 
Void  EGroup_NotifyOnPlayerDemolition( EGroupID id, LuaFunction function )
 	
Calls a function when any entity in an EGroup gets destroyed by the player clicking the "Detonate me" button 

 
void  EGroup_Remove( EGroup* group, Entity* entity )
 	
Removes an entity from a group. 

 
Void  EGroup_RemoveDemolitions( EGroupID egroup )
 	
Removes all demolition charges on an egroup 

 
Void  EGroup_RemoveGroup( SGroupID group, SGroupID grouptoremove )
 	
Remove from the first SGroup all squads contained in the second SGroup. SGroup2 remains untouched. 

 
Void  EGroup_RemoveUpgrade( EGroupID egroup, UpgradeBlueprint/Table upgrade )
 	
Removes upgrade(s) from an egroup 

 
Void  EGroup_ReSpawn( EGroupID egroup )
 	
Respawn all despawned entities in a group. 

 
Void  EGroup_SetAnimatorAction( EGroupID egroup, String actionName )
 	
Trigger animation action for an EGroup. Please only use this for simple animations 

 
Void  EGroup_SetAnimatorEvent( EGroupID egroup, String eventName )
 	
Set animation event for an EGroup. Please only use this for simple animations 

 
Void  EGroup_SetAnimatorState( EGroupID egroup, String stateMachineName, String stateName )
 	
Set animation state of a state machine for an EGroup. Please only use this for simple animations 

 
Void  EGroup_SetAnimatorVariable( EGroupID egroup, String variableName, Real value )
 	
Set animation variable value for an EGroup. Please only use this for simple animations 

 
Void  EGroup_SetAutoTargetting( EGroupID group, String hardpoint, Bool enable )
 	
Sets whether a weapon to auto-target things or not 

 
Real  EGroup_SetAvgHealth( EGroupID egroup, Real healthPercent )
 	
Sets the health of each unit in an entity group to a given percent [0.0, 1.0]. 

 
Void  EGroup_SetCrushable( EGroupID egroup, Boolean crushable )
 	
Overrides crushable behavior for an egroup 

 
Void  EGroup_SetDemolitions( PlayerID player, EGroupID egroupid[, Integer numcharges] )
 	
Instantly wires a building for demolitions 

 
Void  EGroup_SetHealthMinCap( EGroupID egroup, float minhealth )
 	
Set the minimum health for this entity 

This is usually set to zero, any higher value prevents the entity from having its health reduced below this given value

 
Void  EGroup_SetInvulnerable( EGroupID egroup, Boolean enabled[, Float reset_time] )
 	
Enable/Disable invulnerablity for an entire entity group. Use true and false for simple on/off, or use a number between 0.0 and 1.0 for more precise control on how much damage an entity can take before it takes no more. 

The optional reset_time is used to automatically remove invulnerability after a set time. If invulnerable, both health and critical damage are disabled.

 
Void  EGroup_SetPlayerOwner( EGroup egroup, PlayerID owner )
 	
Changes the player owner for all spawned and despawned entities of an EGroup. 

Strategic/capturable point does not support setting player owner directly

 
Void  EGroup_SetRallyPoint( EGroupID egroup, Position target )
 	
Set the rally point for this entity 

This is usually set to zero, any higher value prevents the entity from having its health reduced below this given value

 
Void  EGroup_SetRecrewable( EGroupID sgroup, Boolean recrewable )
 	
Sets all entities in an egroup to be recrewable or not when abandoned 

 
Void  EGroup_SetSelectable( EGroupID egroup, Bool selectable )
 	
Set player selectable state of entities in the egroup 

 
Void  EGroup_SetSharedProductionQueue( EGroupID egroup, Boolean enable )
 	
Enables shared team production on a building (teammates can build using THEIR resources) 

 
Void  EGroup_SetStrategicPointNeutral( EGroupID egroup )
 	
Sets a strategic point to neutral (not owned by any team)  

 
Void  EGroup_SetWorldOwned( EGroupID egroup )
 	
Makes an egroup neutral 

 
EGroupID  EGroup_Single( EGroupID egroup, entityID entity )
 	
Creates an entity group containing a single entity 

Creates an EGroup containing just one entity, creating the group if it doesn't exist and clearing it if it does. It returns the name of the EGroup.

 
Boolean  SGroup_HasEntityUpgrade( EGroupID egroup, UpgradeID upgrade, Boolean all )
 	
Returns true if ANY or ALL of the squad's entities have the specified upgrade 

 
 

 

Encounter
Functions

Table  Ai:GetEncountersBySGroup( SGroup sgroup, ANY/ALL all )
 	
Finds all encounters that contain ANY or ALL squads within the given sgroup. 

 
Table  Ai:GetEncountersBySquad( SGroup sgroup, ANY/ALL all )
 	
Finds all encounters that contain ANY or ALL squads within the given sgroup. 

 
Void  AI_DisableAllEncounters( Void  )
 	
Disables all encounters 

 
Void  AI_EnableAllEncounters( Void  )
 	
Enables all encounters 

 
Table  AI_GetActiveEncounters( Void  )
 	
Returns a table with all active (not dead) encounters. 

 
Int  AI_GetNumEncounters( Void  )
 	
Returns the number of alive encounters currently managed by the AI manager. 

 
Boolean  AI_IsMatchingDifficulty( Int/Table difficultyList )
 	
Returns True if the current AI_Manager difficulty matches any in a given list. 

 
Void  AI_OverrideDifficulty( Int level )
 	
Overrides the current difficulty setting (only for the AI Manager). Pass 'nil' to reset to Game_GetSPDifficulty() value 

 
Void  AI_RemoveAllEncounters( Void  )
 	
Disables all encounters, then clears out the encounter list 

 
Void  AI_SetDebugLevel( Void  )
 	
Set the level of debug information shown but Ai:Print(). 

 
Void  AI_SetStaggeredSpawnDelay( Float delay )
 	
Sets the delay to use when using staggeredSpawn for encounters. The new interval will take effect immediately. 

 
Void  AI_ToggleDebugData( Void  )
 	
Toggle encounter/goal debug information on screen. 

 
Void  AI_ToggleDebugPrint( Void  )
 	
Toggle printing console debug information for encounters. 

 
Void  AIAbilityGoal_AdjustDefaultGoalData( Table additionalDefaultGoalData )
 	
Adjust default goal data for ability goals. Sets the default GoalData to the current defaults plus additionalDefaultGoalData; any values specified are used for unspecified encounter ability goal values. 

 
Void  AIAbilityGoal_SetDefaultGoalData( Table defaultGoalData )
 	
Set default goal data for ability goals. defaultGoalData is cloned; any values specified are used for unspecified encounter ability goal values. 

 
Void  AIAbilityGoal_SetModifyGoalData( Table modifyGoalData )
 	
Set modify goal data for ability goals. modifyGoalData is cloned; values specified via keyname_Multiplier are used for the numeric keyname encounter ability goal value. 

 
Void  AIAbilityGoal_SetOverrideGoalData( Table overrideGoalData )
 	
Set override goal data for ability goals. overrideGoalData is cloned; any values specified are used for encounter ability goal values. 

 
Void  AIAttackGoal_AdjustDefaultGoalData( Table additionalDefaultGoalData )
 	
Adjust default goal data for attack goals. Sets the default GoalData to the current defaults plus additionalDefaultGoalData; any values specified are used for unspecified encounter attack goal values. 

 
Void  AIAttackGoal_SetDefaultGoalData( Table defaultGoalData )
 	
Set default goal data for attack goals. defaultGoalData is cloned; any values specified are used for unspecified encounter attack goal values. 

 
Void  AIAttackGoal_SetModifyGoalData( Table modifyGoalData )
 	
Set modify goal data for attack goals. modifyGoalData is cloned; values specified via keyname_Multiplier are used for the numeric keyname encounter attack goal value. 

 
Void  AIAttackGoal_SetOverrideGoalData( Table overrideGoalData )
 	
Set override goal data for attack goals. overrideGoalData is cloned; any values specified are used for encounter attack goal values. 

 
Void  AIBaseGoal_AdjustDefaultGoalData( Table additionalDefaultGoalData )
 	
Adjust default goal data. Sets the default GoalData to the current defaults plus additionalDefaultGoalData; any values specified are used for unspecified encounter goal values. 

 
Void  AIBaseGoal_SetDefaultGoalData( Table defaultGoalData )
 	
Set default goal data. defaultGoalData is cloned; any values specified are used for unspecified encounter goal values. 

 
Void  AIBaseGoal_SetModifyGoalData( Table modifyGoalData )
 	
Set modify goal data. modifyGoalData is cloned; values specified via keyname_Multiplier are used for the numeric keyname encounter goal value. 

 
Void  AIBaseGoal_SetOverrideGoalData( Table overrideGoalData )
 	
Set override goal data. overrideGoalData is cloned; any values specified are used for encounter goal values. 

 
Void  AIDefendGoal_AdjustDefaultGoalData( Table additionalDefaultGoalData )
 	
Adjust default goal data for defend goals. Sets the default GoalData to the current defaults plus additionalDefaultGoalData; any values specified are used for unspecified encounter defend goal values. 

 
Void  AIDefendGoal_SetDefaultGoalData( Table defaultGoalData )
 	
Set default goal data for defend goals. defaultGoalData is cloned; any values specified are used for unspecified encounter defend goal values. 

 
Void  AIDefendGoal_SetModifyGoalData( Table modifyGoalData )
 	
Set modify goal data for defend goals. modifyGoalData is cloned; values specified via keyname_Multiply are used for the numeric keyname encounter defend goal value. 

 
Void  AIDefendGoal_SetOverrideGoalData( Table overrideGoalData )
 	
Set override goal data for defend goals. overrideGoalData is cloned; any values specified are used for encounter defend goal values. 

 
Void  AIMoveGoal_AdjustDefaultGoalData( Table additionalDefaultGoalData )
 	
Adjust default goal data for move goals. Sets the default GoalData to the current defaults plus additionalDefaultGoalData; any values specified are used for unspecified encounter move goal values. 

 
Void  AIMoveGoal_SetDefaultGoalData( Table defaultGoalData )
 	
Set default goal data for move goals. defaultGoalData is cloned; any values specified are used for unspecified encounter move goal values. 

 
Void  AIMoveGoal_SetModifyGoalData( Table modifyGoalData )
 	
Set modify goal data for move goals. modifyGoalData is cloned; values specified via keyname_Multiply are used for the numeric keyname encounter move goal value. 

 
Void  AIMoveGoal_SetOverrideGoalData( Table overrideGoalData )
 	
Set override goal data for move goals. overrideGoalData is cloned; any values specified are used for encounter move goal values. 

 
Void  Encounter:AddSgroup( Void  )
 	
Adds an sgroup to an encounter 

 
Void  Encounter:ClearGoal( Void  )
 	
Clears the current goal. 

 
Encounter  Encounter:ConvertSgroup( SGroup squadgroup )
 	
Create a new encounter from an SGroup, with default encounter data 

Encounter player is derived from sgroup; all squads in sgroup must be owned by same player.

 
Encounter  Encounter:Create( EncounterData data[, Bool spawnNow, Bool spawnStaggered] )
 	
Create a new encounter from encounter data. If spawnNow is true, spawns specified units immediately. 

See: http://relicwiki/display/REL/Ai+Encounters

 
Encounter  Encounter:CreateAbility( String name, SBP/Table encUnits, Marker/Pos spawnLoc, EGroup/SGeoup/Marker/Pos encTarget[, Marker/Pos dynamicSpawn, INT moveRange] )
 	
Create a new encounter with a generic Ability goal. 

 
Encounter  Encounter:CreateAttack( String name, SBP/Table encUnits, Marker/Pos spawnLoc, EGroup/SGeoup/Marker/Pos encTarget[, Marker/Pos dynamicSpawn, Marker/INT encRange, Marker/INT encLeash] )
 	
Create a new encounter with a generic Attack goal. 

 
Encounter  Encounter:CreateBasic( String name, Marker/Pos spawnLoc, SBP/Table encUnits[, Marker/Pos dynamicSpawn] )
 	
Create a new basic encounter. 

 
Encounter  Encounter:CreateDefend( String name, SBP/Table encUnits, Marker/Pos spawnLoc, EGroup/SGeoup/Marker/Pos encTarget[, Marker/Pos dynamicSpawn, Marker/INT encRange, Marker/INT encLeash] )
 	
Create a new encounter with a generic Defend goal. 

 
Encounter  Encounter:CreateMove( String name, SBP/Table encUnits, Marker/Pos spawnLoc, EGroup/SGeoup/Marker/Pos encTarget[, Marker/Pos dynamicSpawn, INT moveRange] )
 	
Create a new encounter with a generic Move goal. 

 
Encounter  Encounter:CreatePatrol( String name, SBP/Table encUnits, Marker/Pos spawnLoc, Marker/String encPath[, Marker/Pos dynamicSpawn, INT pathWait, INT pathLoop] )
 	
Create a new encounter with a generic Patrol goal.  

pathLoop can be: LOOP_NONE, LOOP_NORMAL, LOOP_TOGGLE_DIRECTION

 
Void  Encounter:Disable( Void  )
 	
Stops running the encounter and clears the current goal. 

 
Void  Encounter:Enable( Void  )
 	
Starts encounter running (encounters are enabled by default) if it was disabled previously. 

 
GoalData  Encounter:GetGoalData( Void  )
 	
Gets clone of current goal data. May be nil. 

 
SGroup sgroup  Encounter:GetSgroup( Void  )
 	
Gets the encounter's sgroup. Caution: sgroup may be empty 

 
Void  Encounter:RemoveOnDeath( Bool includeUnits )
 	
Clears the encounter's onDeath callback. If includeUnits is set to true, it clears onDeath callbacks for units as well. 

 
Bool  Encounter:RestartGoal( Void  )
 	
If encounter has a goal, but no currently running objective, restarts the goal. 

Returns true if goal was restarted, false otherwise.

 
Void  Encounter:SetGoal( GoalData goalData )
 	
Creates encounter goal from goal data; goals determine unit objectives and behaviours. 

See: http://relicwiki/display/REL/Ai+Goal

 
Void  Encounter:SetGoalOnSuccess( Void  )
 	
Set the goal's OnSuccess callback. 

 
Void  Encounter:SetOnDeath( ScarFn func )
 	
Sets a new onDeath callback for the encounter 

 
Void  Encounter:Spawn( Bool spawnStaggered )
 	
Spawns the units within an. Does nothing if the encounter has already been spawned. 

 
Void  Encounter:UpdateGoal( GoalData goalData )
 	
Sets the goal data for the encounter. If encounter has a goal with a running objective, updates the goal. 

Use GetGoalData() to get

 
Table  MergeClone( Table defaultTable, Table overrideTable )
 	
Merge clones two table (recursively) into a single table combining into a new table allowing for unadulterated use of the data 

 
 

 

Entity
Functions

void  Entity_ApplyCritical( Entity* pEntity, ScarCriticalPBG criticalPBG, float removeAtHealth )
 	
Trigger a critical hit on an entity 

 
void  Entity_BuildingPanelInfo( Entity* pEntity, ScarPosition cam, ScarPosition terrain )
 	
Displays info about the panel that is intersected by the passed in ray 

 
bool  Entity_CanAttackNow( Entity* attacker, ScarPosition target )
 	
Returns whether an entity can attack a target without moving or turning. 

 
void  Entity_CancelProductionQueueItem( Entity* entity, uint32_t index )
 	
Cancels an item in a production queue. Index 0 is the currently producing item. 

 
bool  Entity_CanLoadSquad( Entity* entity, Squad* squad, bool bCheckSquadState, bool bOverload )
 	
Check if the entity can load squad or not 

 
bool  Entity_CanLoadSquadAndAttackCurrentTarget( Entity* entity, Squad* squad, bool bCheckSquadState, bool bOverload )
 	
Check if the entity can load squad and shoot its target after loading (This function should only be called by AI) 

 
bool  Entity_CanSeeEntity( Entity* entity, Entity* target )
 	
Returns true if the distance between a target entity and the source entity is less than it entity's sight distance. There is no LOS or FOW check. 

Try Player_CanSeeEntity() if you care about LOS or FOW.

 
bool  Entity_CanSeeSquad( Entity* entity, Squad* target )
 	
Returns true if the distance between a target squad and the source entity is less than it entity's sight distance. There is no LOS or FOW check. 

Try Player_CanSeeSquad() if you care about LOS or FOW.

 
void  Entity_ClearPostureSuggestion( Entity* entity )
 	
Clears any previous posture suggestions made to an entity 

 
void  Entity_ClearTagDebug( Void  )
 	
Clears the tagged entity used for debugging 

 
void  Entity_CompleteUpgrade( Entity* pEntity, ScarUpgradePBG upgradePBG )
 	
Instantly adds an upgrade to a given entity 

 
Entity*  Entity_Create( ScarEntityPBG ebp, Player* player, ScarPosition pos, ScarPosition toward )
 	
Creates an entity at a given position and assigns it to a given player. 'blueprint' is a string value containing the name of the entity blueprint. This function does not spawn the entity so you will need to call Entity_Spawn to see this entity 

 
Entity*  Entity_CreateENV( ScarEntityPBG ebp, ScarPosition pos, ScarPosition toward )
 	
Creates an entity at a given position and assigns it to a given player. 'blueprint' is a string value containing the name of the entity blueprint. This function spawns the entity so there is no need to call Entity_Spawn 

 
void  Entity_DeSpawn( Entity* entity )
 	
DeSpawn the entity at its current position 

 
void  Entity_Destroy( Entity* entity )
 	
Remove an entity from the world and destroy it. 

 
bool  Entity_DisableBuildingDeath( Entity* pEntity, bool bDisableDeath )
 	
Disables the death of the given entity building, only works for panel based destructible buldings 

 
void  Entity_DoBuildingDamageRay( Entity* pEntity, ScarPosition cam, ScarPosition terrain, size_t dmgType, bool isDestory, float radius )
 	
Damages this entity but only if its a destructible building 

dmgType of 0 is damage accessory, 1 is damage panel, 2 is destroy panel and 3 is destroy radius

 
void  Entity_EnableAttention( Entity* entity, bool attentive )
 	
Sets whether an entity pays attention to its surroundings 

 
void  Entity_EnableProductionQueue( Entity* entity, bool enable )
 	
Sets whether an entity can produce anything (including upgrades) 

 
void  Entity_EnableStrategicPoint( Entity* entity, bool enable )
 	
Sets whether an strategic point is active 

 
void  Entity_ForceConstruct( Entity* e )
 	
Force constructs this entity but only if its a building 

 
Entity*  Entity_FromWorldID( uint32_t id )
 	
Get an entity from a mission editor ID. 

 
EntityStateID  Entity_GetActiveCommand( Entity* entity )
 	
Returns the active entity command. 

 
ScarEntityPBG  Entity_GetBlueprint( Entity* entity )
 	
Returns the entity's blueprint 

 
float  Entity_GetBuildingProgress( Entity* pEntity )
 	
Returns the construction progress (with range [0.0, 1.0] for a given entity. Returns 0.0 if the entity is not a building. 

 
float  Entity_GetCoverValue( Entity* entity )
 	
Get cover safety value from the where the entity is standing. The safety value is number from -.5 to .5. 

Higher value means better cover. If the entity doesn't have cover_ext, value of 0 would be returned

 
uint32_t  Entity_GetGameID( Entity* entity )
 	
Returns the entities unique id in the world 

 
ScarPosition  Entity_GetHeading( Entity* entity )
 	
Returns the heading of the entity. The heading is currently a lua table with three entries (x, y, z) 

 
float  Entity_GetHealth( Entity* entity )
 	
Returns the health of an entity. 

Health will be zero for entities with no health extension.

 
float  Entity_GetHealthMax( Entity* entity )
 	
Returns the max health of an entity. 

Max health will be zero for entities with no health extension.

 
float  Entity_GetHealthPercentage( Entity* entity )
 	
Returns the percentage health, taking into account destructible buildings 

Health will be zero for entities with no health extension nor building destruction

 
Bool  Entity_GetInvulnerable( SquadID squad )
 	
Check if the entity is invulnerable or not 

 
float  Entity_GetInvulnerableMinCap( Entity* entity )
 	
Returns the invulnerable point in terms of percentage 

For buildings, retrieve the percentage value of healthy below which no more panels could be destroyed

 
bool  Entity_GetInvulnerableToCritical( Entity* entity )
 	
get if an entity is invulnerable to critical effects 

 
void  Entity_GetLastAttacker( Entity* entity, SGroup* group )
 	
Find the last squad attacker on this entity. If found, the squad is added to the sgroup 

 
void  Entity_GetLastAttackers( Entity* entity, SGroup* group, float timeSeconds )
 	
Find the squad attackers on this entity from the last seconds specified. If found, the squads are added to the sgroup. Building attackers are ignored 

 
int  Entity_GetMaxCaptureCrewSize( Entity* entity )
 	
Gets the maximum capture crew size from a recrewable entity 

 
Position  Entity_GetOffsetPosition( EntityID entity, Integer offset, Real distance )
 	
Returns a position relative to an entity's current position and orientation. see LuaConsts.scar for explanation of 'offset' parameter. 

 
Player*  Entity_GetPlayerOwner( Entity* entity )
 	
Returns the Player owner of the given entity. Entity MUST NOT be owned by the world. 

Use World_OwnsEntity to make sure entity is not owned by the world before calling this function

 
ScarPosition  Entity_GetPosition( Entity* entity )
 	
Returns the position of the entity. The position is currently a lua table with three entries (x, y, z) 

 
const PropertyBagGroup*  Entity_GetProductionQueueItem( Entity* entity, uint32_t index )
 	
Returns the blueprint for a production queue item with index. 

 
ProductionItemType  Entity_GetProductionQueueItemType( Entity* entity, uint32_t index )
 	
Returns the production type (PITEM_Upgrade, PITEM_Spawn, PITEM_SquadUpgrade, PITEM_SquadReinforce, PITEM_PlayerUpgrade) for a production queue item with index. 

 
uint32_t  Entity_GetProductionQueueSize( Entity* entity )
 	
Returns the number of items in the entities production queue. 

It is an error to call this function on an entity that does not have a production queue.<BR/> Use Entity_HasProductionQueue to check that the entity has a queue.

 
ResourceAmount::ResourceType  Entity_GetResourceType( Entity* entity )
 	
Returns the resource type of this point 

returns RT_Fuel, RT_Munition, RT_Action, RT_Command, RT_Popcap, RT_Invalid. NOTE: only works on player owned points

 
float  Entity_GetSightInnerHeight( Entity* entity )
 	
Returns the inner sight radius for this entity 

Radius will be zero for entities without a sight extension

 
float  Entity_GetSightInnerRadius( Entity* entity )
 	
Returns the inner sight radius for this entity 

Radius will be zero for entities without a sight extension

 
float  Entity_GetSightOuterHeight( Entity* entity )
 	
Returns the outer sight radius for this entity 

Radius will be zero for entities without a sight extension

 
float  Entity_GetSightOuterRadius( Entity* entity )
 	
Returns the outer sight radius for this entity 

Radius will be zero for entities without a sight extension

 
Squad*  Entity_GetSquad( Entity* pEntity )
 	
Returns the Squad for the passed Entity. (May be nullptr) 

 
bool  Entity_GetSquadsHeld( Entity* pEntity, SGroup* sgroup )
 	
Adds squads held by an entity to an SGroup 

 
size_t  Entity_GetTotalPanelCount( Entity* pEntity )
 	
Gets the total number of panels in a building (returns 0 for anything but panel based destructible buldings) 

 
size_t  Entity_GetUndestroyedPanelCount( Entity* pEntity )
 	
Gets the current number of undestroyed panels in a building (returns 0 for anything but panel based destructible buldings) 

 
ScarWeaponPBG  Entity_GetWeaponBlueprint( Entity* entity, int hardPointIndex )
 	
Returns a weapon hardpoint ( 0 indexed ) 

 
size_t  Entity_GetWeaponHardpointCount( Entity* entity )
 	
Returns how many hardpoints an entity has 

 
bool  Entity_HasAnyCritical( Entity* pEntity )
 	
Return true if the entity has any critical applied to it 

 
bool  Entity_HasCritical( Entity* pEntity, ScarCriticalPBG criticalPBG )
 	
Return true if the entity has the given criticalID applied to it 

 
bool  Entity_HasProductionQueue( Entity* entity )
 	
Returns true if an entity has a production queue. 

 
bool  Entity_HasUpgrade( Entity* pEntity, ScarUpgradePBG upgradePBG )
 	
Return true if the entity has purchased the specified upgrade. 

 
void  Entity_InstantCaptureStrategicPoint( Entity* entity, Player* player )
 	
Strategic point will be captured instantly by the team of the supplied player 

 
void  Entity_InstantRevertOccupiedBuilding( Entity* entity )
 	
Reverts an occupied building 

 
uint32_t  Entity_IsAlive( Entity* pEntity )
 	
Returns true if entity is still alive 

 
bool  Entity_IsAttacking( Entity* entity, float time )
 	
Returns true if the entity is attacking within the time 

Time is in seconds

 
bool  Entity_IsBuilding( Entity* e )
 	
Returns true if the given entity is a building 

 
bool  Entity_IsBurning( Entity* e )
 	
Returns true if the given entity is burning (buildings on fire or non-buildings with burn_exts) 

 
bool  Entity_IsCamouflaged( Entity* entity )
 	
Returns whether the entity is camouflaged. 

 
bool  Entity_IsCapturableBuilding( Entity* entity )
 	
Returns true if the entity is a capturable building 

 
bool  Entity_IsCasualty( Entity* entity )
 	
Returns true if entity is a casualty else false 

 
bool  Entity_IsCuttable( Entity* entity )
 	
Returns whether this entity is cuttable 

 
bool  Entity_IsDemolitionReady( Entity* entity )
 	
Returns whether this entity's demolition charges are ready to be detonated 

 
uint32_t  Entity_IsEBPBuilding( ScarEntityPBG ebp )
 	
Returns true if the given blueprint is a building 

 
bool  Entity_IsEBPObjCover( ScarEntityPBG ebp )
 	
Returns true if the given blueprint is objcover 

 
bool  Entity_IsHardpointActive( Entity* entity, int hardPointIndex )
 	
Returns whether a hardpoint is active ( 0 indexed ) 

 
bool  Entity_IsHoldingAny( Entity* entity )
 	
Check if the entity has a hold on anything 

 
Boolean  Entity_IsInCover( EntityID entityId )
 	
Returns true if entity is in cover. 

 
bool  Entity_IsMoving( Entity* pEntity )
 	
Returns whether an entity is moving. 

 
bool  Entity_IsOfType( Entity* entity, const char* type )
 	
Determines if this entity is of the given type. Types are defined in type_ext/unit_type_list 

 
bool  Entity_IsPartOfSquad( Entity* pEntity )
 	
Returns true if the entity is part of a squad 

 
bool  Entity_IsPlane( Entity* pEntity )
 	
Returns whether an entity is a plane (has a flight extension) 

 
bool  Entity_IsSlotItem( Entity* entity )
 	
Return true if the entity is a slot item 

 
bool  Entity_IsSoldier( Entity* pEntity )
 	
Returns whether an entity is a soldier 

 
bool  Entity_IsSpawned( Entity* entity )
 	
if entity is spawned return true 

 
bool  Entity_IsStartingPosition( Entity* entity )
 	
Returns true if the entity is a starting position 

 
bool  Entity_IsStrategicPoint( Entity* entity )
 	
Returns true if the entity is a strategic point. 

 
bool  Entity_IsStrategicPointCapturedBy( Entity* entity, Player* player )
 	
Returns true if strategic point is captured by the team of the player provided. 

 
bool  Entity_IsSyncWeapon( Entity* entity )
 	
Return true if the entity is a team weapon 

 
bool  Entity_IsUnderAttack( Entity* entity, float time )
 	
Returns true if the entity is under attack.  

 
bool  Entity_IsUnderAttackByPlayer( Entity* entity, Player* pAttackerOwner, float time )
 	
Returns true if the entity is under attack by a certain player 

 
bool  Entity_IsUnderAttackFromDirection( Entity* entity, int offset, float timeSeconds )
 	
Returns true if the entity was under attack from a certain direction (8 offset types, see LuaConsts.scar) 

 
bool  Entity_IsValid( uint32_t id )
 	
Check if an entity with the given ID can be found in the world 

 
bool  Entity_IsVaultable( Entity* pEntity )
 	
Returns whether an entity can be vaulted 

 
bool  Entity_IsVehicle( Entity* pEntity )
 	
Returns whether an entity is a vehicle 

 
bool  Entity_IsVictoryPoint( Entity *pEntity )
 	
Returns true if entityID is a victory point 

 
void  Entity_Kill( Entity* entity )
 	
Kill the entity. Sets health to 0, and triggers death effects. 

 
Void  Entity_NotifyOnPlayerDemolition( Entity entity, LuaFunction function )
 	
Calls a function when an entity gets destroyed by the player clicking the "Detonate me" button next to an entity. 

 
void  Entity_RemoveBoobyTraps( Entity* pEntityTarget )
 	
Removes all booby-traps on this entity 

 
void  Entity_RemoveCritical( Entity* pEntity, ScarCriticalPBG criticalPBG )
 	
Remove a critical from a given entity 

 
void  Entity_RemoveDemolitions( Entity* entity )
 	
Removes all demolition charges on an entity 

 
void  Entity_RemoveUpgrade( Entity* entity, ScarUpgradePBG upgrade )
 	
Removes an upgrade from an entity 

 
void  Entity_SetAnimatorAction( Entity* pEntity, const char* actionName )
 	
Trigger animation action for an entity. Please only use this for simple animations 

 
void  Entity_SetAnimatorActionParameter( Entity* pEntity, const char* actionParameterName, const char* actionParameterValue )
 	
Set animation action parameter for an entity. Please only use this for simple animations 

 
void  Entity_SetAnimatorEvent( Entity* pEntity, const char* eventName )
 	
Set animation event for an entity. Please only use this for simple animations 

 
void  Entity_SetAnimatorState( Entity* pEntity, const char* stateMachineName, const char* stateName )
 	
Set animation state of a state machine for an entity. Please only use this for simple animations 

 
void  Entity_SetAnimatorVariable( Entity* pEntity, const char* variableName, float value )
 	
Set animation variable value for an entity. Please only use this for simple animations 

 
void  Entity_SetBuildingVisualFireState( Entity* pEntity, BuildingDestructionExt::BuildingFireState newFireState )
 	
Set the visual fire state of a building (doesn't actually set the building on fire) 

 
void  Entity_SetCrushable( Entity* entity, bool crushable )
 	
Overrides crushable behavior for an entity 

 
void  Entity_SetCrushMode( Entity* entity, CrushExtInfo::CrushMode mode )
 	
Changes the crush mode of a given entity. Entity must have a crush extension. 

 
bool  Entity_SetDemolitions( Player* player, Entity* entity, int numcharges )
 	
Fully wires this entity for demolitions, if it's set up to be demolishable. 'player' is the one that owns the demolitions and can detonate them. 

 
void  Entity_SetEnableCasualty( bool enable, Entity* pEntity )
 	
 
void  Entity_SetHeading( Entity* entity, ScarPosition pos, bool bInterpolate )
 	
Sets the heading of the entity. The position is currently a lua table with three entries (x, y, z) 

 
void  Entity_SetHealth( Entity* entity, float healthPercent )
 	
Set the health of an entity. healthPercent must be in the range [0.0, 1.0]. 

 
Void  Entity_SetInvulnerable( EntityID entity, Bool enable, Float reset_time )
 	
Set invulnerability on the entity. Reset time is in seconds. If it it set, the invulnerability will expire after this time. 

 
void  Entity_SetInvulnerableMinCap( Entity* entity, float minHealthPercentage, float resetTime )
 	
Make an entity invulnerable to physical damage when health is below the minimum health percentage 

resetTime is the time in seconds that vulnerability will be restored.; zero time for reset time means the buff will last forever

 
void  Entity_SetInvulnerableToCritical( Entity* entity, bool invulnerable )
 	
set an entity invulnerable to critical effects. Invulnerable to critical also means that kills a entity will not have effect 

 
void  Entity_SetOnFire( Entity* pEntity )
 	
Sets an object on fire (also works on buildings) 

 
void  Entity_SetPlayerOwner( Entity* entity, Player* owner )
 	
Changes the owner of the given squad. 

This function doesn't work with strategic/capturable point

 
void  Entity_SetPosition( Entity* entity, ScarPosition pos )
 	
Sets the position of the entity. The position is currently a lua table with three entries (x, y, z) 

 
void  Entity_SetProjectileCanExplode( Entity* projectile, bool canExplode )
 	
Sets whether or not a projectile can explode.  

 
void  Entity_SetRecrewable( Entity* entity, bool capturable )
 	
Sets an entity to be recrewable or not when it becomes abandoned 

 
void  Entity_SetSharedProductionQueue( Entity* entity, bool shared )
 	
Enables shared team production on a building (teammates can build using THEIR resources) 

 
void  Entity_SetStrategicPointNeutral( Entity* entity )
 	
Sets a strategic point to neutral (not owned by any team) 

 
void  Entity_SetWorldOwned( Entity* entity )
 	
Makes an entity neutral 

 
void  Entity_SimHide( Entity* entity, bool hide )
 	
Shows/hides the entity in the simulation 

 
void  Entity_Spawn( Entity* entity )
 	
Spawn the entity at its current position 

 
void  Entity_StopAbility( Entity* entity, ScarAbilityPBG ability, bool bEarlyExit )
 	
Abruptly stops an active ability 

 
void  Entity_SuggestPosture( Entity* entity, unsigned posture, float duration )
 	
Suggests a posture to an entity, lasting the passed duration 

Posture of 0 is prone, 1 is kneel/crouch, and 2 is standing. Duration is in seconds, negative means indefinate.

 
bool  Entity_SupportsDemolition( Entity* entity )
 	
Returns whether this entity is set up to have demolitions placed on it 

 
void  Entity_TagDebug( Entity* entity )
 	
Tags the entity to be used for debugging 

 
void  Entity_VisHide( Entity* pEntity, bool bHide )
 	
Hides or shows an entity visually. 

 
void  Misc_DoWeaponHitEffectOnPosition( ScarPosition pos, ScarWeaponPBG weaponPBG, bool penetrated )
 	
Do weapon hit effect on the ground 

WeaponID is the property bag group id; if penetrated is set to false, deflection effect would be played instead

 
float  Misc_GetTerrainHeight( ScarPosition p )
 	
Returns the terrain height at the top-down co-ordinate specified (for terrain entities can walk on only) 

 
void  Misc_ToggleEntities( Void  )
 	
Hide all world entities for NIS performance debugging. 

 
void  ModMisc_MakeCasualtyAction( Entity* pTargetEntity )
 	
Make the passed entity a casualty by triggering the MakeCasualtyAction 

 
void  ModMisc_MakeWreckAction( Entity* pTargetEntity )
 	
Make the passed entity a wreck by triggering the MakeWreckAction 

 
void  ModMisc_OOCAction( Entity* pTargetEntity )
 	
Make the passed entity go out of control 

Triggers an OutOfControlAction on the unit. Does not trigger any actions associated with an OOC weapon hit critical, just the OOC action.

 
void  UI_EnableEntityDecorator( Entity* entity, bool enabled )
 	
Turn on or off entity decorator. The default is decorator enabled. 

 
void  UI_EnableEntityMinimapIndicator( Entity* entity, bool enabled )
 	
Turn on or off entity minimap indicator. The default is enabled. 

 
void  UI_EnableEntitySelectionVisuals( Entity* entity, bool enabled )
 	
Turn on or off entity selection visuals. The default is visuals enabled. 

 
void  UI_EnableSquadDecorator( Squad* squad, bool enabled )
 	
Turn on or off squad decorator. The default is decorator enabled. 

 
void  UI_EnableSquadMinimapIndicator( Squad* squad, bool enabled )
 	
Turn on or off squad minimap indicator. The default is enabled. 

 
const char*  UI_GetAbilityIconName( ScarAbilityPBG abilityBag )
 	
Returns the icon name for a given ability 

 
 

 

Event System
Functions

EventID  Event_CreateAND( Function callback, Table data, Table events, [Float delay] )
 	
Creates a Callback Event that triggers when ALL of the specified events are triggered. 

Original events are removed.

 
EventID  Event_CreateOR( Function callback, Table data, Table events, [Float delay] )
 	
Creates a Callback Event that triggers when ANY of the specified events are triggered. 

Original events are removed.

 
EventID  Event_ElementOnScreen( Function callback, Table data, PlayerID player, Marker/Pos/SGroup/EGroup element, [ANY/ALL all, Float percent, bool canSee, Float delay] )
 	
Callback given callback function with data, when the given squad/entity/position is on screen.  

Callback data parameter is agumented with: _player = PlayerID player, _element = SGroup/EGroup element

 
EventID  Event_EncounterIsDead( Function callback, Table data, Table!encID [, Float delay] )
 	
Trigger a Callback when an encounter is killed.  

Callback parameter data augmented with: _encounterID, the encounter's reference

 
BOOL  Event_Exists( EventID eventID )
 	
checks to see if the given event currently exists 

 
EventID  Event_GroupBurning( Function callback, Table data, EGroup/Entity group/entityID[, Float delay] )
 	
Callback given callback function with data, when the egroup is burning  

Callback parameter data augmented with: _group = EGroup/Entity group/entityID

 
EventID  Event_GroupIsDead( Function callback, Table data, EGroup/SGroup group[, Float delay, Boolean retreating] )
 	
Callback given callback function with data, when group is dead (empty).  

Callback parameter data augmented with: _group = EGroup/SGroup group. Optional Retreating param will check if the unit is retreating as an alternate (for team weapons)

 
EventID  Event_GroupIsNotPinned( Function callback, Table data, SGroup group[, bool ANY/ALL, Float delay] )
 	
Callback given callback function with data, when group is not pinned  

Callback parameter data augmented with: _group = SGroup group. Note: being suppressed counts as not being pinned

 
EventID  Event_GroupIsNotSuppressed( Function callback, Table data, SGroup group[, bool ANY/ALL, Float delay] )
 	
Callback given callback function with data, when group is not suppressed.  

Callback parameter data augmented with: _group = SGroup group. Note: being pinned counts as not being suppressed.

 
EventID  Event_GroupIsPinned( Function callback, Table data, SGroup group[, bool ANY/ALL, Float delay] )
 	
Callback given callback function with data, when group is pinned  

Callback parameter data augmented with: _group = SGroup group.

 
EventID  Event_GroupIsSuppressed( Function callback, Table data, SGroup group[, bool ANY/ALL, Float delay] )
 	
Callback given callback function with data, when group is suppressed.  

Callback parameter data augmented with: _group = SGroup group.

 
EventID  Event_GroupLeftAlive( Function callback, Table data, EGroup/SGroup group, Int amount[, Float delay] )
 	
Callback given callback function with data, when the amount of entities left in a group drops below amount.  

Callback parameter data augmented with: _group = EGroup/SGroup group, _amount = Int amount

 
EventID  Event_IsDoingAttack( Function callback, Table data, EGroup/SGroup group, ANY/ALL all, Float attackTime[, Float delay] )
 	
Callback given callback function with data, when group is doing an attack in the last attackTime seconds.  

Callback parameter data augmented with: _group = EGroup/SGroup group, _attackTime = Float attackTime

 
EventID  Event_IsEngaged( Function callback, Table data, EGroup/SGroup group, ANY/ALL all, Float attackTime[, Float delay] )
 	
Callback given callback function with data, when group is doing an attack or is under attack in the last attackTime seconds.  

Callback parameter data augmented with: _group = EGroup/SGroup group, _attackTime = Float attackTime

 
EventID  Event_IsHoldingAny( Function callback, Table data, EGroup/SGroup/Entity/Squad target, Boolean empty[, Float delay] )
 	
Callback given callback function with data, when an element is holding anything or nothing.  

Callback parameter data augmented with: _target = EGroup/SGroup/Entity/Squad target, _empty = Bool isEmpty

 
EventID  Event_IsInHold( Function callback, Table data, SGroup/Squad target, Boolean inHold, Float delay] )
 	
Callback given callback function with data, when a target element is in a hold or not.  

Callback parameter data augmented with: _target = SGroup/Squad target, _inHold = Bool inHold

 
EventID  Event_IsSelected( Function callback, Table data, SGroup/Squad/EGroup/entity target, Float delay] )
 	
Callback when a target element is selected.  

Callback parameter data augmented with: _target = EGroup/Entity/SGroup/Squad target, _all = Bool ANY/ALL

 
EventID  Event_IsUnderAttack( Function callback, Table data, EGroup/SGroup group, bool ANY/ALL, Float attackTime[, PlayerID player, Float delay] )
 	
Callback given callback function with data, when group is under attack in the last attackTime seconds.  

Callback parameter data augmented with: _group = EGroup/SGroup group, _attackTime = Float attackTime

 
EventID  Event_NarrativeEventsNotRunning( Function callback, Table data, [Float delay] )
 	
Callback given callback function with data, a narrative event is running.  

 
EventID  Event_NarrativeEventsRunning( Function callback, Table data, [Float delay] )
 	
Callback given callback function with data, when no narrative events are running.  

 
EventID  Event_OnHealth( Function callback, Table data, EGroup/SGroup/Entity/Squad target, Float threshold, Boolean higher[, Float delay] )
 	
Callback given callback function with data, when an element's health falls below (or above if higher is true) given threshold.  

 
EventID  Event_PlayerBuildingCount( Function callback, Table data, PlayerID player, Int!amountOfBuilding [, Float delay] )
 	
Callback given function with data, when player has greater than or equal to amountOfBuildings  

Callback parameter data augmented with: _player = PlayerID player, _amountOfBuildings = Int amountOfBuildings

 
EventID  Event_PlayerCanNotSeeElement( Function callback, Table data, PlayerID player, SquadID/SGroupID/EntityID/EGroupID/Marker/Position!Table element[, ANY/ALL all, Float delay] )
 	
Callback given callback function with data, when the given player can not see the element.  

Callback data parameter is augmented with: _player = PlayerID player, _elements = Table inputElements, _seenElements = Table allSeenElements

 
EventID  Event_PlayerCanSeeElement( Function callback, Table data, PlayerID/TeamID player/team, SquadID/SGroupID/EntityID/EGroupID/Marker/Position!Table element[, ANY/ALL all, Float delay] )
 	
Callback given callback function with data, when the given player can see the element.  

Callback data parameter is augmented with: _player = PlayerID player, _elements = Table inputElements, _seenElements = Table allSeenElements

 
EventID  Event_PlayerDoesntOwnTerritory( Function callback, Table data, PlayerID player, Int/Table/EGroup/Entity sectorID/group/entity[, Float delay] )
 	
Callback given callback function with data, when player owns none of the given territories.  

Callback parameter data augmented with: _player = PlayerID player, _territory = Int/Table sectorID OR EGroup/Entity of a capture point

 
EventID  Event_PlayerOwnsElement( Function callback, Table data, PlayerID player, Entity/EGroup/Squad/SGroup!element [, Float delay] )
 	
Callback given function with data, when player owns the given element 

Callback parameter data augmented with: _player = PlayerID player, _element = Entity/EGroup/Squad/SGroup element

 
EventID  Event_PlayerOwnsTerritory( Function callback, Table data, PlayerID player, SectorID/EGroup/Entity/Table territory[, ANY/ALL all, Float delay] )
 	
Callback given callback function with data, when player owns all given territories.  

Callback parameter data augmented with: _player = PlayerID player, _territory = sectorID/EGroup/Entity/Table of a capture point

 
EventID  Event_PlayerResourceLevel( Function callback, Table data, PlayerID player, ResourceType resourceType, Int amount, [Float delay] )
 	
Callback given callback function with data, when player has more than amount of resourceType.  

Callback data parameter is augmented with: _player = PlayerID player, _resourceType = ResourceType resourceType, _amount = Int amount

 
EventID  Event_PlayerSquadCount( Function callback, Table data, [Bool!areRunning!= false, Float delay] )
 	
Callback given callback function with data, when no narrative events are running.  

 
EventID  Event_Proximity( Function callback, Table data, PlayerID/Squad/Table/TeamID target, Marker/Pos/SectorID/Table/SGroup/EGroup location, REAL range, [ANY/ALL all, Float delay] )
 	
Callback given callback function with data when target enters location. 

Callback data parameter augmented with (could be nil): _result_location = Pos/Marker/Table/SGroup/EGroup/SectorID proximity position.

 
Void  Event_Remove( EventID eventID )
 	
Remove the given callback 

 
Void  Event_RemoveAll( Void  )
 	
Remove all existing callback events. 

 
EventID  Event_TeamBuildingCount( Function callback, Table data, TeamID team, Int!amountOfBuilding [, Float delay] )
 	
Callback given function with data, when player has greater than or equal to amountOfBuildings  

Callback parameter data augmented with: _player = PlayerID player, _amountOfBuildings = Int amountOfBuildings

 
EventID  Event_TeamCanNotSeeElement( Function callback, Table data, TeamID team, SquadID/SGroupID/EntityID/EGroupID/Marker/Position!Table element[, ANY/ALL all, Float delay] )
 	
Callback given callback function with data, when the given team can not see the element.  

Callback data parameter is augmented with: _team = TeamID team, _elements = Table inputElements, _seenElements = Table allSeenElements

 
EventID  Event_TeamCanSeeElement( Function callback, Table data, TeamID team, SquadID/SGroupID/EntityID/EGroupID/Marker/Position!Table element[, ANY/ALL all, Float delay] )
 	
Callback given callback function with data, when the given team can see the element.  

Callback data parameter is augmented with: _team = TeamID team, _elements = Table inputElements, _seenElements = Table allSeenElements

 
EventID  Event_TeamDoesntOwnTerritory( Function callback, Table data, TeamID team, Int/Table/EGroup/Entity sectorID/group/entity[, Float delay] )
 	
Callback given callback function with data, when a team owns none of the given territories.  

Callback parameter data augmented with: _team = TeamID team, _territory = Int/Table sectorID OR EGroup/Entity of a capture point

 
EventID  Event_TeamOwnsElement( Function callback, Table data, TeamID team, Entity/EGroup/Squad/SGroup!element [, Float delay] )
 	
Callback given function with data, when a team owns the given element 

Callback parameter data augmented with: _team = TeamID team, _element = Entity/EGroup/Squad/SGroup element

 
EventID  Event_TeamOwnsTerritory( Function callback, Table data, TeamID team, Int/Table/EGroup/Entity sectorID/group/entity[, ANY/ALL all, Float delay] )
 	
Callback given callback function with data, when a team owns all given territories.  

Callback parameter data augmented with: _team = TeamID team, _territory = Int/Table sectorID OR EGroup/Entity of a capture point

 
EventID  Event_TeamResourceLevel( Function callback, Table data, TeamID team, ResourceType resourceType, Int amount, [Float delay] )
 	
Callback given callback function with data, when a team has a combined amount more than amount of resourceType.  

Callback data parameter is augmented with: _team = TeamID team, _resourceType = ResourceType resourceType, _amount = Int amount

 
EventID  Event_TeamSquadCount( Function callback, Table data, TeamID team, [Bool!areRunning!= false, Float delay] )
 	
Callback given callback function with data, when no narrative events are running.  

 
EventID  Event_Timer( Function callback, Table data, INT/Table delay )
 	
Callback given callback function with data, after a specified delay.  

Delay can be a table containing two numbers and will randomly select a delay from between the two

 
Void  Event_ToggleDebug( Void  )
 	
Toggles the ScarEvent debugger ON and OFF 

 
Void  Event_View( INT eventID )
 	
Calls the view_manager on a ScarEvent with a specific ID. 

 
Void  EventHandler_AssignEncounterGoal( Table data )
 	
Callback helper function for assigning a goal to an Encounter. Name of parameters: 'goalData', 'encounter'. 

Example usage: Event_*(EventHandler_AssignEncounterGoal, {encounter = myEncounter, goalData = myGoalData}, ...

 
Void  EventHandler_ObjectiveComplete( Table data )
 	
Callback helper function for completing an objective. Received parameters: Table objective, Bool showTitle, Bool skipIntel 

Example usage: Event_*(EventHandler_ObjectiveComplete, {objective = objectiveID}, ...

 
Void  EventHandler_ObjectiveStart( Table data )
 	
Callback helper function for starting an objective, name of objective parameter is objective, additional parameters: Bool showTitle, Bool skipIntel 

Example usage: Event_*(EventHandler_ObjectiveStart, {objective = objectiveID, showTitle = true, skipIntel = true}, ...

 
Void  EventHandler_RemoveHint( Table data )
 	
Callback helper function for removing in-game hints. Name of hintpointID parameter is 'hint'. Can receive a table of ID's. 

Example usage: Event_*(EventHandler_RemoveHint, {hint = hp_hintPointID}, ...

 
Void  EventHandler_RemoveMinimapBlip( Table data )
 	
Callback helper function for removing in minimap blips, name of blipID parameter is blip 

Example usage: Event_*(EventHandler_RemoveMinimapBlip, {blip = blipID}, ...

 
Void  EventHandler_RemoveObjectiveUI( Table data )
 	
Callback helper function that removes objective UI elements, name of parameters: objective, element 

Example usage: Event_*(Objective_RemoveUIElements, {element = elementID, objective = objectiveID}, ...

 
Void  EventHandler_Retreat( Table data )
 	
Callback helper function that causes the input group to retreat, name of parameters: group, location, deleteAtMarker, queued 

Example usage: Event_*(EventHandler_Retreat, {group = sg_group, location = mkr_option, deleteAtMarker = true, queued = false}, ...

 
Void  EventHandler_StaggeredRetreat( Table data )
 	
Callback helper function that causes the input group to retreat, name of parameters: group, location, maxTries 

Example usage: Event_*(EventHandler_Retreat, {group = sg_group, location = mkr_option, maxTries = 8}, ...

 
Void  EventHandler_StartIntel( Table data )
 	
Callback helper function for Intel events, name of intel parameter is intel 

Example usage: Event_*(EventHandler_StartIntel, {intel = EVENTS.Speech01}, ...

 
Void  EventHandler_StartNislet( Table data )
 	
Callback helper function for Intel Nislet events, name of intel parameter is intel 

Example usage: Event_*(EventHandler_StartIntel, {intel = EVENTS.Nislet01}, ...

 
Void  EventHandler_StopFlashing( Table data )
 	
Callback helper function for removing UI flashing. Name of ID parameter is flashID 

Example usage: Event_*(EventHandler_StopFlashing, {flashID = myFlashID}, ...

 
 

 

FOW
Functions

void  FOW_PlayerExploreAll( ModPlayer* player )
 	
Explores entire map for one player 

 
void  FOW_PlayerRevealAll( ModPlayer* player )
 	
Reveal FOW for specified player 

 
void  FOW_PlayerRevealArea( ModPlayer* player, ScarPosition pos, float radius, float durationSecs )
 	
Reveals a circular area for the given player over a given duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 

Pass in a duration of -1 for indefinite duration ( until unreveal is called )

 
void  FOW_PlayerUnExploreAll( ModPlayer* player )
 	
Unexplores entire map for one player 

 
void  FOW_PlayerUnRevealAll( ModPlayer* player )
 	
Use to undo a FOW_RevealAll for specified player 

 
void  FOW_PlayerUnRevealArea( ModPlayer* player, ScarPosition pos, float radius )
 	
UnReveals a circular area for a given player. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 

 
void  FOW_RevealAll( Void  )
 	
Reveal FOW for all players 

 
void  FOW_RevealArea( ScarPosition pos, float radius, float durationSecs )
 	
Reveals a circular area for all alive players over a given duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 

Pass in a duration of -1 for indefinite duration ( until unreveal is called )

 
void  FOW_RevealEGroup( EGroup* group, float durationSecs )
 	
Reveals an entity groups line of sight(LOS) for all alive players over a given duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 

Pass in a duration of -1 for indefinite duration ( until the entities are dead )

 
void  FOW_RevealEGroupOnly( EGroup* group, float durationSecs )
 	
Reveals an entity groups in FOW for all alive players over a given duration. 

Pass in a duration of -1 for indefinite duration ( until the entities are dead )

 
void  FOW_RevealEntity( Entity* entity, float durationSecs )
 	
Reveals an entities line of sight (LOS) for all alive players over a given duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 

Pass in a duration of -1 for indefinite duration ( until the entity is dead )

 
Void  FOW_RevealMarker( MarkerID marker, Real duration )
 	
Reveals an area the size of a given markers proximity at that markers position for a given amount of time. Pass in a duration of 1 for indefinite duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA.  

This function will reveal the FOW for ALL alive players. This does not work with markers with rectangular proximity type

 
void  FOW_RevealSGroup( SGroup* group, float durationSecs )
 	
Reveals a squad groups line of sight(LOS) for all alive players over a given duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 

Pass in a duration of -1 for indefinite duration ( until the squads are dead )

 
void  FOW_RevealSGroupOnly( SGroup* group, float durationSecs )
 	
Reveals a squad groups in fow for all alive players over a given duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 

Pass in a duration of -1 for indefinite duration ( until the squads are dead )

 
void  FOW_RevealSquad( Squad* squad, float durationSecs )
 	
Reveals a squads line if sight(LOS) for all alive players over a given duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 

Pass in a duration of -1 for indefinite duration ( until the entity is dead )

 
void  FOW_RevealTerritory( ModPlayer* player, int sectorID, float durationSecs, bool mustOwn )
 	
Reveals a territory to a player 

 
void  FOW_UnRevealAll( Void  )
 	
Use to undo a FOW_RevealAll 

 
void  FOW_UnRevealArea( ScarPosition pos, float radius )
 	
UnReveals a circular area for all alive players. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 

 
Void  FOW_UnRevealMarker( MarkerID marker )
 	
Unreveals an area the size of a given markers proximity at that markers position. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA.  

This does not work with markers with rectangular proximity type

 
void  FOW_UnRevealTerritory( ModPlayer* player, int sectorID )
 	
Unreveals a territory sector 

 
 

 

ID
Functions

LuaTable  EGroup_CreateTable( String format, Integer size )
 	
Returns a table of egroups NOT in the world builder 

See Marker_GetTable for more info on format parameter

 
LuaTable  EGroup_GetWBTable( String format )
 	
Returns a table of egroups from the world builder 

See Marker_GetTable for more info on format parameter

 
LuaTable  Marker_GetNonSequentialTable( String format, Integer size )
 	
Returns a fixed size table of markers from the world builder. Markers that do not exist in the WB, will be nil in the table. This is why we call it 'non-sequential' 

 
LuaTable  Marker_GetTable( String format )
 	
Returns a table of markers from the world builder. Creates as many as it finds 

mkr_table = Marker_GetTable( 'mkr_%d' ) -- creates a table with 3 markers named 'mkr_1', 'mkr_2', and 'mkr_3' (and so on) from the WB<BR/><BR/> mkr_table2 = Marker_GetTable( 'mkr_%02d' ) -- creates a table with 3 markers named 'mkr_01', 'mkr_02', 'mkr_03' (and so on) from the WB<BR/><BR/> mkr_table3 = Marker_GetTable( 'mkr_%03d_patrol' ) -- creates a table with 3 markers named 'mkr_001_patrol', 'mkr_002_patrol' (and so on) from the WB<BR/><BR/>

 
LuaTable  SGroup_CreateTable( String format, Integer size )
 	
Returns a table of sgroups NOT in the world builder 

See Marker_GetTable for more info on format parameter

 
LuaTable  SGroup_GetWBTable( String format )
 	
Returns a table of sgroups from the world builder 

See Marker_GetTable for more info on format parameter

 
 

 

Marker
Functions

bool  Marker_DoesNumberAttributeExist( ScarMarker marker, const char* attrname )
 	
Returns true if a generic number attribute exists for the marker type. 

 
bool  Marker_DoesStringAttributeExist( ScarMarker marker, const char* attrname )
 	
Returns true if a generic string attribute exists for the marker type. 

 
bool  Marker_Exists( const char* name, const char* type )
 	
Returns true if marker exists. If you don't care about the type, pass in an empty string ( "" ) 

 
ScarMarker  Marker_FromName( const char* name, const char* type )
 	
Returns a ScarMarker from the Mission Editor. If you don't care about the type, pass in an empty string ( "" ) 

The type is defined in the markers list of the mission editor when placing markers.<BR/> You will need the result of this function to call any functions that start with Marker_

 
ScarPosition  Marker_GetDirection( ScarMarker marker )
 	
Returns a vector for the marker direction 

 
const char*  Marker_GetName( ScarMarker marker )
 	
Returns the name of a given marker. This value gets set in the Mission Editor. 

 
float  Marker_GetNumberAttribute( ScarMarker marker, const char* attrname )
 	
Returns a generic number attribute defined in a marker. 

Different marker types have different attributes. Note: All marker types have Name and Proximity. Do not use this function to retrieve these values, use Marker_GetName and Marker_GetProximity instead.

 
ScarPosition  Marker_GetPosition( ScarMarker marker )
 	
Returns the position of a given marker. 

 
float  Marker_GetProximityRadius( ScarMarker marker )
 	
Returns the proximity radius of a given marker. Only for marker with proximity type PT_Circle. This value gets set in the Mission Editor. 

 
MarkerObj::ProximityType  Marker_GetProximityType( ScarMarker marker )
 	
Returns the proximity type of a given marker. The possible results are PT_Circle and PT_Rectangle 

 
Table  Marker_GetSequence( String name, String type )
 	
Builds a table of MarkerIDs that are named in a sequence. i.e. a name of "spot" will find markers "spot1", "spot2" and so on, up until it looks for a marker that isn't there. 

 
std::string  Marker_GetStringAttribute( ScarMarker marker, const char* attrname )
 	
Returns a generic string attribute defined in a marker. 

Different marker types can have different attributes.<BR/> Note: All marker types have Name and Proximity. Do not use this function to retrieve these values, use Marker_GetName and Marker_GetProximity instead.<BR/> See markertypes.lua for a listing of all the marker types.

 	Source: [coh2\BIA\src\game\Cross\SimEngine\LuaExports/LuaMarker.cpp] (174) 
References: [MarkerTypes.lua]

const char*  Marker_GetType( ScarMarker marker )
 	
Returns the typename of a given marker. This is the typename from the Mission Editor (name displayed when placing markers) 

 
bool  Marker_InProximity( ScarMarker marker, ScarPosition pos )
 	
Returns true if the given position is in the markers proximity radius or proximity rectangle (depending on the type). 

 
 

 

Modifiers
Functions

Void  Modifier_IsEnabledOnEGroup( EGroupID egroup, String modifier, String modtype, Boolean all, Boolean bEnabledByDefault )
 	
Checks if a modifier is enabled on all or any entities in an egroup 

 
Void  Modifier_Remove( ModID modifier )
 	
Remove an applied modifier.  

 
Void  Modifier_RemoveAllFromEGroup( EGroupID egroup )
 	
Removes all SCAR-applied modifiers for a specific EGroup.  

 
Void  Modifier_RemoveAllFromSGroup( SGroupID sgroup )
 	
Removes all SCAR-applied modifiers for a specific SGroup.  

 
ModID  Modify_AbilityDelayTime( PlayerID player, AbilityID ability, Real scalefactor )
 	
Modifies the initial delay time of an ability 

 
ModID  Modify_AbilityDurationTime( PlayerID player, AbilityID ability, Real scalefactor )
 	
Modifies the duration of an ability 

 
ModID  Modify_AbilityManpowerCost( PlayerID player, AbilityID ability, Real scalefactor[, Integer mathtype] )
 	
Modifies the manpower cost of an ability 

 
ModID  Modify_AbilityMaxCastRange( PlayerID player, AbilityID ability, Real scalefactor )
 	
Modifies the maximum casting range of an ability. NOTE: it assumes that the actions that the ability executes can also handle the modified range 

 
ModID  Modify_AbilityMinCastRange( PlayerID player, AbilityID ability, Real scalefactor )
 	
Modifies the minimum casting range of an ability. NOTE: it assumes that the actions that the ability executes can also handle the modified range 

 
ModID  Modify_AbilityMunitionsCost( PlayerID player, AbilityID ability, Real scalefactor[, Integer mathtype] )
 	
Modifies the munitions cost of an ability 

 
ModID  Modify_AbilityRechargeTime( PlayerID player, AbilityID ability, Real scalefactor )
 	
Modifies the recharge time of an ability 

 
ModID  Modify_Armor( SGroupID/EGroupID group, Real scalefactor[, Boolean exclusive] )
 	
Modifies a squad or entity's armor 

 
ModID  Modify_CaptureTime( EGroupID sgroup, Real scalefactor )
 	
Modifies the capture time of all strategic points in an EGroup. DO NOT USE THIS FUNCTION. 

 
ModID  Modify_DisableHold( EGroupID group, Boolean disable )
 	
Enable or disable hold (garrisoning) for an egroup or sgroup 

 
Void  Modify_Enable_ParadropReinforcements( PlayerID playerId, Boolean enable )
 	
Allows paratroopers to reinforce from the sky. Set to true to enable, false to disable. 

 
ModID  Modify_EntityBuildTime( PlayerID playerId, String ebp, Real scalefactor )
 	
Modifies the time taken to build a particular EBP. This only affects the given player.  

 
ModID  Modify_EntityCost( PlayerID player, String blueprint, Integer resourcetype, Integer addition )
 	
Modifies the cost of an entity for a particular player. Possible resource types are RT_Manpower, RT_Munition, RT_Fuel, RT_Action  

 
ModID  Modify_PlayerExperienceReceived( PlayerID player, Real factor )
 	
Modifies the veterancy experience received by a player 

 
ModID  Modify_PlayerProductionRate( PlayerID sgroup, Real scalefactor )
 	
Modifies the production rate of a player. 

 
ModID  Modify_PlayerResourceCap( PlayerID playerId, Integer resourceType, Real scalefactor[, Integer mathtype] )
 	
Modifies a player's resource cap. Possible resource types are RT_Manpower, RT_Munition, RT_Fuel. Possible math types are MUT_Multiplication, MUT_Addition. 

 
ModID  Modify_PlayerResourceGift( PlayerID playerId, Integer resourceType, Real scalefactor )
 	
Modifies a player's resource bonus received (ie. one-time resource gifts) Possible resource types are RT_Manpower, RT_Munition, RT_Fuel, RT_Action  

 
ModID  Modify_PlayerResourceRate( PlayerID playerId, Integer resourceType, Real scalefactor[, Integer mathtype] )
 	
Modifies a player's incoming resource rate. Possible resource types are RT_Manpower, RT_Munition, RT_Fuel, RT_Action. Possible math types are MUT_Multiplication, MUT_Addition. 

 
ModID  Modify_PlayerSightRadius( PlayerID player, Real scalefactor )
 	
Modifies the sight radius for a player. 

 
ModID  Modify_ProductionRate( EGroupID sgroup, Real scalefactor )
 	
Modifies the production rate of all factories in an EGroup 

 
ModID  Modify_ProjectileDelayTime( PlayerID player, PBG entityBP, Real factor )
 	
Modifies a projectile's delay_detonate_time. 

 
ModID  Modify_ReceivedAccuracy( SGroupID/EGroupID group, Real scalefactor[, Boolean exclusive] )
 	
Modifies the chance of a squad/entity being hit 

 
ModID  Modify_ReceivedDamage( SGroupID/EGroupID group, Real scalefactor[, Boolean exclusive] )
 	
Modifies the damage a squad/entity receives. 

 
ModID  Modify_ReceivedSuppression( SGroupID sgroup, Real scalefactor )
 	
Modifies the rate at which a squad gets suppressed 

 
ModID  Modify_SetUpgradeCost( PlayerID playerId, UpgradeID upgrade, Integer resourceType, Real newCost )
 	
Sets the cost of an upgrade. This only affects the given player 

 
ModID  Modify_SightRadius( SGroupID/EGroupID group, Real scalefactor )
 	
Modifies the sight radius for an egroup or an sgroup. 

 
ModID  Modify_SquadAvailability( PlayerID player, String blueprint, Integer addition )
 	
Modifies the availability limit of a squad type for any given player 

 
ModID  Modify_SquadCaptureRate( SGroupID group, Real scalefactor )
 	
Modifies a squad's rate at which it will capture a strategic point. 

 
ModID  Modify_SquadTypeSightRadius( PlayerID player, String blueprint, Real scalefactor )
 	
Modifies the sight radius of a squad type for any given player 

 
ModID  Modify_TargetPriority( SGroupID/EGroupID group, Integer addition )
 	
Modifies the target priority of a squad or entity group from the attacker. The value is an addition 

 
ModID  Modify_TeamWeapon( SGroupID/EGroupID group, String modifier, Real scalefactor, [String hardpoint] )
 	
Modifies a sync weapon only.  

The hardpoint defaults to "hardpoint_01"

 
ModID  Modify_TerritoryRadius( EGroupID group, Real scalefactor )
 	
Modifies the territory radius for an egroup or an sgroup. 

 
ModID  Modify_UnitSpeed( SGroupID sgroup, Real scalefactor )
 	
Modifies the maximum speed for a vehicle. This has no effect on infantry. 

 
ModID  Modify_UnitVeterancyValue( SGroup/EGroup group, Real scalefactor[, Integer mathtype )
 	
Modifies the Veterancy Experience value of the target SGroup, EGroup, Entity, or Squad. Mathtype is Multiplication by default 

 
ModID  Modify_UpgradeBuildTime( PlayerID playerId, UpgradeID upgrade, Real scalefactor )
 	
Modifies the build time for a particular upgrade. This only affects the given player.  

 
ModID  Modify_Upkeep( PlayerID playerId, Real scalefactor )
 	
Modifies the upkeep for a player  

 
ModID  Modify_VehicleRepairRate( PlayerID player, Real factor, String engineer_entity_blueprint )
 	
Modifies the vehicle repair rate of all a player's engineers 

 
ModID  Modify_VehicleRotationSpeed( EGroupID/SGroupID group, Real factor )
 	
Modifies the vehicle rotation speed 

 
ModID  Modify_VehicleTurretRotationSpeed( SGroupID/EGroupID group, String hardpoint, Real scalefactor )
 	
Modifies the turret rotation speed of a vehicle squad 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
ModID  Modify_Vulnerability( EGroupID/SGroupID group, Real scalefactor )
 	
Increases the received accuracy, penetration, and damage on a squad by the scalefactor. For example, a scalefactor of 2 means that the squad gets 2x the received accuracy, 2x the received penetration, and 2x the received damage. 

 
ModID  Modify_WeaponAccuracy( SGroupID/EGroupID group, String hardpoint, Real scalefactor )
 	
Modifies a squad's weapon accuracy. 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
ModID  Modify_WeaponBurstLength( SGroupID/EGroupID group, String hardpoint, Real scalefactor )
 	
Modifies a squad's weapon burst length (time). 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
ModID  Modify_WeaponBurstRateOfFire( SGroupID/EGroupID group, String hardpoint, Real scalefactor )
 	
Modifies a squad's weapon rate of fire. 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
ModID  Modify_WeaponCooldown( SGroupID/EGroupID group, String hardpoint, Real scalefactor )
 	
Modifies a squad's weapon cooldown time. 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
ModID  Modify_WeaponDamage( SGroupID/EGroupID group, String hardpoint, Real scalefactor )
 	
Modifies a squad's weapon damage. 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
ModID  Modify_WeaponEnabled( SGroupID/EGroupID group, String hardpoint, Boolean enabled )
 	
Enables or disables a weapon hardpoint 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
ModID  Modify_WeaponPenetration( SGroupID/EGroupID group, String hardpoint, Real scalefactor )
 	
Modifies a squad's weapon penetration. Does not work on artillery (mortar, nebelwerfer, etc.) 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
ModID  Modify_WeaponRange( SGroupID/EGroupID group, String hardpoint, Real scalefactor )
 	
Modifies a squad's weapon range. Does not work on artillery (mortar, nebelwerfer, etc.) 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
ModID  Modify_WeaponReload( SGroupID/EGroupID group, String hardpoint, Real scalefactor )
 	
Modifies a squad's weapon reload time. 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
ModID  Modify_WeaponScatter( SGroupID/EGroupID group, String hardpoint, Real scalefactor )
 	
Modifies a squad's weapon scatter. 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
ModID  Modify_WeaponSuppression( SGroupID/EGroupID group, String hardpoint, Real scalefactor )
 	
Modifies a squad's weapon suppression. Does not work on artillery (mortar, nebelwerfer, etc.) 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
 

 

Multiplayer
Functions

Void  MP_BlizzardInit( String blizzard_atmosphere, String default_atmosphere[, Boolean startInBlizzard, Table blizzardData, Boolean useSpeech, String transitionOutAtmosphere] )
 	
Initializes and starts cold weather and blizzard mechanics, taking in atmosphere presets to use in each condition. Uses MP values by default. Defaults to NOT starting in blizzard conditions.  

You need to add import("Systems/BlizzardMulitplayer.scar") to your mission script to use this - it isn't imported by default

 
 

 

Objectives
Functions

PingID  Objective_AddPing( LuaTable objectiveTable, Position pos )
 	
Adds a tactical map ping to an objective 

 
ElementID  Objective_AddUIElements( LuaTable objTable, Position pos[, Boolean ping, LocString hintpointText, Boolean worldArrow, Float/Position objectiveArrowOffset, Entity/Squad/Position objectiveArrowFacing, HintPointActionType actionType, String iconName] )
 	
Adds multiple UI elements on one position. 'pos' can be group/entity/squad/marker. worldArrow adds a 3D arrow which points to the thing in the world. hintpointText adds a hint point that appears on the thing when moused over. If you're adding an arrow or a hintpoint, this thing will be among those potentially pointed to by the 2D HUD arrow. objectiveArrowOffset is an offset applied to the arrow's position (you can specify a height offset or a 3D position offset). 

 
Boolean  Objective_AreAllPrimaryObjectivesComplete( )
 	
Returns whether all primary objectives have been completed. 

 
Void  Objective_Complete( LuaTable objTable[, Boolean bShowTitle, Boolean skipIntel] )
 	
'Completes' an objective. Wrapper function for Objective_SetState with a few other features. If you do not want the objective title to be shown on screen, pass in 'false' for bShowTitle 

Includes managing the blips and triggers the OnComplete() function as defined by the objective table created in the main scar file. SkipIntel will skip the defined INTEL_COMPLTE event.

 
Void  Objective_Fail( LuaTable objTable[, Boolean bShowTitle, Boolean skipIntel] )
 	
'Fails' an objective. Wrapper function for Objective_SetState with a few other features. 

Includes managing the blips and triggers the OnFail() function as defined by the objective table created in the main scar file. SkipIntel will skip the defined INTEL_FAIL event.

 
Integer  Objective_GetCounter( LuaTable objTable )
 	
Returns the current count associated with this objective. 

 
Integer  Objective_GetTimerSeconds( LuaTable objTable )
 	
Returns the amount of seconds on the timer (time remaining or time elapsed, based on the type of timer used) 

 
Void  Objective_IncreaseCounter( LuaTable objTable[, Int amount] )
 	
Increases the counter that is associated with this objective in the UI. You can provide an amount to increase by. 

 
Boolean  Objective_IsComplete( LuaTable objTable )
 	
Returns whether an objective is complete 

 
Boolean  Objective_IsCounterSet( LuaTable objTable )
 	
Returns true if a counter has been set for this objective 

 
Boolean  Objective_IsFailed( LuaTable objTable )
 	
Returns whether an objective is failed 

 
Boolean  Objective_IsStarted( LuaTable objTable )
 	
Returns whether an objective has been started. Completed objectives will return true. 

 
Boolean  Objective_IsTimerSet( LuaTable objTable )
 	
Returns true if a timer has been set for this objective 

 
Boolean  Objective_IsVisible( LuaTable objTable )
 	
Returns whether an objective is visible or not. 

 
Void  Objective_PauseTimer( LuaTable objTable )
 	
Pauses the objective's timer. If a timer has not been set, it does nothing. 

 
ObjectiveID  Objective_Register( LuaTable objTable[, PlayerID/TeamID owner] )
 	
'Registers' an objective. Wrapper function for Objective_Create with a few other features. 

Includes pings as defined by the objective table created in the main scar file. You can pass in a team or player, so that the objective only applies to it.

 
Void  Objective_RemovePing( LuaTable objectiveTable, Integer PingID )
 	
Removes a tactical map ping from an objective 

 
Void  Objective_RemoveUIElements( LuaTable objTable, Integer elementID )
 	
Removes a group of UI elements that were added by Objective_AddUIElements 

 
Void  Objective_ResumeTimer( LuaTable objTable )
 	
Resume the objective's timer. If a timer has not been set, it does nothing. 

 
Void  Objective_SetAlwaysShowDetails( LuaTable objTable, Boolean title, Boolean hud_arrow, Boolean hintpoints )
 	
Sets whether this objective always shows detailed text, the HUD arrow, or the hintpoints. There can only be one objective at a time that forces the HUD arrow to show up. If you pass in 'nil' for hud_arrow then its behavior is not affected. 

 
Void  Objective_SetCounter( LuaTable objTable, Float current[, Float maximum] )
 	
Sets a counter that is associated with this objective in the UI. You can provide a 'maximum' so that it shows up as "1 of 5" 

 
Void  Objective_Show( LuaTable objective_table, Boolean on/off )
 	
Shows or hides an objective from the UI and tactical map 

 
Void  Objective_Start( LuaTable objTable[, Boolean bShowTitle, Boolean skipIntel] )
 	
Shows an objective to the player and activates it 

Includes pings and FOW as defined by the objective table created in the main scar file. SkipIntel will skip the defined INTEL_START event.

 
Void  Objective_StartTimer( LuaTable objTable, Integer direction[, Float initialTime, Float flashThreshold] )
 	
Starts a timer that is associated with this objective in the UI. Use COUNT_DOWN or COUNT_UP for the 'direction' parameter 

 
Void  Objective_StopCounter( LuaTable objTable )
 	
Stops the objective's counter. If a counter has not been set, it does nothing. 

 
Void  Objective_StopTimer( LuaTable objTable )
 	
Stops the objective's timer. If a timer has not been set, it does nothing. 

 
Void  Objective_TogglePings( LuaTable objective_table, Boolean on/off )
 	
Toggles minimap blips on or off. 

 
Void  Objective_UpdateText( LuaTable objTable, LocString title, LocString description[, Boolean bShowTitle] )
 	
Updates the title and description for the objective. If you only want to set one of them, pass in nil for the other 

 
 

 

Operations
Functions

Void  Cmd_StopSquadsOnly( SGroupID sgroup1, Enum squadStateIDtype )
 	
Pass in a group to command to 'stop'. Pass in a squad state to filter by. 

 
Table playerData  OpGameSetup( )
 	
Operation Setup function registers all valid players 

OpGameSetup() should be called by the individual Operation files It creates a master table _Op.PDT meant to be used by Op Utility files only It returns this table so that the Operation file can use and manipulate its own

 
GroupTable table  OpNPC_AddSupportGroup( Table groupTable )
 	
Does things 

 
GroupTable table  OpNPC_AddSyncWpnGroup( Table groupTable )
 	
Does things 

 
GroupTable table  OpNPC_AddTeamWpnGroup( Table groupTable )
 	
Does things 

 
Void  OpNPC_IsGroupActive( Integer groupId )
 	
Does things 

 
Value  OpNPC_Name( Type!value [, Type value] )
 	
Does things 

Does more things

 
Void  OpNPC_RemoveGroup( Integer groupID )
 	
Removes the indicated sub table from the NPC Support Manager 

 
Void  OpNPC_RetreatGroup( Table groupTable, Boolean activeStatus )
 	
Does things 

 
Void  OpNPC_SetGroupActive( Integer groupId, Boolean activeStatus )
 	
Changes the state of the indicated sub table to the value provided 

 
Value  OpPlayer_Action( Type!value [, Type value] )
 	
Does things 

Does more things

 
ModType modTable, PlayerID/Egroup/Sgroup modReciever, Integer scaleValue  OpUtil_AddModifier( )
 	
Applies the indicated modifier type to the specified group or player 

 
Void  OpUtil_AddResourcesToTeam( PlayerID/Team playerORteam, Boolean myTeam )
 	
Works with _Op.PDT, takes a playerID or team and gives that team OR the enemy team lots of resources 

 
Boolean sameTypeFound  OpUtil_AssignSquadSameTypeControlGroup( SgroupID sgroup[, Boolean startWithFirst] )
 	
Trys to assign a squad to a control group with the sametype of squad 

 
void  OpUtil_AssignSquadUnusedControlGroup( SgroupID sgroup[, Boolean startWithFirst] )
 	
Assigns the squads within a sgroup to free control group 

 
Void  OpUtil_ClearPlayZone( MarkerID marker )
 	
Removes the 'Playable Zone' set by OpUtil_SetPlayZone 

 
Boolean isCaptured  OpUtil_EgroupIsCapturedByTeam( EgroupID capturePoint, TeamID playerTeam, Boolean anyAll )
 	
Tracks a syncweapon ID and destroys the weapon if it ever becomes un-crewed 

 
Void  OpUtil_EnemyEGroupArrowManager( ObjectiveID objective, EGroupID target, PlayerID targetPlayer, Table blueprintTable, EGroup buildingGroup, LocID objectiveText, Boolean pingArrow )
 	
Displays an arrow with a text message over a random building that's part of an EGroup of buildings 

Useful when you want to highlight a group of buildings that you want to destroy as an objective but don't want to highlight every building at once.

 
EgroupID/NIL egroupID/nil  OpUtil_FindNearestCapturePoint( SgroupID sgroup, Integer range )
 	
Finds the nearest captureable point to the sgroup  

Will only compare to Registered Captureable Points, will return 'nil' if there are none in range

 
Void  OpUtil_InvulnerableAdd( SGroupID SGroupID, Integer survivorThreshold, [Real percentage] )
 	
Adds an SGroup from a list of units to be tracked for invulnerability 

Specified SGroup will turn invulnerable when it reaches a specified number of survivors OR if the average health of the squad is <20% (under the hood, as a safety measure). If no number is entered the SGroup is assumed to be instantly invulnerable. The percentage is the average health of an sgroup, and will override the number of total members, and thus is optional.

 
Void  OpUtil_InvulnerableRemove( SGroupID SGroupID )
 	
Removes an SGroup from a list of units to be tracked for invulnerability 

If you want an SGroup to not be tracked anymore in terms of invulnerability use this function

 
Void  OpUtil_LogSyncWpn( SGroupID syncweapon )
 	
Tracks a syncweapon ID and destroys the weapon if it ever becomes un-crewed 

 
PlayerID  OpUtil_ReturnEnemyNPC( PlayerID/Team playerORteam )
 	
Works with _Op.PDT, takes a variable and returns an enemy NPC  

 
PlayerID humanPlayer  OpUtil_ReturnHumanPlayer( RaceID/FactionID/Index/TeamID compareVar )
 	
Works with _Op.PDT, takes a variable and returns a Human player  

 
PlayerID npcPlayer  OpUtil_ReturnNPCPlayer( RaceID/FactionID/Index/TeamID compareVar )
 	
Works with _Op.PDT, takes a variable and returns a Non-Human player  

 
RaceID enum  OpUtil_ReturnRace( RaceID/FactionID/Index/PlayerID compareVar )
 	
Works with _Op.PDT, takes a player and returns the race  

 
TeamID integer  OpUtil_ReturnTeam( RaceID/FactionID/Index/PlayerID compareVar )
 	
Works with _Op.PDT, takes a variable and returns the team  

 
Void  OpUtil_SetPlayZone( MarkerID marker )
 	
Sets a 'playable zone' in the area and keeps all Human players within it 

 
Boolean ownsEgroup  OpUtil_TeamOwnsEntity( PlayerID/TeamID owner, EgroupID egroup[, Boolean ANY/ALL )
 	
Checks to see if an egroup is owned by a team 

 
GroupTable table  OpVP_AddPenaltyGroup( Table groupTable )
 	
Does things 

 
Value  OpVP_Name( Type!value [, Type value] )
 	
Does things 

Does more things

 
Void  OpVP_RegisterCaptureablePoints( EgroupID/Table groupID/egroupTable )
 	
Registers a single egroup or a table of egroups as a captureable point 

Tracks the various states of the points, neutral or team owner

 
Void  OpVP_RegisterPointDefense( Table defendTable )
 	
Add a set egroups and defensive formations to defend them  

 
Void  OpVP_RemoveGroup( Integer groupID )
 	
Removes the indicated sub table from the VP Support Manager 

 
Void  UI_PopUpMessage( LocID locstring, LocID locstring[, LabelActionTable table, LabelActionTable table, LabelActionTable!table ] )
 	
Auto-generate a popup message with callbacks. See OpUtil.scar for an example of how to use this function. 

If no buttons are defined it defaults to a 'Close' button that triggers no action.

 
Void  Util_ProductionRestriction( Table sbps/upgs[, Table ebps, LocID!unit Warning, LocID!build Warning] )
 	
Prevents the construction of squads or enities based on blueprint tables passed into the function. 

Calling the function multiple times will stomp any previously data passed into the function.

 
Void  Util_TutorialIntel( Table!intelEventTable![or Actor/String/Button/Sticky/Input] )
 	
Auto-generate a Tutorial Intel Event. Called individually or using the traditional table format. 

See Util_AutoIntel() Takes a table of parameters defining speaker(s)/line(s) or pass in Actor/String/Button/Sticky/Input

 
 

 

Player
Functions

void  Player_AddAbility( ModPlayer* pPlayer, ScarAbilityPBG pAbilityPBG )
 	
Add an ability to a player 

 
void  Player_AddAbilityLockoutZone( ModPlayer* player, ScarAbilityPBG abilityPBG, ScarMarker marker )
 	
Specifies a marker where an ability cannot be used. This only applies to abilities where you use the cursor to pick a location in the world (like a location to paradrop at). 

 
Void  Player_AddResource( PlayerID playerId, Integer resourceType, Real value )
 	
Add resource to player, as opposed to just setting it. Possible resource types are RT_Manpower, RT_Munition, RT_Fuel, RT_Action  

 
SGroupID  Player_AddSquadsToSGroup( PlayerID playerId, String squadgroupName )
 	
For the given player, get all of the squads gathered into a squadgroup of your naming.  

Squads will be added to given squad group. If the given squad group does not exist it will be created.

 
void  Player_AddUnspentCommandPoints( ModPlayer* player, float points )
 	
Gives the player new command points to spent on 

 
Boolean  Player_AreSquadsNearMarker( PlayerID playerid, MarkerID marker )
 	
Returns true if ANY of a players squads are in proximity of a marker 

 
bool  Player_CanCastAbilityOnEntity( ModPlayer* player, ScarAbilityPBG abilityPBG, Entity* targetEntity )
 	
Tests if the player can currently use an ability on target entity 

 
bool  Player_CanCastAbilityOnPlayer( ModPlayer* player, ScarAbilityPBG abilityPBG, ModPlayer* targetPlayer )
 	
Tests if the player can currently use an ability on target player 

 
bool  Player_CanCastAbilityOnPosition( ModPlayer* player, ScarAbilityPBG abilityPBG, ScarPosition targetPosition )
 	
Tests if the player can currently use an ability on target position 

 
bool  Player_CanCastAbilityOnSquad( ModPlayer* player, ScarAbilityPBG abilityPBG, Squad* targetSquad )
 	
Tests if the player can currently use an ability on target squad 

 
Boolean  Player_CanSeeEGroup( PlayerID playerid, EGroupID egroup, Boolean all )
 	
Returns true if a player can see ALL or ANY items in an egroup 

 
bool  Player_CanSeeEntity( const ModPlayer* player, Entity* entity )
 	
Returns true if a player can see a given entity (revealed in FOW) 

 
bool  Player_CanSeePosition( const ModPlayer* player, ScarPosition pos )
 	
Returns true if a player can see a given position. 

 
Boolean  Player_CanSeeSGroup( PlayerID playerid, SGroupID sgroup, Boolean all )
 	
Returns true if a player can see ALL or ANY items in an sgroup 

 
bool  Player_CanSeeSquad( const ModPlayer* player, Squad* squad, bool all )
 	
Returns true if a player can see ALL or ANY units in a given squad (revealed in FOW) 

Set all to true to check that ALL units are visible or set to false to check for ANY.

 
Void  Player_ClearArea( PlayerID player, MarkerID marker, Bool invulnerable )
 	
Any of the player's units in the marker area move out of the area, and can be made invulnerable for a bit whilst they do it 

You can replace the marker with a position and a range - i.e. Player_ClearArea(player, pos, range, invulnerable)

 
void  Player_ClearAvailabilities( ModPlayer* player )
 	
Clears item, command and construction menu availabilities for the player. 

 
void  Player_ClearPopCapOverride( ModPlayer* player )
 	
Clears the pop cap override so that modifiers can take effect again 

 
void  Player_CompleteUpgrade( ModPlayer* pPlayer, ScarUpgradePBG pUpgradePBG )
 	
Finish upgrade for a player 

 
void  Player_DoParadrop( ModPlayer* player, SGroup* sgroup, ScarPosition pos, float dropHeight, float dropDrift, LuaBinding::StackVar blueprint, size_t maxSquadEntityCount, size_t maxDeathOnBuilding )
 	
Do a paradrop with custom parameters for this player. This is similar to regular paradrop ability without any prereq check 

sgroup is the SGroup that the newly created squad would be added to dropHeight is Height in metres the paratroopers are dropped from. dropDrift is Horizontal distance in metres from where the paratroopers are dropped from. blueprint is the blueprint to spawn. It could be squad or entity maxSquadEntityCount is the number of squad members to spawn. 0 means default is used maxDeathOnBuilding is the number of entities allowed to die when landing on buildings Example: local id = SBP.ALLIED_AIRBOURNE Player_DoParadrop( g_player1, sg_soldier1, Marker_GetPosition( marker4 ), 100.0, 10.0, id, 3, 2 )

 
ModPlayer*  Player_FindFirstEnemyPlayer( const ModPlayer* player )
 	
Searches the player list in the world and returns the id of the first enemy player 

 
ModPlayer*  Player_FromId( uint32_t id )
 	
Returns a player given a player id from the ME. 

 
Player::AIType  Player_GetAIType( ModPlayer* pPlayer )
 	
Returns the type of the given player if it is an AI. 

 
Void  Player_GetAll( PlayerID player[, SGroupID sgroup, EGroupID egroup] )
 	
Creates/Clears groups that contain all of a player's units and buildings. Defaults - sg_allsquads and eg_allentities 

Fills an SGroup with all of the given player's squads, and an EGroup with all the player's entities. If you don't provide and groups, then it defaults to using sg_allsquads and eg_allentities.

 
Void  Player_GetAllEntitiesNearMarker( PlayerID playerid, EGroupID egroup, MarkerID/Pos/SectorID position[, Real range] )
 	
Gather together all of a player's entities that are in proximity to a marker, a position, or within a territory sector into an EGroup. The EGroup is cleared beforehand.  

You can override a marker's normal proximity by specifying a range.

 
Void  Player_GetAllSquadsNearMarker( PlayerID player, SGroupID sgroup, MarkerID/Pos/SectorID position[, Real range] )
 	
Gather together all of a player's squads that are in proximity to a marker, a position, or within a territory sector into an SGroup. The SGroup is cleared beforehand.  

You can override a marker's normal proximity by specifying a range.

 
EntityID  Player_GetBuildingID( PlayerID player, BlueprintTable entitytypes )
 	
Returns the entityID of the first player owned building listed in the table. 

This only looks at completed buildings

 
Integer  Player_GetBuildingsCount( PlayerID playerId )
 	
Returns the total number of buildings owned by this player. 

 
Integer  Player_GetBuildingsCountExcept( PlayerID playerId, BlueprintTable exceptions )
 	
Returns the total number of buildings owned by this player (with exclusions). 

 
Integer  Player_GetBuildingsCountOnly( PlayerID playerId, BlueprintTable ebplist )
 	
Returns the number of buildings owned by this player (inclusive). 

 
float  Player_GetCurrentPopulation( const ModPlayer* player, CapType capType )
 	
Use capType CT_Personnel to get current squad cap, CT_Vehicle to get current vehicle cap, CT_Medic to get current medic cap 

 
LocString  Player_GetDisplayName( const ModPlayer* player )
 	
Returns the players UI name. 

 
EGroup*  Player_GetEntities( ModPlayer* player )
 	
Returns an EntityGroupObs containing all the players entities. 

This function returns a 'global' entity group with the name '__Player%dEntities', where %d is the player ID. This means that you should never need to destroy it./n However, if you do destroy it, it will be recreated the next time this function is called.

 
EGroup  Player_GetEntitiesFromType( PlayerID player, String unitType )
 	
Returns an EGroup containing all of the players entities of a specific unit_type (as defined by the type_ext on the entity) 

This function returns a new EGroup to allow tracking of different types.

 
EGroup  Player_GetEntityConcentration( PlayerID player[, Boolean popcapOnly, Table includeBlueprints, Table excludeBlueprints, Boolean bLeastConcentrated, MarkerID/Table onlyInThisMarker] )
 	
Finds the greatest (or least) concentration of entities owned by a player. 

This function is slow, so don't call it very often

 
int  Player_GetEntityCount( const ModPlayer* player )
 	
Returns the number of entities a player currently owns 

 
const char*  Player_GetEntityName( const ModPlayer* player, int index )
 	
Returns the name of an entity a player currently owns 

 
int  Player_GetID( const ModPlayer* player )
 	
Returns the id of the player 

 
float  Player_GetMaxPopulation( const ModPlayer* player, CapType capType )
 	
Use capType CT_Personnel to get max squad cap or CT_VehicleCap to get max vehicle cap. 

 
int  Player_GetNumStrategicPoints( const ModPlayer* p )
 	
Returns the number of strategic points (not objectives) this player owns 

 
int  Player_GetNumVictoryPoints( const ModPlayer* p )
 	
Returns the number of strategic objectives this player owns 

 
Real  Player_GetPopulationPercentage( PlayerID playerid[, Integer captype] )
 	
Gets the current personnel or vehicle population as a percetange of the current max-cap. The captype is either CT_Personnel or CT_Vehicle. 

captype is CT_Personnel by default.

 
int  Player_GetRace( const ModPlayer* player )
 	
Returns the race index for the given player. 

 
const char*  Player_GetRaceName( const ModPlayer* player )
 	
Returns the name of the race for a given player and always in english 

 
ModAlliance::AllianceResult  Player_GetRelationship( const ModPlayer* player1, ModPlayer* player2 )
 	
Returns the relationship between 2 players. 

 
float  Player_GetResource( const ModPlayer* player, ResourceAmount::ResourceType type )
 	
Returns the amount of resources a given player has. 

 
float  Player_GetResourceRate( const ModPlayer* player, ResourceAmount::ResourceType type )
 	
Returns the amount of resources a given player is getting per second. 

 
SGroup  Player_GetSquadConcentration( PlayerID player[, Boolean popcapOnly, Table includeBlueprints, Table excludeBlueprints, Boolean bLeastConcentrated, MarkerID/Table onlyInThisMarker] )
 	
Finds the greatest (or least) concentration of squads owned by a player. 

This function is slow, so don't call it very often

 
int  Player_GetSquadCount( const ModPlayer* player )
 	
Returns the number of squads a player currently owns 

 
SGroup*  Player_GetSquads( const ModPlayer* player )
 	
Returns a SquadGroupObs containing all the players units. 

This function returns a 'global' squad group with the name '__Player%dSquads', where %d is the player ID. This means that you should never need to destroy it./n However, if you do destroy it, it will be recreated the next time this function is called.

 
ScarPosition  Player_GetStartingPosition( const ModPlayer* player )
 	
Returns the starting position for this player 

 
float  Player_GetStrategicPointCaptureProgress( Player* player, Entity* strategicPoint )
 	
Returns a value (-1.0 to 1.0) of how close a point is to being controlled by the team of the player provided 

Progress between -1.0 and 0 means an enemy has progress toward owning a point. Values between 0 and 1.0 represent progress being made toward capture. 1.0 is a team controlled point. -1.0 is an enemy controlled point.

 
int  Player_GetTeam( const ModPlayer* p )
 	
Get the team a player is on 

 
int  Player_GetUnitCount( const ModPlayer* player )
 	
Returns the current number of units the player has. 

 
float  Player_GetUpgradeCost( ModPlayer* player, ScarUpgradePBG upgradePBG, ResourceAmount::ResourceType resourceType )
 	
Returns the cost of an upgrade.  

 
bool  Player_HasAbility( ModPlayer* pPlayer, ScarAbilityPBG pAbilityPBG )
 	
Tests to see if a player has an ability 

 
boolean  Player_HasBuilding( PlayerID player, BlueprintTable entitytypes )
 	
Returns true if this player owns any buildings listed in the table. 

This only looks at completed buildings - use Player_HasBuildingUnderConstruction to see if the player is building something

 
boolean  Player_HasBuildingsExcept( PlayerID playerId, BlueprintTable exceptions )
 	
Returns true if this player owns any buildings. (with exclusions). 

 
boolean  Player_HasBuildingUnderConstruction( PlayerID player, BlueprintTable entitytypes )
 	
Returns true if this player owns any buildings listed in the table currently under construction. 

 
bool  Player_HasCapturingSquadNearStrategicPoint( Player* player, Entity* strategicPoint )
 	
Returns true if the given player has units that are able to capture in the capturable area of the given strategic point 

 
Boolean  Player_HasLost( PlayerID player, LuaTable Blueprints )
 	
Checks to see if a player has lost (if player owns any squads and any buildings contained in blueprints) 

Pass in a table of blueprints of buildings that the player must have in order to be considered "alive". Ambient buildings are already take into consideration since they must be occupied by a squad.

 
bool  Player_HasMapEntryPosition( ModPlayer* player )
 	
Returns whether a player has a map entry position 

 
bool  Player_HasUpgrade( const ModPlayer* pPlayer, ScarUpgradePBG upgradePBG )
 	
Return true if the squad has purchased the specified upgrade. 

 
bool  Player_IsAlive( const ModPlayer* player )
 	
Returns true if player is still alive and false if player is dead. Will error if playerIdx is an invalid index. 

 
Boolean  Player_IsAllied( PlayerID playerId1, PlayerID playerId2 )
 	
Returns true if the players are allied and false if they are not. 

 
bool  Player_IsHuman( ModPlayer* pPlayer )
 	
Returns whether a player is human controlled (local or remote), not dead, and not replaced by an AI 

 
int  Player_NumUpgradeComplete( const ModPlayer* player, ScarSquadPBG upgradePBG )
 	
Returns the number of upgrades that this player has. 

 
Boolean  Player_OwnsEGroup( PlayerID playerid, EGroupID egroup[, Boolean all] )
 	
Returns true if a given player owns ALL or ANY items in a group 

 
Boolean  Player_OwnsEntity( PlayerID playerid, EntityID entity )
 	
Returns true if a given player owns an entity 

 
Boolean  Player_OwnsSGroup( PlayerID playerid, SGroupID sgroup[, Boolean all] )
 	
Returns true if a given player owns ALL or ANY items in a group 

 
Boolean  Player_OwnsSquad( PlayerID playerid, SquadID squad )
 	
Returns true if a given player owns a squad 

 
void  Player_RemoveAbilityLockoutZone( ModPlayer* player, ScarAbilityPBG abilityPBG, ScarMarker marker )
 	
Removes a marker that was previously a lockout zone. 

 
void  Player_RemoveUpgrade( ModPlayer* player, ScarUpgradePBG upgrade )
 	
Removes an upgrade from a player 

 
void  Player_ResetResource( ModPlayer* player, ResourceAmount::ResourceType type )
 	
Reset the resource amount for a given player to zero. Also reset team weapon 

 
Void  Player_RestrictAddOnList( PlayerID playerid, Table addonlist )
 	
Restrict a list of addons. 

list should contain an array of strings to restrict.

 
Void  Player_RestrictBuildingList( PlayerID playerid, Table blueprintlist )
 	
Restrict a list of buildings. 

list should contain an array of strings to restrict.

 
Void  Player_RestrictResearchList( PlayerID playerid, StringTable list )
 	
Restrict a list of research items. 

list should contain an array of strings to restrict.

 
Void  Player_SetAbilityAvailability( PlayerID player, AbilityBlueprint/Table bp, Integer availability )
 	
Sets the availability of an ability. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT 

 
void  Player_SetAllCommandAvailabilityInternal( ModPlayer* player, ModPlayer::Availability availability, LocString reason )
 	
Sets availability of ALL entity, squad and player commands.  

 
Void  Player_SetCommandAvailability( PlayerID player, Integer/Table command, Integer availability )
 	
Sets the availability of entity, squad and player commands. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT 

 
Void  Player_SetConstructionMenuAvailability( PlayerID player, String/Table menuname, Integer availability )
 	
Sets the availability of a construction menu. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT 

 
void  Player_SetDefaultSquadMoodMode( ModPlayer* pPlayer, SquadCombatBehaviourExt::MoodMode mood )
 	
Set default squad mood mode which can be overrided by squad level mood mode settings 

 
Void  Player_SetEntityProductionAvailability( PlayerID player, EntityBlueprint/Table bp, Integer availability )
 	
Sets the availability of an entity production item. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT 

 
void  Player_SetHeatGainRate( ModPlayer* player, float gainRatePerSecond )
 	
Set the heat gain rate per second for this player. Heat is gained when near a heat source or garrisoned. 

 
void  Player_SetHeatLossRate( ModPlayer* player, float lossRatePerSecond )
 	
Set the heat loss rate per second for this player. Heat is lost when not garrisoned and not near a heat source and not in valid cover. A value of 0 turns off the Cold System for all squads belonging to this player. It will also reset all squads to the default heat level. 

 
Void  Player_SetMaxCapPopulation( PlayerID playerid, Integer captype, Integer newcap )
 	
Sets the current personnel or vehicle max-cap for a player. The captype is either CT_Personnel or CT_Vehicle (you can't adjust Medic caps just yet). 

you will have to call Player_SetMaxPopulation to adjust the current max population to do this.

 
Void  Player_SetMaxPopulation( PlayerID playerid, Integer captype, Integer newcap )
 	
Sets the current personnel or vehicle cap for a player. The captype is either CT_Personnel or CT_Vehicle (you can't adjust Medic caps just yet). 

Note that any modifiers that adjust the current cap will be applied on top of this. Also note, the current cap cannot go higher than the max cap.

 
void  Player_SetPopCapOverride( ModPlayer* player, float personnel )
 	
Sets a pop cap override that ignores any modifiers. 

 
void  Player_SetResource( ModPlayer* player, ResourceAmount::ResourceType type, float amt )
 	
Set the resource amount for a given player. Ignores income cap and resource sharing. 

 
Void  Player_SetSquadProductionAvailability( PlayerID player, SquadBlueprint/Table bp, Integer availability )
 	
Sets the availability of a squad production item. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT 

 
Void  Player_SetUpgradeAvailability( PlayerID player, UpgradeBlueprint/Table bp, Integer availability )
 	
Sets the availability of an upgrade. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT 

 
Void  Player_SetUpgradeCost( PlayerID player, UpgradeID upgrade, Real manpower, Real fuel, Real munition, Real action, Real command )
 	
Sets the cost of an upgrade. 

 
Entity*  Player_SpawnGlider( ModPlayer* player, ScarEntityPBG glider, ScarPosition start, ScarPosition end )
 	
Spawns a glider and returns it 

 
void  Player_StopAbility( ModPlayer* player, ScarAbilityPBG ability, bool bEarlyExit )
 	
Abruptly stops an active ability 

 
Void  Player_StopEarningActionPoints( PlayerID player )
 	
Prevents a player from earning any action points (and by extention, command points) 

 
void  Player_Triangulate( ModPlayer* player, SGroup* squads, EGroup* eg )
 	
Returns the enemy squads and entities within a player's radio beacons. Radio beacons are shared among team members. 

 
 

 

Presentation
Functions

Void  Actor_Clear( ActorTable actor )
 	
Clear ties between an actor and any units 

 
Void  Actor_PlaySpeech( ActorTable actor, Integer locID[, Boolean continueButton, Boolean stickySubtitle, Boolean blockInput] )
 	
Plays a speech event for a given actor WITH a portrait and subtitle 

Be VERY careful how you use the 'blockInput' parameter. It blocks all input except mouse movement, a few critical keyboard keys, and the Continue and Menu buttons. So you should always allow a continue button when blocking input. You shouldn't block input for a sticky subtitle! If the speech file is not available, a placeholder time will be calculated for the message using the number of words and the message will be displayed for that length of time.<BR/> Actors: ACTOR.GenericAlly, ACTOR.GenericAxis, ACTOR.Keller, ACTOR.McKay, ACTOR.Conti, ACTOR.Franks, ACTOR.Peoples, ACTOR.Coogi, etc...

 
Void  Actor_PlaySpeechWithoutPortrait( ActorTable actor, Integer locID[, Boolean continueButton, Boolean stickySubtitle, Boolean blockInput] )
 	
Plays a speech event for a given actor WITHOUT a portrait or subtitle. See Actor_PlaySpeech for more details 

 
Void  Actor_SetFromSGroup( ActorTable actor, SGroupID sgroup )
 	
Tie an entire sgroup to an actor, so audio comes from a squad member 

 
Void  Actor_SetFromSquad( ActorTable actor, SquadID squad )
 	
Tie a single squad to an actor, so audio comes from a squad member 

 
 

 

Proximity
Functions

Boolean  Prox_AreEntitiesNearMarker( EGroupID egroup, MarkerID/Position/SectorID position, Boolean all[, Real range] )
 	
Returns true if ANY or ALL entities from a group are in range of a given position, marker, or territory sector. 

Markers with proximity type rectangle will use circular proximity check if custom range is supplied<BR/>

 
Boolean  Prox_ArePlayerMembersNearMarker( PlayerID player, MarkerID/Position/SectorID position, Boolean all[, Real range, SBP/Table filterlist, Integer filtertype] )
 	
Returns true if ANY or ALL of a player's members (i.e. individual guys, not squads as a whole) are in range of a given position, marker, or territory sector. DO NOT USE THIS FUNCTION UNLESS YOU ABSOLUTELY HAVE TO!! 

You MUST specify a range if you are using a position rather than a marker.

 
Boolean  Prox_ArePlayersNearMarker( PlayerID player, MarkerID/Position/SectorID position, Boolean all[, Real range, SBP/Table filterlist, Integer filtertype] )
 	
Returns true if ANY or ALL of a player's squads are in range of a given position, marker, or territory sector. THIS FUNCTION IS VERY SLOW. DO NOT USE THIS UNLESS ABSOLUTELY NECESSARY. 

Markers with proximity type rectangle will use circular proximity check if custom range is supplied<BR/>

 
Boolean  Prox_AreSquadMembersNearMarker( SGroupID sgroup, MarkerID/Position/SectorID position, Boolean all[, Real range] )
 	
Returns true if ANY or ALL squad members (i.e. individual guys, not squads as a whole) from a group are in range of a given position, marker, or territory sector. DO NOT USE THIS FUNCTION UNLESS YOU ABSOLUTELY HAVE TO!! 

Markers with proximity type rectangle will use circular proximity check if custom range is supplied<BR/>

 
Boolean  Prox_AreSquadsNearMarker( SGroupID sgroup, MarkerID/Position/SectorID position, Boolean all[, Real range] )
 	
Returns true if ANY or ALL squads from a group are in range of a given position, marker, or territory sector 

Markers with proximity type rectangle will use circular proximity check if custom range is supplied<BR/>

 
Boolean  Prox_AreTeamsNearMarker( TeamID team, MarkerID/Position/SectorID position, Boolean all[, Real range, SBP/Table filterlist, Integer filtertype] )
 	
Returns true if ANY or ALL of a teams's squads are in range of a given position, marker, or territory sector. THIS FUNCTION IS VERY SLOW. DO NOT USE THIS UNLESS ABSOLUTELY NECESSARY. 

Markers with proximity type rectangle will use circular proximity check if custom range is supplied<BR/>

 
Real  Prox_EGroupEGroup( EGroupID egroup1, EGroupID egroup2, ProxType checktype )
 	
Returns the distance between two entity groups. use checktype PROX_SHORTEST, PROX_LONGEST, or PROX_CENTER. 

If check is PROX_SHORTEST this will return the shortest distance between the two groups.<BR/> If check is PROX_LONGEST this will return the longest distance between the two groups.<BR/> If check is PROX_CENTER this will return the distance between the two groups centers.<BR/>

 
Real  Prox_EGroupSGroup( EGroupID egroup1, SGroupID sgroup2, ProxType checktype )
 	
Returns the distance between an entity group and a squad group. use checktype PROX_SHORTEST, PROX_LONGEST, or PROX_CENTER. 

If check is PROX_SHORTEST this will return the shortest distance between the two groups.<BR/> If check is PROX_LONGEST this will return the longest distance between the two groups.<BR/> If check is PROX_CENTER this will return the distance between the two groups centers.<BR/>

 
Boolean  Prox_EntitiesInProximityOfEntities( EGroupID egroup1, EGroupID egroup2, Real proximity, Boolean all )
 	
Checks if ALL or ANY entities are in proximity of a given entity group. 

Set "all" to true to check that ALL entities are in proximity, or set "all" to false to check for ANY.

 
Position  Prox_GetRandomPosition( Object item, Integer radius, Integer minimum )
 	
Takes something (Entity, Squad, SGroup, EGroup, Position) in, then returns a random position 

Minimum is ignored if it is greater than the radius

 
Real  Prox_MarkerEGroup( MarkerID marker, EGroupID egroup, ProxType checktype )
 	
Returns the distance between a marker and an entity group. use checktype PROX_SHORTEST, PROX_LONGEST, or PROX_CENTER. 

If check is PROX_SHORTEST this will return the shortest distance between the two groups.<BR/> If check is PROX_LONGEST this will return the longest distance between the two groups.<BR/> If check is PROX_CENTER this will return the distance between the two groups centers.<BR/>

 
Real  Prox_MarkerSGroup( MarkerID marker, SGroupID sgroup, ProxType checktype )
 	
Returns the distance between a marker and a squad group. use checktype PROX_SHORTEST, PROX_LONGEST, or PROX_CENTER. 

If check is PROX_SHORTEST this will return the shortest distance between the two groups.<BR/> If check is PROX_LONGEST this will return the longest distance between the two groups.<BR/> If check is PROX_CENTER this will return the distance between the two groups centers.<BR/>

 
Boolean  Prox_PlayerEntitiesInProximityOfEntities( PlayerID playerid, EGroupID egroup, Real proximity, Boolean all, EntityID exclude )
 	
Checks if ALL or ANY players squads are in proximity of a given entity group. 

Set "all" to true to check that ALL entities are in proximity, or set "all" to false to check for ANY.

 
Boolean  Prox_PlayerEntitiesInProximityOfPlayerSquads( PlayerID playerentities, PlayerID playersquads, Real proximity, Boolean all )
 	
Checks if ALL or ANY players entities are in proximity of a given squad group. 

Set "all" to true to check that ALL entities are in proximity, or set "all" to false to check for ANY.

 
Boolean  Prox_PlayerEntitiesInProximityOfSquads( PlayerID playerid, SGroupID sgroup, Real proximity, Boolean all )
 	
Checks if ALL or ANY players entities are in proximity of a given squad group. 

Set "all" to true to check that ALL entities are in proximity, or set "all" to false to check for ANY.

 
Boolean  Prox_PlayerSquadsInProximityOfEntities( PlayerID playerid, EGroupID egroup, Real proximity, Boolean all, SBP/Table filterlist, Int filtertype )
 	
Checks if ALL or ANY players squads are in proximity of a given entity group. 

Set "all" to true to check that ALL squads are in proximity, or set "all" to false to check for ANY.

 
Boolean  Prox_PlayerSquadsInProximityOfPlayerEntities( PlayerID playersquads, PlayerID playerentities, Real proximity, Boolean all )
 	
Checks if ALL or ANY players squads are in proximity of a given players entities. 

Set "all" to true to check that ALL squads are in proximity, or set "all" to false to check for ANY.

 
Boolean  Prox_PlayerSquadsInProximityOfPlayerSquads( PlayerID playerid1, PlayerID playerid2, Real proximity, Boolean all )
 	
Checks if ALL or ANY players squads are in proximity of a given players squads. 

Set "all" to true to check that ALL squads are in proximity, or set "all" to false to check for ANY.

 
Boolean  Prox_PlayerSquadsInProximityOfSquads( PlayerID playerid, SGroupID sgroup, Real proximity, Boolean all, SquadID exclude, SBP/Table filterlist, Int filtertype )
 	
Checks if ALL or ANY players squads are in proximity of a given squad group. 

Set "all" to true to check that ALL squads are in proximity, or set "all" to false to check for ANY.

 
Real  Prox_SGroupSGroup( SGroupID sgroup1, SGroupID sgroup2, ProxType checktype )
 	
Returns the distance between two squad groups. use checktype PROX_SHORTEST, PROX_LONGEST, or PROX_CENTER. 

If check is PROX_SHORTEST this will return the shortest distance between the two groups.<BR/> If check is PROX_LONGEST this will return the longest distance between the two groups.<BR/> If check is PROX_CENTER this will return the distance between the two groups centers.<BR/>

 
Boolean  Prox_SquadsInProximityOfEntities( SGroupID sgroup, EGroupID egroup, Real proximity, Boolean all )
 	
Checks if ALL or ANY squads are in proximity of a given entity group. 

Set "all" to true to check that ALL squads are in proximity, or set "all" to false to check for ANY.

 
Boolean  Prox_SquadsInProximityOfSquads( SGroupID sgroup1, SGroupID sgroup2, Real proximity, Boolean all )
 	
Checks if ALL or ANY squads are in proximity of a given squad group. 

Set "all" to true to check that ALL squads are in proximity, or set "all" to false to check for ANY.

 
 

 

RuleSystem
Functions

Void  Rule_Add( LuaFunction rule[, Integer priority] )
 	
Add a rule to be executed every frame. Priority can be from 0 to 1000, with 0 being the lowest. Priority is used in conjunction with Rule_RemoveAll so that rules with high priority do not get removed. 

 
Void  Rule_AddDelayedInterval( LuaFunction rule, Real delay, Real interval[, Integer priority] )
 	
Add a rule to be executed at every 'interval' seconds, after an initial delay. Priority can be from 0 to 1000, with 0 being the lowest. Priority is used in conjunction with Rule_RemoveAll so that rules with high priority do not get removed. 

 
Void  Rule_AddDelayedIntervalEx( LuaFunction rule, Real delay, Real interval, Integer calls[, Integer priority, Integer calls] )
 	
Add a rule to be executed 'calls' times, at every 'interval' seconds, after an initial delay. Priority can be from 0 to 1000, with 0 being the lowest. Priority is used in conjunction with Rule_RemoveAll so that rules with high priority do not get removed. 

 
Void  Rule_AddEGroupEvent( LuaFunction rule, EGroupID egroup, Integer eventtype )
 	
Add a rule to be executed when the event of 'eventType' has happened on entities in the 'egroup' 

Event types are: GE_EntityKilled

 
Void  Rule_AddEntityEvent( LuaFunction rule, EntityID entity, Integer eventtype )
 	
Add a rule to be executed when the event of 'eventType' has happened on the 'entity' 

Event types are: GE_EntityKilled

 
Void  Rule_AddGlobalEvent( LuaFunction rule, Integer eventtype )
 	
Add a rule to be executed when the event of 'eventType' has happened, regardless of source 

Event types are: GE_PlayerBeingAttacked

 
Void  Rule_AddInterval( LuaFunction rule, Real interval[, Integer priority] )
 	
Add a rule to be executed at every 'interval' seconds. Priority can be from 0 to 1000, with 0 being the lowest. Priority is used in conjunction with Rule_RemoveAll so that rules with high priority do not get removed. 

 
Void  Rule_AddIntervalEx( LuaFunction rule, Real interval, Integer calls[, Integer priority] )
 	
Add a rule to be executed 'calls' times, at every 'interval' seconds. Priority can be from 0 to 1000, with 0 being the lowest. Priority is used in conjunction with Rule_RemoveAll so that rules with high priority do not get removed. 

 
Void  Rule_AddOneShot( LuaFunction rule, Real delay[, Integer priority] )
 	
Add a rule to be executed once, after 'delay' seconds. Priority can be from 0 to 1000, with 0 being the lowest. Priority is used in conjunction with Rule_RemoveAll so that rules with high priority do not get removed. 

 
Void  Rule_AddPlayerEvent( LuaFunction rule, PlayerID player, Integer eventtype )
 	
Add a rule to be executed when the event of 'eventType' has happened on the 'player' 

Event types are: GE_PlayerBeingAttacked

 
Void  Rule_AddSGroupEvent( LuaFunction rule, SGroupID sgroup, Integer eventtype )
 	
Add a rule to be executed when the event of 'eventType' has happened on squads in the 'sgroup' 

Event types are: GE_SquadKilled, GE_SquadPinned, GE_SquadCommandIssued, GE_AbilityExecuted

 
Void  Rule_AddSquadEvent( LuaFunction rule, SquadID squad, Integer eventtype )
 	
Add a rule to be executed when the event of 'eventType' has happened on the 'squad' 

Event types are: GE_SquadKilled, GE_SquadPinned, GE_SquadCommandIssued, GE_AbilityExecuted

 
Void  Rule_ChangeInterval( LuaFunction rule, Real interval )
 	
Change 'interval' seconds of an existing rule 

 
Boolean  Rule_Exists( LuaFunction rule )
 	
Test if a rule is currently active 

 
Void  Rule_Remove( LuaFunction rule )
 	
Remove a currently active rule (this does not remove any event rules) 

 
Void  Rule_RemoveAll( [Integer max_priority] )
 	
Kills all rules below a certain priority. The default is to remove ALL rules. 

 
Void  Rule_RemoveEGroupEvent( LuaFunction rule, EGroupID egroup )
 	
Remove an active event rule for entities in the 'egroup' 

 
Void  Rule_RemoveEntityEvent( LuaFunction rule, EntityID entity )
 	
Remove an active event rule for the 'entity' 

 
Void  Rule_RemoveGlobalEvent( LuaFunction rule )
 	
Remove an active event rule that's been applied 'globally' 

 
Void  Rule_RemoveIfExist( LuaFunction rule )
 	
Remove a currently active rule if it exists(this does not remove any event rules) 

 
Void  Rule_RemoveMe( )
 	
Remove a currently executing rule (only works inside a rule function) 

 
Void  Rule_RemovePlayerEvent( LuaFunction rule, PlayerID player )
 	
Remove an active event rule for the 'player' 

 
Void  Rule_RemoveSGroupEvent( LuaFunction rule, SGroupID sgroup )
 	
Remove an active event rule for squads in the 'sgroup' 

 
Void  Rule_RemoveSquadEvent( LuaFunction rule, SquadID squad )
 	
Remove an active event rule for the 'squad' 

 
 

 

Setup
Functions

PlayerID  Setup_Player( Integer playerIndex, LocString playerName, String playerRace, Integer team )
 	
Initializes the all of the players settings in one function and returns the playerID. 

In most cases you will call this function from OnGameSetup and store the returned playerId in a global variable. The player index should be in the range [1 , (numPlayers)].<BR/><BR/> Valid player races: "Allied Airborne Company", "Allied Assault Company", "Allied Rifle Company", "Allied Tank Company", "Axis Armored Company","Axis Heavy Tank Company", "Axis Infantry Company","Axis Pioneer Company"<BR/><BR/> Example:<BR/> function OnGameSetup( )<BR/> <TAB/>g_player1 = Setup_Player(0, "PlayerDisplayName", "Allied Assault Company", 1)<BR/> <TAB/>-- g_player2 and g_player3 will be on the same team (allies)<BR/> <TAB/>g_player2 = Setup_Player(1, "$20000", "Axis Infantry Company", 2)<BR/> <TAB/>g_player3 = Setup_Player(2, "$20001", "Axis Infantry Company", 2)<BR/> --? The team ID starts from one!! end

 
 

 

SGroup
Functions

Void  Cmd_StopSquadsExcept( SGroupID sgroup1[, Boolean stopCapture, Boolean stopBuild] )
 	
Pass in a group to command to 'stop'. Pass in booleans for capturing and building 

 
Void  Misc_IsEGroupOnScreen( EGroupID group, Real percent, Boolean all )
 	
Test whether ANY or ALL of an EGroup is on screen currently (not strict)  

 
Void  Misc_IsSGroupOnScreen( SGroupID group, Real percent, Boolean all )
 	
Test whether ANY or ALL of an SGroup is on screen currently (not strict)  

 
Void  Rule_AddEGroupEvent( LuaFunction fule, EGroup egroup, Integer eventtype )
 	
Add a rule to be executed when the event of 'eventType' has happened on the 'EGroup' Event types are: GE_EntityKilled 

 
void  SGroup_Add( SGroup* group, Squad* squadron )
 	
Adds an squadron to the end of a group if the group doesnt already have it. 

 
Void  SGroup_AddAbility( SGroupID sgroup, AbilityBlueprint ability )
 	
Adds an ability to all squads in an sgroup. 

 
void  SGroup_AddGroup( SGroup* group, SGroup* grouptoadd )
 	
Same as EGroup_AddGroup. Note: You cannot mix squad groups and entity groups. 

 
Void  SGroup_AddGroups( SGroupID sgroup, Table groupList )
 	
Add a list of multiple sgroups into an existing group. 

 
Void  SGroup_AddLeaders( SGroupID sgroup )
 	
Adds a leader to all squads in a group that can take a leader. 

This function will bypass all cost and queue prereqs

 
Void  SGroup_AddSlotItemToDropOnDeath( SGroupID groupid, Int itemid, Float drop_chance, Bool exclusive )
 	
Add to the list of slot items to drop when any one of the squads is wiped out 

SGroup_AddSlotItemToDropOnDeath( squadid, item, false )

 
Void  SGroup_CanCastAbilityOnEntity( SGroupID caster, AbilityBlueprint ability, EntityID target_entity, Boolean all )
 	
Test whether ANY or ALL of a group can be ordered to do this ability on the target squad 

 
Void  SGroup_CanCastAbilityOnPosition( SGroupID caster, AbilityBlueprint ability, Position position, Boolean all )
 	
Test whether ANY or ALL of a group can be ordered to do this ability on the target position 

 
Void  SGroup_CanCastAbilityOnSquad( SGroupID caster, AbilityBlueprint ability, SquadID target_squad, Boolean all )
 	
Test whether ANY or ALL of a group can be ordered to do this ability on the target entity 

 
Boolean  SGroup_CanInstantReinforceNow( SGroupID group, Boolean all )
 	
Return true if ANY or ALL of a group can reinforce now 

 
Boolean  SGroup_CanSeeSGroup( SGroupID sgroup, SGroupID targetsgroup, Boolean all )
 	
Returns true if ALL or ANY squads in a group can see ALL or ANY squads in a target sgroup. 

 
void  SGroup_Clear( SGroup* sgroup )
 	
Removes all entities from a group. 

 
void  SGroup_ClearPostureSuggestion( SGroup* sgroup )
 	
Clears any previous posture suggestions made to a squad 

 
bool  SGroup_Compare( SGroup* group1, SGroup* group2 )
 	
Returns true if the contents of the two groups are equal. Order of the entities does not matter. 

 
Void  SGroup_CompleteEntityUpgrade( SGroupID sgroup, UpgradeID upgrade )
 	
Applies an upgrade to all squad entities in an sgroup. 

 
Boolean  SGroup_ContainsBlueprints( SGroupID sgroup, BP/Table blueprints, Boolean all )
 	
Check if a group contains ALL or ANY of the blueprints. 

 
bool  SGroup_ContainsSGroup( SGroup* group1, SGroup* group2, bool all )
 	
Returns true if SGroup1 contains ANY or ALL of SGroup2 

 
bool  SGroup_ContainsSquad( SGroup* group, uint32_t SquadID )
 	
Returns true if SGroup contains a particular SquadID 

 
int  SGroup_Count( SGroup* sgroup )
 	
Returns the total number of spawned and despawned squads in a group. 

NOTE: SGroup_Count does not count the individual soldiers in an SGroup. For that, use SGroup_TotalMembersCount

 
int  SGroup_CountDeSpawned( SGroup* sgroup )
 	
Returns the number of despawned squads in a group. 

 
int  SGroup_CountSpawned( SGroup* sgroup )
 	
Returns the number of spawned squads in a group. 

 
SGroup*  SGroup_Create( const char* name )
 	
Returns a new squadron group with the given name.  

Squad groups are used for all units and vehicles. You can issue orders such as move and attack to an entire squad group. If you want a group for buildings or objects such as trees, use an EntityGroupObs instead.<BR/> Note that you are allowed to have unamed squadgroups or squadgroups with the samename. Be careful not to create duplicates of your squad group when you dont intend to. To be safe, you can check if the SquadGroupObs you want to create exists using SGroup_Exists( )

 
SGroupID  SGroup_CreateIfNotFound( String name )
 	
Find a squad group from name. Creates a new one with given name if it doesnt exist. 

 
Void  SGroup_CreateKickerMessage( SGroupID group, PlayerID player, LocString textid )
 	
Create and display kicker message on the each squad in the sgroup to the player 

 
Void  SGroup_DeSpawn( SGroupID groupid )
 	
Despawn all spawned squads in a group. 

 
void  SGroup_Destroy( SGroup* egroup )
 	
Manually destroy a group that you dont need anymore. 

 
Void  SGroup_DestroyAllInMarker( SGroupID sgroup, MarkerID marker )
 	
Destroys all items in a group that are in proximity to a given marker. 

 
Void  SGroup_DestroyAllSquads( SGroupID sgroup )
 	
Destroys all spawned and despawned squads in a group. 

Be careful not to confuse this with SGroup_Destroy which destroys the group and NOT the squads it contains. This function will destroy spawned and despawned items in a group

 
Void  SGroup_DisableCombatPlans( SGroupID groupID )
 	
Disables all current combat plans for the squads in the sgroup 

 
Void  SGroup_Duplicate( SGroupID sgroup1, SGroupID sgroup2 )
 	
Duplicates an SGroup 

Creates a copy of sgroup1 in sgroup2. The function will clear sgroup2 beforehand if necessary.

 
Void  SGroup_EnableAttention( SGroupID sgroup, Boolean attentive )
 	
Sets whether an entity pays attention to its surroundings 

 
Void  SGroup_EnableMinimapIndicator( SGroupID group, Boolean enable )
 	
Enable or disable minimap indicator on all squads in the sgroup 

 
Void  SGroup_EnableSurprise( SGroupID groupid, Boolean enable )
 	
Enables or disables the surprise feature for an sgroup 

 
Void  SGroup_EnableUIDecorator( SGroupID group, Boolean enable )
 	
Enable or disable decorators on all squads in the sgroup  

 
bool  SGroup_Exists( const char* name )
 	
Returns true if the squad group with the given name exists 

 
Void  SGroup_FaceEachOther( SGroupID sgroup1, SGroupID sgroup2 )
 	
Makes two SGroups face each other 

 
Void  SGroup_FaceMarker( SGroupID sgroup, MarkerID marker )
 	
Makes a SGroup face a marker. 

 
Void  SGroup_Filter( SGroupID sgroup, ID/Table blueprint, Integer!filtertype [, SGroupID splitSGroup] )
 	
Filters an SGroup by blueprint. 

Blueprints can be provided by name or by ID, and in a table if you want to filter on more than one type. Setting filtertype to FILTER_KEEP results in the group only containing squads of the types listed in the blueprint table. Setting filtertype to FILTER_REMOVE will strip those same squads out and leave those that aren't of the types listed. Setting splitSGroup will move any squads being KEEP or REMOVE to it. This SGroup will NOT be cleared beforehand.

 
Void  SGroup_FilterCount( SGroupID sgroup1, Int groupSize )
 	
Pass in a group and it will filter it down to the indicated number 

 
Void  SGroup_FilterThreat( SGroupID sgroup, LuaTable tableSBPs, [Boolean bEmpty] )
 	
Searches an SGroup and finds the first threat within the table (searching first to last) and removes all other SBPs. 

Optional parameter bEmpty can be set to true, will clear the SGroup if none of the SBPS in the table are found.

 
bool  SGroup_ForEach( SGroup* sgroup, LuaBinding::StackVarFunction f )
 	
Call a lua function for each item in a group. Function will recieve (groupid, itemindex, itemid) and should return true to break or false to continue. 

function Rule_Test( )<BR/> <TAB/>local DespawnSquad = function( sgroupid, itemindex, squadID )<BR/> <TAB/><TAB/>Squad_Despawn( squadID )<BR/> <TAB/>end<BR/><BR/> <TAB/>SGroup_ForEach( SGroup_FromName("sg_Squads"), DespawnSquad )<BR/> end<BR/><BR/> This functions iterates over spawned squads only.

 
bool  SGroup_ForEachAllOrAny( SGroup* sgroup, bool all, LuaBinding::StackVarFunction f )
 	
Call a lua function for each item in a group. Function will receive (groupid, itemindex, itemid) and should return a bool. 

Only use this to TEST conditions on squads. DO NOT use this to perform operations on all squads, since it may not call your function on all squads (due to short circuit evaluation). This is used for checking if ALL or ANY items in a group match a given predicate. (eg. Are all items in a group chaos marines)<BR/> This functions iterates over spawned squads only.

 
bool  SGroup_ForEachAllOrAnyEx( SGroup* sgroup, bool all, LuaBinding::StackVarFunction f, bool spawned, bool despawned )
 	
Same as SGroup_ForEachAllOrAny except you have a choice to iterate over spawned squads, despawned squads, or both. 

 
bool  SGroup_ForEachEx( SGroup* sgroup, LuaBinding::StackVarFunction f, bool spawned, bool despawned )
 	
Same as SGroup_ForEach except you have a choice to iterate over spawned squads, despawned squads, or both. 

 
SGroup*  SGroup_FromName( const char* name )
 	
Find an squadron group with a given name. 

 
Real  SGroup_GetAvgHealth( SGroupID sgroup )
 	
Returns the average health of all units in a squad group. 

It now uses the same health measure that's used by the UI, so it does take into account fallen members of a squad

 
Real  SGroup_GetAvgLoadout( SGroup sgroup )
 	
Returns the average loadout of all squads in a group as a percent [0.0, 1.0]. 

Example: A group of squads with loadouts of 4/8 and 1/1 would return 0.75

 
Squad*  SGroup_GetDeSpawnedSquadAt( SGroup* group, unsigned int index )
 	
Returns the despawned squad at a certain position in the group. 

This is a one-based index (use index 1 to get the first squad in the group.) It is an error if index > SGroup_GetDeSpawnedCount().

 
EntityID  SGroup_GetGarrisonedBuildingEntity( SGroupID groupid )
 	
Get the entity id of the building that any squad of the sgroup is garrisoned in 

 
Void  SGroup_GetHoldEGroup( SGroupID sgroup, EGroup EGroupHold )
 	
Gets all the entities that an SGroup may occupy and adds them to the EGroupHold 

 
Void  SGroup_GetHoldSGroup( SGroupID sgroup, SGroup SGroupHold )
 	
Gets all the squads that an SGroup may occupy and adds them to the SGroupHold 

 
Boolean  SGroup_GetInvulnerable( SGroupID sgroup, Boolean all )
 	
Check invulnerablity state for ALL or ANY squads in a squad group. 

Set all param to true to check for ALL or set to false to check for ANY.

 
Void  SGroup_GetLastAttacker( SGroup SGroupVictim, SGroup SGroupAttacker[, Real seconds] )
 	
Gets the last attacker(s) for all the squads in an SGroup Gets the last attacker for all the squads in an SGroup and stores that in SGroupAttacker 

 
SquadID  SGroup_GetLoadedVehicleSquad( SGroupID groupid )
 	
Get the squad id of the vehicle squad that any squad of the sgroup is loaded in 

 
const char*  SGroup_GetName( SGroup* sgroup )
 	
Returns the name of a given squad group. 

 
Int  SGroup_GetNumSlotItem( SGroupID group, Int itemID )
 	
Get the number of slot items with the same ID that the squads in the sgroup own 

 
Position  SGroup_GetOffsetPosition( SGroupID sgroup, Integer offset, Real value )
 	
Returns a position (a certain distance away) relative to a squad's current position/orientation. see LuaConsts.scar for explanation of 'offset' parameter 

 
ScarPosition  SGroup_GetPosition( SGroup* group )
 	
Returns the center position of a squad group. 

Despawned squads are ignored.

 
SquadID  SGroup_GetRandomSpawnedSquad( SGroup sgroupid )
 	
Get a random spawned squad from sgroup 

 
Table  SGroup_GetSequence( String name )
 	
Builds a table of SGroupIDs that are named in a sequence. i.e. a name of "sg_killer" will find groups "sg_killer1", "sg_killer2" and so on, up until it looks for a group that isn't there. 

 
Squad*  SGroup_GetSpawnedSquadAt( SGroup* group, unsigned int index )
 	
Returns the spawned squad at a certain position in the group. 

This is a one-based index (use index 1 to get the first squad in the group.) It is an error if index > SGroup_GetSpawnedCount().

 
Real  SGroup_GetSpread( SGroupID sgroup )
 	
Returns the distance from the centre of the group of the unit that furthest out.  

 
Void  SGroup_GetSquadsHeld( SGroupID sgroup, SGroupID sgroupRecipient )
 	
Returns an sgroup containing all squads held by any squad in an sgroup 

 
Float  SGroup_GetSuppression( SGroupID groupid )
 	
Get the suppression level for the first squad in the sgroup 

 
Float  SGroup_GetVeterancyExperience( SGroupID groupid )
 	
Get the veterancy experience value for the first squad in the sgroup 

 
Int  SGroup_GetVeterancyRank( SGroupID groupid )
 	
Get the veterancy rank for the first squad in the sgroup 

 
Boolean  SGroup_HasCritical( SGroupID group, CriticalID critical, Boolean all )
 	
Returns true if ANY or ALL of the squads in the SGroup have the specified critical 

 
Boolean  SGroup_HasLeader( SGroupID sgroup, Boolean all )
 	
Check if ALL or ANY squads in a sgroup have a leader 

Set all param to true to check for ALL or set to false to check for ANY.

 
Boolean  SGroup_HasSquadBlueprint( SGroupID sgroup, BP blueprint, Boolean all )
 	
Check if ALL or ANY of the squads in a group have a specific blueprint. 

 
Boolean  SGroup_HasTeamWeapon( SGroupID sgroup, Boolean all )
 	
Returns true if ANY or ALL of the squads in an SGroup are carrying some kind of team weapon 

 
Boolean  SGroup_HasUpgrade( SGroupID sgroup, UpgradeID upgrade, Boolean all )
 	
Returns whether ANY or ALL squads in an SGroup have the specified upgrade 

 
Void  SGroup_Hide( SGroupID sgroup, Bool hide )
 	
Hide or show all entities in all squads in an SGroup 

Bool should be true to hide, false to show

 
Void  SGroup_IncreaseVeterancyExperience( SGroupID groupid, Float experience[, Boolean silent, Boolean applyModifiers] )
 	
Increase squad veterancy experience for all squads in the sgroup. Can do silent promotion (no sound/UI). Can skip modifiers, giving you direct control of experience gained. 

 
Void  SGroup_IncreaseVeterancyRank( SGroupID groupid[, Integer numranks, Boolean silent] )
 	
Increase squad veterancy rank for all squads in the sgroup. By default, increases rank by 1. Can do silent promotion (no sound/UI. ex: mass rank insrease at mission start) 

 
void  SGroup_Intersection( SGroup* group, SGroup* grouptointersect )
 	
Same as EGroup_Intersection. Note: You cannot mix squad groups and entity groups. 

Only squads that are in both groups will be added to 'group'.<BR/> The contents of 'grouptointersect' will not be changed.<BR/> Example: group = (1,2,3,4,5,6) grouptointersect = (2,4,6,8,10) --> group will now equal (2,4,6)

 
Boolean  SGroup_IsAlive( SGroupID sgroup )
 	
Returns true if a named squad group is not empty and its average health is > 0.0 

 
Boolean  SGroup_IsAttackMoving( SGroupID sgroup, Boolean all )
 	
Returns true if ANY or ALL squads in an SGroup are attack moving. 

 
Boolean  SGroup_IsCamouflaged( SGroupID sgroup, Boolean all )
 	
Returns true if ANY or ALL of the squads in an SGroup are camouflaged 

 
Boolean  SGroup_IsCapturing( SGroupID sgroup, Boolean ALL )
 	
Checks if ANY or ALL squads in an SGroup are capturing 

 
Boolean  SGroup_IsConstructingBuilding( SGroup sgroup, Boolean all )
 	
Returns true if ALL or ANY squads in a group are currently constructing a building. 

Set all to true to check for ALL or set to false to check for ANY

 
Boolean  SGroup_IsDoingAbility( SGroupID sgroupid, AbilityID ability, Boolean all )
 	
Returns if ANY or ALL members of an SGroup are doing an ability 

 
Boolean  SGroup_IsDoingAttack( SGroupID sgroup, Boolean all, Float time )
 	
Returns true if ALL or ANY squads are attacking within the time. 

 
Boolean  SGroup_IsDugIn( SGroupID group, Boolean all )
 	
Returns true if ANY or ALL of the squads in the SGroup is dug in (or in the process of digging in) 

 
Boolean  SGroup_IsEmpty( SGroupID sgroup )
 	
Returns true if a named squad group is empty 

 
Boolean  SGroup_IsFemale( SGroupID sgroup, Boolean all )
 	
Returns true if ANY or ALL squads are female 

 
Void  SGroup_IsHoldingAny( SGroupID sgroup )
 	
Returns whether any entity in an SGroup has a hold on anything 

 
Boolean  SGroup_IsIdle( SGroupID sgroup, Boolean ALL )
 	
Checks if ANY or ALL squads in an SGroup are idle 

 
Real/Boolean  SGroup_IsInCover( SGroupID sgroup[, Boolean all] )
 	
Returns the percentage of the SGroup members that are in cover. Alternatively, specify ANY or ALL as a second parameter to return true/false. 

 
Boolean  SGroup_IsInfiltrated( SGroupID sgroup, Boolean all )
 	
Returns true if ALL or ANY squads in a group are infiltrated 

 
Boolean  SGroup_IsInHoldEntity( SGroupID sgroup, Boolean ALL )
 	
Checks if ANY or ALL squads in an SGroup are garrisoned in an entity (building)  

 
Boolean  SGroup_IsInHoldSquad( SGroupID sgroup, Boolean ALL )
 	
Checks if ANY or ALL squads in an SGroup are garrisoned in a squad (transport vehicle)  

 
Boolean  SGroup_IsMoving( SGroupID sgroup, Boolean all )
 	
Returns true if ANY or ALL squads in an SGroup are moving. 

 
Bool  SGroup_IsOnScreen( PlayerID player, SGroupID group, Bool all[, Float percent] )
 	
Returns true if ANY or ALL (use those keywords) of the squads in the group are present onscreen. You can pass in a percentage of the screen to check, so 0.8 would be a centered rectangle occupying 80% of the screen. 

 
Boolean  SGroup_IsPinned( SGroupID group, Boolean all )
 	
Returns true if ANY or ALL of a group is pinned 

 
Boolean  SGroup_IsReinforcing( SGroupID sgroup, Boolean all )
 	
Returns true if ALL or ANY squads in a group are currently calling for reinforcments. 

Set all to true to check for ALL or set to false to check for ANY

 
Boolean  SGroup_IsRetreating( SGroupID sgroup, Boolean all )
 	
Returns true if ANY or ALL of the squads in an SGroup are currently retreating 

 
Boolean  SGroup_IsSettingDemolitions( SGroupID sgroup, Boolean all )
 	
Returns true if ANY or ALL squads are setting demolitions 

 
Boolean  SGroup_IsSuppressed( SGroupID group, Boolean all )
 	
Returns true is ANY or ALL of a group is suppressed 

 
Boolean  SGroup_IsUnderAttack( SGroupID sgroup, Boolean all, Float time )
 	
Returns true if ALL or ANY squads are under attack within the time. 

 
Bool  SGroup_IsUnderAttackByPlayer( SGroupID group, PlayerID attackerplayer, Float duration )
 	
Check if the squads are attacked by the player 

 
Boolean  SGroup_IsUnderAttackFromDirection( SGroupID sgroup, Boolean all, Integer offset, Float time )
 	
Returns true if ALL or ANY squads are under attack from a direction within the time. see LuaConsts.scar for types of directions. you can pass in a table of directions 

 
Boolean  SGroup_IsUpgrading( SGroupID sgroup, UpgradeBlueprint blueprint, Boolean all )
 	
Returns true if ALL or ANY squads in a group are currently upgrading. You can pass in nil for upgradeid if it doesn't matter what is being upgraded. 

Set all to true to check for ALL or set to false to check for ANY

 
Boolean  SGroup_IsUsingAbility( SGroupID sgroup, Boolean ALL )
 	
Checks if ANY or ALL squads in an SGroup are using an ability 

Does not check WHAT ability a squad is using.

 
Void  SGroup_Kill( SGroupID sgroup )
 	
Kills all squads in an SGroup. This kills them 'naturally', as opposed to SGroup_DestroyAllSquads() which makes them blink out of existance. 

 
void  SGroup_Remove( SGroup* group, Squad* squadron )
 	
Removes an squadron from a group. 

 
Void  SGroup_RemoveGroup( SGroupID group, SGroupID grouptoremove )
 	
Remove from the first SGroup all squads contained in the second SGroup. SGroup2 remains untouched. 

 
Void  SGroup_RemoveUpgrade( SGroupID sgroup, UpgradeBlueprint/Table upgrade )
 	
Removes upgrade(s) from an sgroup 

 
Void  SGroup_ReSpawn( SGroupID groupid )
 	
Respawn all despawned squads in a group. 

 
Void  SGroup_RestoreCombatPlans( SGroupID sgroupID )
 	
Restore all current combat plans for the squads in the sgroup 

 
Void  SGroup_RewardActionPoints( SGroupID sgroup, Float actionpoint )
 	
Give action points to the squad 

 
Void  SGroup_SetAnimatorState( SGroupID sgroupid, String stateMachineName, String stateName )
 	
Set animation state of a state machine for an SGroup. Please only use this for simple animations 

 
Void  SGroup_SetAutoTargetting( SGroupID group, String hardpoint, Bool enable )
 	
Sets whether a weapon to auto-target things or not 

 
Real  SGroup_SetAvgHealth( SGroupID sgroup, Real healthpercent )
 	
Sets the health of each squad in a squad group to a given percent [0.0, 1.0]. 

 
Real  SGroup_SetAvgMorale( SGroup sgroup, Real moralepercent )
 	
Sets the moral of each squad in a squad group to a given percent [0.0, 1.0]. 

 
Void  SGroup_SetCrushable( SGroupID sgroup, Boolean crushable )
 	
Overrides crushable behavior for an sgroup 

 
Void  SGroup_SetInvulnerable( SGroupID sgroup, Boolean/Real enabled[, Float reset_time] )
 	
Enable/Disable invulnerablity for an entire SGroup. Use true and false for simple on/off, or use a number between 0.0 and 1.0 for more precise control on how much damage a squad can take before it takes no more. 

The optional reset_time is used to automatically remove invulnerability after a set time. If invulnerable, both health and critical damage are disabled.

 
Void  SGroup_SetInvulnerableToCritical( SGroupID sgroup, Boolean/Real enabled )
 	
Enable/Disable invulnerablity to criticals for an entire SGroup. 

 
Void  SGroup_SetMoodMode( SGroupID group, Integer mode )
 	
Set soldier mood mode. Mode could be MM_Auto, MM_ForceCalm or MM_ForceTense 

 
Void  SGroup_SetMoveType( SGroupID group, MoveTypeBlueprint movetype )
 	
Set the move type for an SGroup - find the move types in the MOVETYPE table in LuaConsts.scar 

 
Void  SGroup_SetPlayerOwner( SGroupID sgroup, PlayerID owner )
 	
Changes the player owner of spawned and despawned squads in an SGroup. 

 
Void  SGroup_SetRecrewable( SGroupID sgroup, Boolean recrewable )
 	
Sets all squads in as sgroup to be recrewable or not when abandoned 

 
Void  SGroup_SetSelectable( SGroup sgroupid, bool selectable )
 	
Set player selectable state of squads in the sgroup 

 
Void  SGroup_SetSharedProductionQueue( SGroupID egroup, Boolean enable )
 	
Enables shared team production on a building (teammates can build using THEIR resources) 

 
Void  SGroup_SetSuppression( SGroupID groupid, Float suppression )
 	
Set the suppression level for all squads in the sgroup 

 
Void  SGroup_SetTeamWeaponCapturable( SGroupID group, Boolean enable )
 	
Set team weapon in the squads to be capturable or not 

 
Void  SGroup_SetVeterancyDisplayVisibility( SGroupID groupid, bool visible )
 	
Sets the visibility of in-game veterancy art for the squads in given SGroup 

 
Void  SGroup_SetWorldOwned( SGroupID sgroup )
 	
Makes an sgroup neutral 

 
SGroupID  SGroup_Single( SGroupID groupID, squadID squad )
 	
Creates a squad group containing a single squad 

Creates an SGroup containing just one squad, creating the group if it doesn't exist and clearing it if it does. It returns the name of the SGroup.

 
Void  SGroup_SnapFaceEachOther( SGroupID sgroup1, SGroupID sgroup2 )
 	
Makes two SGroups face each other at no time 

 
void  SGroup_SuggestPosture( SGroup* sgroup, unsigned posture, float duration )
 	
Suggests a posture to an SGroup, lasting the passed duration 

Posture of 0 is prone, 1 is kneel/crouch, and 2 is standing. Duration is in seconds, negative means indefinate.

 
Integer  SGroup_TotalMembersCount( SGroupID sgroup, Bool dontCountTeamWeapons )
 	
Returns the total count of all members of all the squads in a given SGroup. 

 
Void  SGroup_WarpToMarker( SGroupID sgroup, MarkerID marker )
 	
Warps all members of an SGroup immediately to a marker 

 
Void  SGroup_WarpToPos( SGroupID sgroup, Position pos )
 	
Warps all members of an SGroup immediately to a new position 

 
Sgroup/Egroup Group containing selection  Util_Grab( Boolean subselect )
 	
Grabs the selected squads/entities and returns them in a group. Only works with -dev. 

Tries to return an SGroup first. If it's empty, it will return an EGroup. (Both types can't be selected at the same time)

 
 

 

Squad
Functions

void  SGroup_FacePosition( SGroup* sgroup, ScarPosition pos )
 	
Works like Squad_FacePosition. All Squads will face the same direction, with the squad the closest to the center determining the direction. 

This function works on spawned squads only.

 
void  SGroup_SnapFacePosition( SGroup* sgroup, ScarPosition pos )
 	
Works like SGroup_FacePosition except with no interpolation. All Squads will face the same direction, with the squad the closest to the center determining the direction. 

This function works on spawned squads only.

 
void  Squad_AddAbility( Squad* squad, ScarAbilityPBG ability )
 	
Allows the squad to use this ability 

 
void  Squad_AddSlotItemToDropOnDeath( Squad* squad, ScarSlotItemPBG pbg, float dropChance, bool exclusive )
 	
Add to the list of slot items to drop when this squad is wiped out 

Squad_AddSlotItemToDropOnDeath( squadid, item, false )

 
bool  Squad_CanCaptureStrategicPoint( Squad* squad, Entity* entity )
 	
Returns true if squad can capture stategic point 

 
bool  Squad_CanCaptureTeamWeapon( Squad* pSquad, Entity* pEntity )
 	
True if the squad can capture the entity sync weapon 

 
Void  Squad_CanCastAbilityOnEGroup( SquadID caster, AbilityBlueprint ability, EGroup target_egroup )
 	
Test whether a squad can be ordered to do this ability on any member of the target EGroup 

 
bool  Squad_CanCastAbilityOnEntity( Squad* castingSquad, ScarAbilityPBG abilityPBG, Entity* targetEntity )
 	
Test whether a squad can be ordered to do this ability on the target squad 

 
bool  Squad_CanCastAbilityOnPosition( Squad* castingSquad, ScarAbilityPBG abilityPBG, ScarPosition targetPos )
 	
Test whether a squad can be ordered to do this ability on the target squad 

 
Void  Squad_CanCastAbilityOnSGroup( SquadID caster, AbilityBlueprint ability, SGroup target_sgroup )
 	
Test whether a squad can be ordered to do this ability on any member of the target SGroup 

 
bool  Squad_CanCastAbilityOnSquad( Squad* castingSquad, ScarAbilityPBG abilityPBG, Squad* targetSquad )
 	
Test whether a squad can be ordered to do this ability on the target squad 

 
void  Squad_CancelProductionQueueItem( Squad* squad, uint32_t index )
 	
Cancels an item in a production queue. Index 0 is the currently producing item. 

 
bool  Squad_CanHold( Squad* squad )
 	
Checks whether a squad can hold any squad 

 
bool  Squad_CanInstantReinforceNow( Squad* squad )
 	
Returns true if the squad is available to be reinforced 

 
bool  Squad_CanLoadSquad( Squad* squad, Squad* loadthis, bool bCheckSquadState, bool bOverload )
 	
Checks whether a squad can load another squad 

 
bool  Squad_CanPickupSlotItem( Squad* pSquad, Entity* pEntity )
 	
True if the squad can pickup the entity slot item 

 
bool  Squad_CanRecrew( Squad* pSquad, Entity* pEntity )
 	
True if the squad can recrew the entity 

 
bool  Squad_CanSeeEntity( Squad* squad, Entity* entity )
 	
Returns true if the distance between a target entity and the source squad is less than it squad's sight distance. There is no LOS or FOW check. 

Try Player_CanSeeEntity() if you care about LOS or FOW.

 
bool  Squad_CanSeeSquad( Squad* squad, Squad* target )
 	
Returns true if the distance between a target squad and the source squad is less than it squad's sight distance. There is no LOS or FOW check. 

Try Player_CanSeeSquad() if you care about LOS or FOW.

 
void  Squad_ClearPostureSuggestion( Squad* squad )
 	
Clears any previous posture suggestions made to a squad 

 
void  Squad_CompleteUpgrade( Squad* pSquad, ScarUpgradePBG upgradePBG )
 	
Instantly adds an upgrade to a given squad 

 
int  Squad_Count( Squad* squad )
 	
Returns the number of units currently in a squad (spawned AND despawned!!) 

 
Squad*  Squad_CreateAndSpawnToward( ScarSquadPBG sbp, Player* player, size_t loadoutCount, ScarPosition pos, ScarPosition toward )
 	
Create a squad, spawn it and assign it to a player.  

This will create a squad of size 'loadoutCount' and of unit type 'unit_base' (from squad blueprint)<BR/> Note: loadoutCount will be clipped to loadoutMin and loadoutMax from the squad blueprint. A loudoutCount of zero means create the whole squad as is.

 
void  Squad_DeSpawn( Squad* squad )
 	
Despawn the entire squad at its current position. 

 
void  Squad_Destroy( Squad* squad )
 	
Remove an squad from the world and destroy it. 

 
void  Squad_EnableProductionQueue( Squad* squad, bool enable )
 	
Sets whether a squad can produce anything (including upgrades) 

 
void  Squad_EnableSurprise( Squad* squad, bool enable )
 	
Enables or disables the surprise feature on thie given squad 

 
Entity*  Squad_EntityAt( Squad* squad, uint32_t index )
 	
ZERO-BASED get of entities out of squads 

 
void  Squad_FacePosition( Squad* squad, ScarPosition pos )
 	
Set the rotation of all troopers in a squad to face the position. 

The center of the squad will face the position and all other troops will use the same rotation as the from center vector.<BR/><BR/> This function works on spawned squads only.

 
void  Squad_FaceSquad( Squad* squad1, Squad* squad2 )
 	
Get 2 squads to face each other. This function works on spawned squads only. 

 
ScarPosition  Squad_FindCover( Squad* squad, ScarPosition pos, float coverSearchRadius )
 	
Tries to find cover within a certain radius of a position. If no cover is found, it returns the position used for the search. 

 
ScarPosition  Squad_FindCoverCompareCurrent( Squad* squad, ScarPosition pos, float coverSearchRadius, float maxPathDistanceFromGoal, bool compareToCurrentCover )
 	
Tries to find cover within a certain radius of a position, traveling a max distance to get there, and possibly comparing against current position's cover. If no cover is found, it returns the position used for the search. 

 
Squad*  Squad_FromWorldID( uint32_t id )
 	
Get a squad from a mission editor ID. 

 
SquadStateID  Squad_GetActiveCommand( Squad* squad )
 	
Returns the active squad command. 

 
const char*  Squad_GetAttackPlan( Squad* squad )
 	
Get name of current Squad AI attack plan 

 
void  Squad_GetAttackTargets( Squad* squad, SGroup* group )
 	
Find the squad member current or forced targets. If found, the targets squads are added to the sgroup. Entity targets like buildings are ignored 

 
ScarSquadPBG  Squad_GetBlueprint( Squad* squad )
 	
Returns the name of the squad blueprint (from the attribute editor) 

 
ScarPosition  Squad_GetDestination( Squad* squad )
 	
Returns the squad's destination, if it's moving. IMPORTANT: you must only call this function if Squad_HasDestination has returned true. 

 
uint32_t  Squad_GetGameID( Squad* squad )
 	
Returns an integer containing the unqiue squad ID for this squad. 

 
ScarPosition  Squad_GetHeading( Squad* squad )
 	
Returns the average heading of the spawned units in the squad. The heading is currently a lua table with three entries (x, y, z) 

 
float  Squad_GetHealth( Squad* squad )
 	
Returns the current health of a squad. 

The current health of the squad is the total health of each entity in that squad.

 
float  Squad_GetHealthMax( Squad* squad )
 	
Returns the max health of the squad. 

The max health of a squad is the max health of each entity in that squad. This means that the max health of a squad may change when entities are added or removed from the squad.<BR/><BR/>

 
float  Squad_GetHealthPercentage( Squad* squad )
 	
Returns how much of an original squad's health is left, accounting for deaths (ex: a squad of 3 riflemen would be at 50% health, since they started with 6 members) Note: This is the same percentage that the UI uses. 

 
Entity*  Squad_GetHoldEntity( Squad* squad )
 	
Get which building (entity) is the squad garrisoned 

Please use Squad_IsInHold() to check first

 
Squad*  Squad_GetHoldSquad( Squad* squad )
 	
Get which vehicle (squad) is the squad garrisoned 

Please use Squad_IsInHold() to check first

 
Bool  Squad_GetInvulnerable( SquadID squad )
 	
Check if the squad is invulnerable or not 

 
int  Squad_GetInvulnerableEntityCount( Squad* squad )
 	
Returns the number of invulnerable member 

 
float  Squad_GetInvulnerableMinCap( Squad* squad )
 	
Returns the highest invulnerable min cap percentage from members of the squad. 

 
void  Squad_GetLastAttacker( Squad* squad, SGroup* group )
 	
Find the last squad attacker on this squad. If found, the squad is added to the sgroup 

 
void  Squad_GetLastAttackers( Squad* squad, SGroup* group, float timeSeconds )
 	
Find the squad attackers on this squad from the last seconds specified. If found, the squads are added to the sgroup. Building attackers are ignored 

 
void  Squad_GetLastEntityAttacker( Squad* pSquad, EGroup* pEGroup )
 	
Find the last entity attacker on this squad. If found, the entity added to egroup 

 
int  Squad_GetMax( Squad* squad )
 	
Returns the max number of units allowed in the squad 

 
size_t  Squad_GetNumSlotItem( Squad* squad, ScarSlotItemPBG pbg )
 	
Get the number of slot items with the same ID that the squad has 

Squad_GetNumSlotItem( squadid, item )

 
Position  Squad_GetOffsetPosition( SquadID squad, Integer offset, Real distance )
 	
Returns a position relative to a squad's current position and orientation. see LuaConsts.scar for explanation of 'offset' parameter. 

 
const char*  Squad_GetPinnedPlan( Squad* squad )
 	
Get name of current Squad AI reaction plan 

 
Player*  Squad_GetPlayerOwner( Squad* squad )
 	
Returns the Player owner of the given squad. Squad MUST NOT be owned by the world. 

 
ScarPosition  Squad_GetPosition( Squad* squad )
 	
Returns the average position of the spawned units in the squad. The position is currently a lua table with three entries (x, y, z) 

 
ScarPosition  Squad_GetPositionDeSpawned( Squad* squad )
 	
Returns the average position of the despawned AND spawned units in the squad. 

 
const PropertyBagGroup*  Squad_GetProductionQueueItem( Squad* squad, size_t index )
 	
Returns the blueprint for a production queue item with index. 

 
int  Squad_GetProductionQueueItemType( Squad* squad, size_t index )
 	
Returns the production type (PITEM_Upgrade, PITEM_Spawn, PITEM_SquadUpgrade, PITEM_SquadReinforce, PITEM_PlayerUpgrade) for a production queue item with index. 

 
size_t  Squad_GetProductionQueueSize( Squad* squad )
 	
Returns the number of items in the squad's production queue. 

It is an error to call this function on a squad that does not have a production queue.<BR/> Use Squad_HasProductionQueue to check that the squad has a queue.

 
const char*  Squad_GetReactionPlan( Squad* squad )
 	
Get name of current Squad AI reaction plan 

 
const char*  Squad_GetRetaliationPlan( Squad* squad )
 	
Get name of current Squad AI retaliation plan 

 
size_t  Squad_GetSlotItemAt( Squad* squad, size_t index )
 	
Returns the ID of the slot item. Use Squad_GetSlotItemCount to determine how many slot items the squad has. The first index is 1 

 
size_t  Squad_GetSlotItemCount( Squad* squad )
 	
Returns how many slot items this squad has 

 
LuaTable  Squad_GetSlotItemsTable( SquadID squadid )
 	
Returns a table of SlotItem ID's that this squad currently owns 

 
bool  Squad_GetSquadsHeld( Squad* squad, SGroup* sgroup )
 	
Adds all squads held by 'squad' to an sgroup 

 
float  Squad_GetSuppression( Squad* squad )
 	
Check current squad suppresion level. Return value from 0 to 1 

 
float  Squad_GetVeterancyExperience( Squad* squad )
 	
Get current squad veterancy experience 

 
size_t  Squad_GetVeterancyRank( Squad* squad )
 	
Get current squad veterancy rank. 

 
void  Squad_GiveSlotItem( Squad* squad, ScarSlotItemPBG pbg )
 	
Gives a slot item to the squad. Can fail due to not enough slots left 

 
Void  Squad_GiveSlotItemsFromTable( SquadID squadid, LuaTable itemTable )
 	
Gives all slot items in a table to the squad. The table should come from Squad_GetSlotItemsTable 

 
bool  Squad_HasActiveCommand( Squad* squad )
 	
Returns true if there's an active command currently for the squad 

 
bool  Squad_HasAnyCritical( Squad* squad )
 	
Return true if any entity in the squad has any critical applied to it 

 
Bool  Squad_HasCritical( SquadID squad, CriticalID critical )
 	
Check if a squad has a critical or not 

 
bool  Squad_HasDestination( Squad* squad )
 	
Returns whether this squad is moving and has a destination 

 
bool  Squad_HasProductionQueue( Squad* squad )
 	
Returns true if a squad has a production queue. 

 
Bool  Squad_HasSlotItem( SquadID squad, SlotItemID slotItem )
 	
Check if a squad has a specific slot item 

 
Boolean  Squad_HasTeamWeapon( SquadID squad )
 	
Returns true if the squad is carrying some kind of team weapon 

 
bool  Squad_HasUpgrade( Squad* squad, ScarUpgradePBG pbg )
 	
Return true if the squad has purchased the specified upgrade. 

 
void  Squad_IncreaseVeterancyExperience( Squad* squad, float experience, bool silent, bool applyModifiers )
 	
Increase current squad veterancy experience 

 
void  Squad_IncreaseVeterancyRank( Squad* squad, int numranks, bool silent )
 	
Increase current squad veterancy rank 

 
void  Squad_InstantSetupTeamWeapon( Squad* squad )
 	
Stops current squads activity and instant setup the team weapon if they have one 

 
bool  Squad_IsAttacking( Squad* squad, float time )
 	
Returns true if any unit in the squad is attacking within the time 

Time is in seconds

 
Boolean  Squad_IsCamouflaged( SquadID squad )
 	
Returns whether ANY entity in the squad is camouflaged 

 
bool  Squad_IsDoingAbility( Squad* squad, ScarAbilityPBG pbg )
 	
True if squad is currently performing the given ability 

 
bool  Squad_IsFemale( Squad* squad )
 	
Returns whether the passed in squad is female 

 
bool  Squad_IsHoldingAny( Squad* squad )
 	
Check if the squad has a hold on anything (use this on vehicles) 

 
Boolean  Squad_IsInCover( SquadID squadId, Boolean all )
 	
Returns true if ALL or ANY troopers in a squad are in cover. 

Set all to true to check if all troopers are in cover or set to false to check if any.

 
bool  Squad_IsInHoldEntity( Squad* squad )
 	
Check if the squad is garrisoned in entity (building) 

 
bool  Squad_IsInHoldSquad( Squad* squad )
 	
Check if the squad is loaded in squad (vehicle 

 
bool  Squad_IsMoving( Squad* squad )
 	
Returns whether any entity in the squad is moving 

 
bool  Squad_IsPinned( Squad* squad )
 	
True if squad is currently pinned 

 
bool  Squad_IsReinforcing( Squad* squad )
 	
Returns true if the squad is currently reinforcing. This function will return false if the squad does not have a reinforce ext. 

 
Boolean  Squad_IsRetreating( SquadID squadid )
 	
Returns true if the squad is currently retreating 

 
bool  Squad_IsSuppressed( Squad* squad )
 	
True if squad is currently suppressed 

 
bool  Squad_IsUnderAttack( Squad* squad, float time )
 	
Returns true if any unit in the squad is under attack within the time 

Time is in seconds

 
bool  Squad_IsUnderAttackByPlayer( Squad* squad, Player* pAttackerOwner, float time )
 	
Returns true if squad is under attack by enemy from a particular player 

Time is in seconds

 
bool  Squad_IsUnderAttackFromDirection( Squad* squad, int offset, float timeSeconds )
 	
Returns true if the squad was under attack from a certain direction (8 offset types, see LuaConsts.scar) 

 
bool  Squad_IsUpgrading( Squad* squad, ScarUpgradePBG upgrade )
 	
Returns true if the squad is currently upgrading something specific. 

 
bool  Squad_IsUpgradingAny( Squad* squad )
 	
Returns true if the squad is currently upgrading anything. 

 
bool  Squad_IsValid( uint32_t id )
 	
Check if a squad with the given ID can be found in the world 

 
void  Squad_Kill( Squad* squad )
 	
Kill whole squad. Sets health to 0, and triggers death effects. 

 
void  Squad_RemoveAbility( Squad* squad, ScarAbilityPBG ability )
 	
Removes an ability that was previously added by Squad_AddAbility. You cannot remove static abilities (from AE: squad_ability_ext) 

 
void  Squad_RemoveUpgrade( Squad* squad, ScarUpgradePBG upgrade )
 	
Removes an upgrade from a squad 

 
void  Squad_RewardActionPoints( Squad* squad, float actionPoint )
 	
Give squad action points 

 
Void  Squad_SetAnimatorState( SquadID squadid, String stateMachineName, String stateName )
 	
Set animation state of a state machine for a squad Please only use this for simple animations 

 
void  Squad_SetAttackPlan( Squad* squad, const char* planName )
 	
Set overriding Squad AI attack plan  

 
void  Squad_SetHealth( Squad* squad, float healthPercent )
 	
Set the health of all units in a squad. Health must be in range [0.0, 1.0] 

 
Void  Squad_SetInvulnerable( SquadID squad, Bool enable, Float reset_time )
 	
Set invulnerability on the squad. Reset time is in seconds. If it it set, the invulnerability will expire after this time. 

 
void  Squad_SetInvulnerableEntityCount( Squad* squad, int invEntityCount, float resetTime )
 	
Make a squad invulnerable to physical damage when number of members drop to or below specified count. 

resetTime is the time in seconds that vulnerability will be restored.; zero time for reset time means the buff will last forever

 
void  Squad_SetInvulnerableMinCap( Squad* squad, float minHealthPercentage, float resetTime )
 	
Make a squad invulnerable to physical damage. 

resetTime is the time in seconds that vulnerability will be restored.; zero time for reset time means the buff will last forever

 
void  Squad_SetInvulnerableToCritical( Squad* squad, bool invulnerable )
 	
set invulnerability to critical effect for all entities in the entire squad. Invulnerable to critical also means that kills a entity will not have effect 

 
void  Squad_SetMoodMode( Squad* squad, SquadCombatBehaviourExt::MoodMode mood )
 	
Set soldier mood mode. 

 
void  Squad_SetMoveType( Squad* squad, ScarMoveTypePBG movetypePBG )
 	
Sets the squad's move type 

 
void  Squad_SetPinnedPlan( Squad* squad, const char* planName )
 	
Set overriding Squad AI pinned plan 

 
void  Squad_SetPlayerOwner( Squad* squad, Player* owner )
 	
Changes the owner of the given squad. 

 
void  Squad_SetPosition( Squad* squad, ScarPosition pos, ScarPosition toward )
 	
Moves the squad to an arbitrary new position 

 
void  Squad_SetReactionPlan( Squad* squad, const char* planName )
 	
Set overriding Squad AI reaction plan 

 
void  Squad_SetRecrewable( Squad* squad, bool capturable )
 	
Set entity inside the squad to be recrewable or not when it becomes abandoned 

 
void  Squad_SetRetaliationPlan( Squad* squad, const char* planName )
 	
Set overriding Squad AI idle retaliation plan 

 
void  Squad_SetSharedProductionQueue( Squad* squad, bool shared )
 	
Enables shared team production on a building (teammates can build using THEIR resources) 

 
void  Squad_SetSuppression( Squad* squad, float percentage )
 	
Set current squad suppresion level. Suppression value value from 0 to 1 

 
void  Squad_SetVeterancyDisplayVisibility( Squad* squad, bool visible )
 	
Turn on/off display of the unit portrait veterancy stars 

 
void  Squad_SetWorldOwned( Squad* squad )
 	
Makes a squad neutral 

 
bool  Squad_Spawn( Squad* squad, ScarPosition pos )
 	
Spawn the entire squad at a given position 

 
bool  Squad_SpawnToward( Squad* squad, ScarPosition pos, ScarPosition toward )
 	
Spawn the entire squad at a given position 

 
Squad*  Squad_Split( Squad* squad, unsigned int num )
 	
Split the squad into 2. The new squad size is specified by the number passed in 

The new squad size is specified by the number passed in.

 
void  Squad_StopAbility( Squad* squad, ScarAbilityPBG ability, bool bEarlyExit )
 	
Abruptly stops an active ability 

 
void  Squad_SuggestPosture( Squad* squad, unsigned posture, float duration )
 	
Suggests a posture to a squad, lasting the passed duration 

Posture of 0 is prone, 1 is kneel/crouch, and 2 is standing. Duration is in seconds, negative means indefinate.

 
Void  Squad_WarpToPos( SquadID squad, Position pos )
 	
Warps a squad immediately to a new position 

 
 

 

Stats
Functions

int  Stats_BuildingsLost( const ModPlayer* player )
 	
Returns how many buildings a player has lost 

 
int  Stats_InfantryLost( const ModPlayer* player )
 	
Returns how many infantry a player has lost 

 
int  Stats_KillsTotal( const ModPlayer* player )
 	
Returns a player's total kills 

 
uint32_t  Stats_PlayerAt( size_t index )
 	
Returns player id at given index 

 
size_t  Stats_PlayerCount( Void  )
 	
Returns how many players in the game 

 
ResourceAmount  Stats_ResGathered( const ModPlayer* player )
 	
Returns how many resources a player has gathered 

 
ResourceAmount  Stats_ResSpent( const ModPlayer* player )
 	
Returns how many resources a player has spent 

 
int  Stats_SoldiersKilled( const ModPlayer* player )
 	
Returns how many soldiers a player has killed 

 
int  Stats_StructuresKilled( const ModPlayer* player )
 	
Returns how many structures a player has killed 

 
Integer  Stats_TeamTally( Integer teamindex, Function statfunction )
 	
Takes a statistic function and totals up the results for all the players on a given team 

 
int  Stats_TotalDuration( Void  )
 	
Returns game time, in seconds 

 
int  Stats_TotalSquadsLost( const ModPlayer* player )
 	
Returns how many squads a playe has lost 

 
int  Stats_UnitSoldierKills( const ModPlayer* player, ScarSquadPBG sbp )
 	
Returns how many soldiers an SBP have killed. ex: how many soldiers did player2's riflemen kill? 

 
int  Stats_UnitStructureKills( const ModPlayer* player, ScarSquadPBG sbp )
 	
Returns how many structures an SBP have killed. ex: how many structures did player2's riflemen kill? 

 
int  Stats_UnitTotalKills( const ModPlayer* player, ScarSquadPBG sbp )
 	
Returns how many entities an SBP have killed. ex: how many entities did player2's riflemen kill? 

 
int  Stats_UnitVehicleKills( const ModPlayer* player, ScarSquadPBG sbp )
 	
Returns how many vehicles an SBP have killed. ex: how many vehicles did player2's riflemen kill? 

 
int  Stats_VehiclesKilled( const ModPlayer* player )
 	
Returns how many vehicles a playe has killed 

 
int  Stats_VehiclesLost( const ModPlayer* player )
 	
Returns how many vehicles a player has lost 

 
 

 

Stinger
Functions

Void  Stinger_AddEvent( PlayerID player, MarkerID marker, EVENT eventname )
 	
Add a stinger to trigger at a specific location 

You must remember to set Stinger_Manager going as a rule with a regular interval

 
Void  Stinger_AddFunction( PlayerID player, MarkerID marker, LuaFunction functionname )
 	
Add a stinger to trigger at a specific location 

You must remember to set Stinger_Manager going as a rule with a regular interval

 
Void  Stinger_Remove( PlayerID player, MarkerID marker )
 	
Remove all stingers triggered from a specific location 

 
 

 

Team
Functions

Void  Team_AddResource( TeamID team, Integer resourceType, Real value )
 	
Add resource to each member of a team, as opposed to just setting it. Possible resource types are RT_Manpower, RT_Munition, RT_Fuel, RT_Action  

 
SGroupID  Team_AddSquadsToSGroup( TeamID team, String squadgroupName )
 	
For the given team, get all of the squads gathered into a squadgroup of your naming.  

This will add all squads for the entire team to one group. To do so for each player, iterate the team table

 
Boolean  Team_AreSquadsNearMarker( TeamID team, MarkerID marker )
 	
Returns true if ANY of a teams squads are in proximity of a marker 

 
Boolean  Team_CanSee( TeamID teamid, EGroupID/SGroupID/EntityID/SquadId/PositionID/MarkerID item, Boolean all )
 	
Returns true if a team can see ALL or ANY items 

 
Void  Team_ClearArea( TeamID team, MarkerID marker, Bool invulnerable )
 	
Any of the team's units in the marker area move out of the area, and can be made invulnerable for a bit whilst they do it 

You can replace the marker with a position and a range - i.e. Team_ClearArea(team, pos, range, invulnerable)

 
playerID, playerID, playerID, playerID  Team_DefineAllies( Void  )
 	
Returns 4 playerIDs (player1, player2, player3, player4) for Humans/Allies 

 
playerID, playerID, playerID, playerID  Team_DefineEnemies( Void  )
 	
Returns 4 playerIDs (player5, player6, player7, player8) for Enemy Players 

 
TeamID  Team_FindByRace( String race[, String race2 )
 	
Returns the TeamID for a given race. See LuaConsts for constants to use. 

You can pass in multiple races.

 
Boolean  Team_ForEachAllOrAny( TeamID team, Boolean all, LuaFunction function )
 	
Tests a condition on teams. Calls your function for each player. Parameters of your function: (TeamID, player index, PlayerID). Your function must return true or false to indicate whether the player meets the condition. 

 
Void  Team_GetAll( TeamID team[, SGroupID sgroup, EGroupID egroup] )
 	
Creates/Clears groups that contain all of a team's units and buildings. Defaults - sg_allsquads and eg_allentities 

Fills an SGroup with all of the given team's squads, and an EGroup with all the team's entities. If you don't provide and groups, then it defaults to using sg_allsquads and eg_allentities.

 
Void  Team_GetAllEntitiesNearMarker( TeamID team, EGroupID egroup, MarkerID/Pos/SectorID position[, Real range] )
 	
Gather together all of a teams's entities that are in proximity to a marker, a position, or within a territory sector into an EGroup. The EGroup is cleared beforehand.  

You can override a marker's normal proximity by specifying a range.

 
Void  Team_GetAllSquadsNearMarker( TeamID team, SGroupID sgroup, MarkerID/Pos/SectorID position[, Real range] )
 	
Gather together all of a teams's squads that are in proximity to a marker, a position, or within a territory sector into an SGroup. The SGroup is cleared beforehand.  

You can override a marker's normal proximity by specifying a range.

 
EntityID/Table  Team_GetBuildingID( PlayerID player, BlueprintTable entitytypes[, ANY bool] )
 	
Returns the entityID of the first team owned building listed in the table. 

This only looks at completed buildings

 
Integer  Team_GetBuildingsCount( TeamID team )
 	
Returns the total number of buildings owned by this team. 

 
Integer  Team_GetBuildingsCountExcept( TeamID team, BlueprintTable exceptions )
 	
Returns the total number of buildings owned by this team (with exclusions). 

 
Integer  Team_GetBuildingsCountOnly( TeamID team, BlueprintTable ebplist )
 	
Returns the number of buildings owned by this team (inclusive). 

 
TeamID  Team_GetEnemyTeam( TeamID team )
 	
Returns a team's enemy 

 
EGroup  Team_GetEntitiesFromType( TeamID team, String unitType )
 	
Returns an EGroup containing all of the teams entities of a specific unit_type (as defined by the type_ext on the entity) 

This function returns a new EGroup to allow tracking of different types.

 
boolean  Team_HasBuilding( TeamID team, BlueprintTable entitytypes[, ANY bool] )
 	
Returns true if this team owns any buildings listed in the table. 

Use ALL to check if all players on the team have this building

 
boolean  Team_HasBuildingsExcept( TeamID team, BlueprintTable exceptions[, ANY bool] )
 	
Returns true if this team owns any buildings. (with exclusions). 

Use ALL to check if all players on the team have buildings EXCEPT this one

 
boolean  Team_HasBuildingUnderConstruction( TeamID team, BlueprintTable entitytypes[, ANY bool] )
 	
Returns true if this team owns any buildings listed in the table currently under construction. 

Use ALL to check if all players on the team have this building under construction

 
Boolean  Team_IsAlive( Void  )
 	
Returns whether a team is still alive or not (all member players must be 'alive') 

 
Boolean  Team_OwnsEGroup( TeamID team, EGroupID egroup[, Boolean any] )
 	
Returns true if a given team owns ALL or ANY items in a group 

 
Boolean  Team_OwnsEntity( TeamID team, EntityID entity )
 	
Returns true if a given team owns an entity 

 
Boolean  Team_OwnsSGroup( TeamID team, SGroupID sgroup[, Boolean all] )
 	
Returns true if a given team owns ALL or ANY items in a group 

 
Boolean  Team_OwnsSquad( TeamID team, SquadID squad )
 	
Returns true if a given team owns a squad 

 
Void  Team_RestrictAddOnList( TeamID team, Table addonlist )
 	
Restrict a list of addons. 

list should contain an array of strings to restrict.

 
Void  Team_RestrictBuildingList( TeamID team, Table blueprintlist )
 	
Restrict a list of buildings. 

list should contain an array of strings to restrict.

 
Void  Team_RestrictResearchList( TeamID team, StringTable list )
 	
Restrict a list of research items. 

list should contain an array of strings to restrict.

 
Void  Team_SetAbilityAvailability( TeamID team, AbilityBlueprint/Table bp, Integer availability )
 	
Sets the availability of an ability. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT 

 
Void  Team_SetCommandAvailability( TeamID team, Integer/Table command, Integer availability )
 	
Sets the availability of entity, squad and player commands. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT 

 
Void  Team_SetConstructionMenuAvailability( TeamID team, String/Table menuname, Integer availability )
 	
Sets the availability of a construction menu. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT 

 
Void  Team_SetEntityProductionAvailability( TeamID team, EntityBlueprint/Table bp, Integer availability )
 	
Sets the availability of an entity production item. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT 

 
Void  Team_SetMaxCapPopulation( TeamID team, Integer captype, Integer newcap )
 	
Sets the current personnel or vehicle max-cap for each player on a team. The captype is either CT_Personnel or CT_Vehicle (you can't adjust Medic caps just yet). 

you will have to call Team_SetMaxPopulation to adjust the current max population to do this.

 
Void  Team_SetMaxPopulation( TeamID team, Integer captype, Integer newcap )
 	
Sets the current personnel or vehicle cap for each player on a team. The captype is either CT_Personnel or CT_Vehicle (you can't adjust Medic caps just yet). 

Note that any modifiers that adjust the current cap will be applied on top of this. Also note, the current cap cannot go higher than the max cap.

 
Void  Team_SetSquadProductionAvailability( TeamID team, SquadBlueprint/Table bp, Integer availability )
 	
Sets the availability of a squad production item. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT 

 
void  Team_SetTechTreeByYear( TeamID team, Integer year )
 	
Sets up the tech tree for a whole team based off the year 

 
Void  Team_SetUpgradeAvailability( TeamID team, UpgradeBlueprint/Table bp, Integer availability )
 	
Sets the availability of an upgrade. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT 

 
Void  Team_SetUpgradeCost( TeamID team, UpgradeID upgrade, Real manpower, Real fuel, Real munition, Real action, Real command )
 	
Sets the cost of an upgrade. 

 
 

 

TheatreOfWar
Functions

Void  ToW_DefenseCreateWave( Integer waveNumber )
 	
Starts an enemy wave in a ToW mission set up with proper data. See TheatreOfWar.scar for example data. 

You need to add import("TheatreOfWar.scar") to your mission script to use this - it isn't imported by default

 
Void  ToW_SetStandardResources( PlayerID player[, Table overrideData] )
 	
Set a player to have standard starting resources, or use optional override data. 

You need to add import("TheatreOfWar.scar") to your mission script to use this - it isn't imported by default

 
Void  ToW_SetUpBattleObjectives( Void  )
 	
Sets up a default mission objective for Victory Point battles. 

You need to add import("TheatreOfWar.scar") to your mission script to use this - it isn't imported by default

 
Void  ToW_SetUpTechTreeByYear( PlayerID player, Int year )
 	
Restricts a given player's tech tree to just the units that were available in a specific year. 

You need to add import("TheatreOfWar.scar") to your mission script to use this - it isn't imported by default

 
 

 

Timer
Functions

Void  Timer_Add( Integer timerID, Real period )
 	
Add the amount of time to the specified timer 

 
Void  Timer_Advance( Integer timerID, Real period )
 	
Advances the timer by the specified amount of time 

 
Void  Timer_Display( Integer timerID )
 	
Display (in the console) the amount of time remaining in the specified timer. 

 
Void  Timer_DisplayOnScreen( Integer timerID )
 	
Displays a timer on the screen - You need to call this regularly (i.e. every second) to update the onscreen display. THIS IS A TEMPORARY FUNCTION - WELL GET PROPER UI SUPPORT LATER ON 

 
Void  Timer_End( Integer timerID )
 	
Stop the specified timer. 

 
Boolean  Timer_Exists( Integer timerID )
 	
Returns whether the timer with this ID exists 

 
Real  Timer_GetElapsed( Integer timerID )
 	
Returns how much time has elapsed since this timer has been started 

 
Void  Timer_GetMinutesAndSeconds( Luafunction getTimeFunction, Integer TimerID )
 	
Returns TWO values: minutes and seconds. Provide it a function like Timer_GetRemaining or Timer_GetElapsed 

 
Real  Timer_GetRemaining( Integer timerID )
 	
Get the remaining time for the specified timer. 

 
Boolean  Timer_IsPaused( Integer timerID )
 	
Check if the timer is paused. 

 
Void  Timer_Pause( Integer timerID )
 	
Pause the specified timer. 

 
Void  Timer_Resume( Integer timerID )
 	
Resume the specified timer. 

 
Void  Timer_Start( Integer timerID, Real period )
 	
Start a timer with the specified id, taking the required period ( in seconds ) 

 
 

 

UI
Functions

event cue ID  EventCue_Create( CueStyleID style, LocString title, LocString description, Marker/Pos/EGroup/SGroup cameratarget[, LocString hintpointtext, LuaFunction function, Float lifetime, Boolean dismissOnClick] )
 	
Creates an Event Cue message which automatically sends the camera to a specified point when clicked on.  

Can optionally create a 5-second hintpoint at the location when clicked on, and/or call a specified function for you, too. Both of these only activate the first time you click on the event cue to avoid stacking.

 
Void  FOW_Enable( Boolean enable )
 	
Enables or disables the FOW, including out of bound areas and all entities on the map 

 
Void  Game_SubTextFade( LocString location, LocString time, LocString detail, Real in, Real lifetime, Real out )
 	
Fade in and out two or three lines of subtext. 

This function has to support two lines, for backwards compatibility. The 'detail' line is therefore optional.

 
Void  HintMouseover_Add( LocString hintText, Marker/Position/Egroup/Sgroup hintTarget, Real targetRadius, Boolean looping )
 	
Adds a Hint Point that will only appear on Mouseover of the target. 

 
Void  HintMouseover_Remove( LocString hintText, Marker/Egroup/Sgroup hintTarget )
 	
Removes a Mouseover Hint Point from the managing function. 

 
HintPointID  HintPoint_Add( StackVar where, Boolean bVisible, LocString hintText[, number height, HintPointActionType actionType, String iconName] )
 	
Creates a hintpoint attached to a Marker, EGroup, SGroup or position 

If range is set to 0, then the hintpoint is rangeless, see the design document for rangeless features. The following types of hintpoint actions are available. HPAT_Objective HPAT_Hint HPAT_Critical HPAT_Movement HPAT_Attack HPAT_FormationSetup HPAT_RallyPoint HPAT_DeepSnow HPAT_CoverGreen HPAT_CoverYellow HPAT_CoverRed HPAT_Detonation HPAT_Vaulting

 
Void  HintPoint_Remove( Integer HintPointID )
 	
Removes a hintpoint. 

 
Void  HintPoint_SetDisplayOffset( Integer hintpointID, Real x, Real y[, Real z] )
 	
Sets a hintpoint's display offset, which is 3D for world hintpoints and 2D for taskbar binding hintpoints (ignore z) 

 
Void  HintPoint_SetVisible( Integer HintPointID, Boolean bVisible )
 	
Sets a hintpoint's visibility. Currently, FOW is not accounted for. 

 
Boolean  Misc_IsEGroupSelected( EGroupID egroup, Boolean all )
 	
Returns true if ANY or ALL of the EGroup is selected 

 
Boolean  Misc_IsSGroupSelected( SGroupID sgroup, Boolean all )
 	
Returns true if ANY or ALL of the SGroup is selected 

 
Void  ThreatArrow_Add( Integer GroupID, entity/squad/egroup/sgroup/position/marker Threat[, String icon] )
 	
Adds a threat to an existing group 

 
Integer (ID)  ThreatArrow_CreateGroup( variable!argument!list: threats )
 	
Creates a group of threats that are represented by a single arrow. Threats can be entities, squads, egroups, sgroups, positions or markers 

 
Void  ThreatArrow_DestroyAllGroups( Void  )
 	
Destroy all threat groups 

 
Void  ThreatArrow_DestroyGroup( Integer GroupID )
 	
Destroy a threat group 

 
Void  ThreatArrow_Remove( Integer GroupID, entity/squad/egroup/sgroup/position/marker Threat )
 	
Removes a threat from an existing group 

 
Void  UI_AddHintAndFlashAbility( PlayerID playerid, AbilityID abilityID, LocString text, Integer length, [Table/Blueprint blueprint_filter] )
 	
Creates and flashes an ability button on the taskbar if the unit is selected 

Length parameter determines how long to flash the item, and the blueprint filter is used if certain squad types need to be selected before flashing the button.

 
ID  UI_CreateEventCue( String iconPath, String soundPath, LocString title, LocString description[, Float lifetime, Boolean dismissOnClick] )
 	
Creates an event cue without a callback (you won't know when it's clicked) 

 
blipID  UI_CreateMinimapBlip( StackVar where, Real lifetime, Integer blipType )
 	
Creates a blip on the minimap; return the ID of the blip. 

'where' can be an entity, marker, position, egroup, sgroup, or squad. The following blipTypes are available: BT_AttackHere BT_DefendHere BT_CaptureHere BT_General BT_Combat BT_Reveal BT_ObjectivePrimary BT_ObjectiveSecondary

 
Void  UI_CreateSGroupKickerMessage( PlayerID player, SGroup sgroup, LocString message )
 	
Create a custom kicker message on the squad and display to the player. 

 
Void  UI_DeleteMinimapBlip( Integer blipID )
 	
Removes a blip already created on the minimap 

 
Void  UI_HighlightSGroup( SGroupID sgroup, Real duration )
 	
Highlights an SGroup in the UI for the given duration 

 
void  UI_SetAllowLoadAndSave( bool allowLoadAndSave )
 	
Enables or disable load and save features at the pause menu 

 
Void  UI_SetSGroupSpecialLevel( SGroup sgroup, Int level )
 	
Sets a level decorator that's defined in all of the squads squad_ui_ext in the target SGroup 

if level value is -1 it will hide the special decorator, if no level is defined -1 is default

 
void  WinWarning_PublishLoseReminder( ModPlayer* player, long warningLevel )
 	
Triggers a UI event cue and an audio cue that the player is about to lose the game. 

The lower the warningLevel, the closer the player is to losing and the more intense the warning is

 
void  WinWarning_SetMaxTickers( int team1MaxTickers, int team2MaxTickers )
 	
Sets the max victory point scores for the game 

 
void  WinWarning_SetTickers( int team1Tickers, int team2Tickers )
 	
Sets the victory point scores for the game 

 
uint32_t  WinWarning_ShowLoseWarning( LocString text, float fadeIn, float duration, float fadeOut )
 	
Call UI_TitleDestroy to remove.

 
 

 

Util
Functions

Table  Clone( Table data )
 	
Clones a table (recursively) allowing for unadulterated use of the data 

 
Boolean  Event_IsAnyRunning( [Integer priority_threshold] )
 	
Returns true if any event is currently running [at or below (more important than) the priority threshold. If not specified, ignores threshold.] 

 
Void  Game_EndSP( Boolean win[, Boolean nis, Boolean sandmap] )
 	
Ends the single player game (win/lose). 

 
Void  Game_FadeToBlack( Bool direction, Real length )
 	
Fades the screen to black - FADE_OUT to fade to black, FADE_IN to fade back in 

 
nil  Import_Once( String Path )
 	
Loads a scar file if it hasn't been loaded yet 

 
LocString  Loc_FormatText( Integer FormatID[, argc parameters] )
 	
Returns a formatted localized string. 

Use this function to format localized text. ie %1PLAYERNAME% is going to win. It accepts up to 4 additional LocStrings as parameters.

 
Integer  Sound_PlayOnSquad( String soundpathname, SGroupID/Squad sgroupid )
 	
Play sound on the first entity of the squad in sgroup 

 
EGroup  Team_GetEntityConcentration( TeamID team[, Boolean popcapOnly, Table includeBlueprints, Table excludeBlueprints, Boolean bLeastConcentrated, MarkerID/Table onlyInThisMarker] )
 	
Finds the greatest (or least) concentration of entities owned by a team. 

This function is slow, so don't call it very often

 
SGroup  Team_GetSquadConcentration( TeamID team[, Boolean popcapOnly, Table includeBlueprints, Table excludeBlueprints, Boolean bLeastConcentrated, MarkerID/Table onlyInThisMarker] )
 	
Finds the greatest (or least) concentration of squads owned by a team. 

This function is slow, so don't call it very often

 
SGroupID  Util_AddMouseoverSquadToSGroup( [Boolean clearGroup] )
 	
If there's a squad under the mouse cursor, this adds it to a unique SGroup. Return value is the SGroup it was added to, or nil if there was no squad under the mouse cursor. Pass in true for 'clearGroup' to clear the sgroup before adding the squad. 

 
ModID  Util_ApplyModifier( SGroupID/EGroupID/Player groupid, String modifier, Real scalefactor, Real mathtype[, Real applytype, Bool exclusive, String targetname] )
 	
Applies any modifier to the target SGroup, EGroup, or Player 

Valid applytypes are MAT_...(Entity, Squad etc.), if left default assumption is default type for the target Cases you want to define applytype: Weapon Modifiers, Enable Modifiers, or a player modifier for all entity or squad types Valid mathtypes are MUT...(Addition, Multiplication, etc.) Exclusive modifiers will replace all pre-existing modifiers of that modifier type on the target

 
Void  Util_AutoAmbient( Table intelEventTable )
 	
Auto-generate an Ambient Event. These are Low priority, and will hopefully interrupt nothing. 

Takes a table of Actors and LOC numbers

 
Void  Util_AutoIntel( Table intelEventTable )
 	
Auto-generate an Intel Event. These are medium priority, and will interrupt a Stinger, but not an NIS. 

Takes a table of parameters defining speaker(s) and line(s)

 
Void  Util_AutoNISlet( Integer nisletType, Table intelEventTable, [boolean bFOWvisible] )
 	
Auto-generate an NISlet Event, a simple NIS meant to convey mission location. These are high priority, and will interrupt a Stinger and Intel Events. 

Takes an NISLET type and a table of parameters defining speaker(s) and line(s) NISLET_BLACK2GAME = 1 -- starts in black and fades up, ends in gamplay NISLET_GAME2GAME = 2 -- transitions from game play to letterbox and backto gameplay NISLET_GAME2BLACK = 3 -- starts in gameplay and ends in black NISLET_GAME2LETTER = 4 -- starts in gameplay and ends in letterbox mode (for transition to sitrep) NISLET_TIME = 1 -- use seconds to wait on camera movements NISLET_VO = 2 -- use voice to wait on camera movements t_eventes.nislet_start = { {camPos = pos1, waitType = NISLET_TIME, waitValue = 5}, {camPos = pos2, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 000000}}, }

 
void  Util_Autosave( LocString checkpoint[, Float delay, Boolean noFade] )
 	
Automatically save the game for the player. The savegame name is built using the abbreviated mission name + checkpoint.  

 
Void  Util_ClearWrecksFromMarker( MarkerID/Pos/SectorID position[, Real range, Table wrecksList] )
 	
Clears vehicle wrecks from a given area. 

Area can be a marker (with or without a range override), a position and range combo, or a territory sector ID. Uses EBP.WRECKED_VEHICLES unless wrecksList is defined.

 
Void  Util_DespawnAll( Boolean despawn, Boolean!allPlayers![or!Int playerNum], Boolean egroups )
 	
ReSpawns or DeSpawns sgroups (and egroups) for all players or the indicated player. 

examples: Util_DespawnAll(true, true, false) or Util_DespawnAll(true, 1, false) or Util_DespawnAll(false, true, false)

 
Variable  Util_DifVar( Table difficultyVariables[, Integer difficulty] )
 	
Takes in a table and chooses the right variable for the difficulty setting. 1-4 elements. Acquires current difficulty by default. 

 
Boolean  Util_ElementCanSee( PlayerID/TeamID playerID/teamID, SGroupID/EGroupID/EntityID/SquadID/MarkerID/Position element[ )
 	
Returns true if a Player/Team can see any or all of an SGroup/Squad/EGroup/Entity/Position/Marker 

 
Boolean  Util_EntityLimit( [Integer entityLimit] )
 	
Checks the entity count for the world and returns true or false depending on the result. A specific value can be passed in to override the default amount. 

 
EntityID  Util_FallBackToGarrisonBuilding( SGroupID sgroupid, Int radius )
 	
Try to garrison a loadable building within radius that is closer to the first squad of the sgroup than enemy 

The squad suppression would be resetted before fallling back so that they would not succumb to pinned state

 
Position  Util_FindHiddenSpawn( Position origin, Position destination )
 	
Finds a hidden position within the FOW between two given points 

If no position is found, returns origin

 
Void  Util_ForceRetreatAll( SGroup sgroup, Marker marker, Bool/AIEncounter aiEncounterDisable )
 	
Forces all squads given to retreat, regardless of whether they are on team weapons or not. Disables aiEncounters input (true disables all encounters). 

 
EntityID  Util_GarrisonNearbyBuilding( SGroupID sgroup, Position pos, Real radius[, Boolean occupied, SGroup/Table filter] )
 	
Finds a nearby building to garrison. can ignore occupied [friendly] buildings. return ID of entity it found, or nil if not found 

Can also filter out groups not to occupy

 
SquadID  Util_GarrisonNearbyVehicle( SGroupID sgroup, Position pos, Real radius[, Boolean occupied, SGroup/Table filter] )
 	
Finds a nearby vehicle to garrison. can ignore occupied [friendly] vehicles. return ID of vehicle it found, or nil if not found, 

Can also filter out groups not to occupy

 
MarkerID  Util_GetClosestMarker( Variable var, Table markers )
 	
Returns the closest MarkerID to the entity/marker/pos/egroup/sgroup/squad from the table of markers provided 

 
Void  Util_GetEntitiesByBP( EGroupID sourcegroup, EGroupID destgroup, EntityBlueprint ebp )
 	
Find all the entities with a given blueprint in sourcegroup and add them to destgroup. 

See also: EGroup_Filter()

 
Percentage health [0,1]  Util_GetHealth( Squad/Entity/Sgroup/Egroup var )
 	
Determines the health percentage of a given object 

Returns average health if the object is a group

 
Void  Util_GetMouseoverSGroup( Void  )
 	
Returns a unique SGroup used to hold mouseover squads obtained from Util_AddMouseoverSquadToSGroup 

 
Position  Util_GetPosition( Variable var )
 	
Returns a position from entity/marker/pos/egroup/sgroup/squad 

 
Position  Util_GetPositionAwayFromPlayer( MarkerID/Pos/EGroupID/SGroupID pos, PlayerID player, [Integer searchRadius, Integer distance] )
 	
Returns a random position within an area that is not near a player 

searchRadius is the area to look for the location in. Distance is how far from the player's units the position must be.

 
Position  Util_GetPositionFromAtoB( MarkerID/Pos a, MarkerID/Pos b, Real distance )
 	
Returns a position that is distance metres from point A, headed in the direction of point B. 

You can also pass in a percentage (0.0 to 1.0) instead of a distance in metres.

 
Pos  Util_GetRandomPosition( MarkerID/ScarPos [, Real range] )
 	
Returns a random position either within the marker's proximity or with a pos and range provided. Range is ignored for rectangular markers 

 
Void  Util_GetSquadsByBP( SGroupID sourcegroup, SGroupID destgroup, SquadBlueprint sbp )
 	
Find all the squads with a given blueprint in sourcegroup and add them to destgroup. 

See also: SGroup_Filter()

 
Number  Util_GetTrailingNumber( String val )
 	
Returns trailing numbers from a string, if it exists, nil otherwise. E.G. "marker23" would return 23. 

 
Boolean  Util_HasPosition( Variable var )
 	
Returns true if given entity/marker/pos/egroup/sgroup/squad has a position; if false, Util_GetPosition will fail. 

 
Void  Util_HidePlayerForNIS( PlayerID player, Bool hide )
 	
Hides all of a player's squads and/or buildings 

Doesn't hide buildings a player is in, or any base structures. Only items like sandbags, tanktraps, mg nests, etc. Put multiple playerIDs in a table to hide many players together, or use ALL for the playerID to apply to all players at once.

 
bool  Util_IsSequenceSkipped( Void  )
 	
Returns whether the currently running sequence has been skipped 

 
Void  Util_Kill( Player/Squad/Entity/Sgroup/Egroup var )
 	
Kills a given object 

 
Void  Util_LogSyncWpn( SGroupID syncweapon[, Boolean kill] )
 	
Tracks a syncweapon ID and destroys it (by default) or makes it uncapturable (if kill is set to false) 

 
void  Util_MarkerFX( String markername, String eventfile )
 	
Play an events file at a given markers location 

 
Void  Util_MissionTitle( LocString title[, Int time_fade_in, Int lifetime, Int time_fade_out] )
 	
Play the mission title fade. 

 
Void  Util_MuteAmbientSound( Boolean enable, [Real fade] )
 	
Enabling this function will mute the ambient sound (NOT all sound). 

 
void  Util_NewHUDFeatureEvent( HUDFeatureType newHUDFeature, LocString featureText, String featureIcon, Real duration )
 	
Calls UI_NewHUDFeature() as an IntelEvent. Will get queued as any other event. See UI_NewHUDFeature() for parameter details. 

 
Void  Util_PlayMovie( String name[, Integer fadeOut, Integer fadeIn, LuaFunction onComplete, Integer delay, Boolean onCompleteAfterMovie] )
 	
Play a movie. 

If onCompleteAfterMovie is true, the onComplete function will play as soon as the movie is over, instead of after the fade-in

 
Void  Util_PlayMusic( String name, Real fade, Real delay )
 	
Plays music from the Data:Sound folder, and stores the music track so it can be resumed after a save/load 

 
Void  Util_PrintObject( Object obj[, Int max_depth, String data_type, Function print_func] )
 	
Prints out the entire contents of an Object 

Objects can be anything (Player, SGroup, Int, Table, String, etc.), but this is most useful for Tables

 
Void  Util_ReinforceEvent( SGroupID sgroupName[, LocID custumTitle, LocID customDescript] )
 	
Creates an Event Cue for an SGroup and repeats it until the SGroup is killed or selected. 

Additionally, a map ping and custome loc strings for the Title and Description can be used.

 
Void  Util_ReloadScript( Void  )
 	
Reloads the running scar script. Current running rules would also be updated to the redefined functioin. 

 
Void  Util_RestoreMusic( )
 	
Resumes playing the music track that was last triggered i.e. after a save/load 

 
Void  Util_SetPlayerCanSkipSequence( LuaFunction event, LuaFunction skippedCallback, bool noFadeIn[, int fadeInTime] )
 	
Sets it so that a player can skip a scripted sequence. When the skip key is pressed, calls back the given function as a post-sequence setup. noFadeIn stops the system from fading back into gameplay when finished. Call Util_SetPlayerUnableToSkipSequence() when the sequence is finished to disable 

 
Void  Util_SetPlayerUnableToSkipSequence( LuaFunction event, LuaFunction skippedCallback, bool noFadeIn )
 	
Disables Util_SetPlayerCanSkipSequence 

 
Table  Util_SortPositionsByClosest( SGroupID/EGroupID/EntityID/SquadID/MarkerID/Position origin, Table positions[ )
 	
Returns a table of positions sorted from closest to furthest (or furthes to closest if reverse is true) from the origin 

 
Void  Util_StartAmbient( LuaFunction func )
 	
Play a Speech Stinger. These are the lowest priority, and will be bumped by Intel Events or NIS's. 

This function should used instead of Event_Start because it handles priorities.

 
Void  Util_StartIntel( LuaFunction func )
 	
Play an Intel Event. These are medium priority, and will interrupt a Stinger, but not an NIS. 

This function should used instead of Event_Start because it handles priorities.

 
Void  Util_StartNislet( LuaFunction event, LuaFunction skippedCallback, bool noFadeIn, int fadeInTime )
 	
Play Nislet Event. Starts a Nislet event, and calls back a function for post-nislet setup if the Nislet is skipped. noFadeIn stops the system from fading back into gameplay when the player skips 

 
Void  Util_StartQuickIntel( String actor, LocString speech )
 	
Play a quick, one-line Intel event. These are medium priority, and will interrupt a Stinger, but not an NIS. 

Use this when playing a single line. For multi-line events, use Util_StartIntel

 
Boolean  Util_TableContains( Table targetTable, Object obj )
 	
Checks the first layer of a table and looks for a specified Object, returns true if found. 

Objects can be anything (Player, SGroup, Int, Table, String, etc.)

 
void  Util_ToggleAllowIntelEvents( Void  )
 	
Debug function used to toggle whether or not IntelEvents are played. Only works with -dev parameter 

 
Void  Util_TriggerEvent( PlayerID playerid, Marker/EGroup/SGroup/ScarPos position, Int range, LuaFunction func, Boolean non_combat, Boolean onscreen_only, Int onscreen_duration )
 	
Library function to trigger NIS event under a certain sets of conditions. NOTE: if checking against a marker DO NOT specify a range. The range of the marker set in the WorldBuilder will be used. 

onscreen_only set to TRUE means the squad must be onscreen if the event is to be triggered.

 
Lua Table  Util_UnitCounts( Boolean!world!OR!playerID player )
 	
Returns a table containing either the total or a specific player's squad count, entity count, and vehicle count. 

table can be accessed as scene below Get Player Example:<BR/> local t = Util_UnitCounts(player1)<BR/> print(t.squad)<BR/> print(t.entity)<BR/> print(t.vehicle)<BR/> Get World Example:<BR/> local t = Util_UnitCounts(true)<BR/> print(t.squad)<BR/> print(t.entity)<BR/> print(t.vehicle)<BR/> Alternate Format:<BR/> print(Util_UnitCounts(true).squad)<BR/>

 
Void  World_KillAllNeutralEntitesNearMarker( MarkerID marker )
 	
Kills ALL world entities near a marker 

 
 

 

Various
Functions

void  Anim_PlayEntityAnim( Entity* entity, const char* animname )
 	
Plays an animation from an entity. 

This function can be called through a CTRL object in NISlets to wait on the animation.

 
Void  bug( ErrorMessage errormessage )
 	
E-mails a warning out with logfiles at the end of the game. 

Example: bug( "This shouldn't happen, fix "..problem.here)

 
void  Camera_AutoRotate( ScarPosition target, float distance, float declination, float speed )
 	
Procedurally rotates the camera around a target. Camera input will be disabled. distance is in meters, declination is in degrees, speed is in degrees/sec. 

 
void  Camera_ClampToMarker( ScarMarker marker )
 	
Clamps the camera's target position to a marker. 

 
void  Camera_FocusOnPosition( ScarPosition position, bool pan )
 	
Focus the camera on the specified position. If pan is true, smoothly pan the camera to the target. 

 
void  Camera_FollowEntity( Entity* entity )
 	
Make the camera follow the specified entity. 

 
void  Camera_FollowSelection( Void  )
 	
Make the camera follow the current full selection. 

 
void  Camera_FollowSquad( Squad* squad )
 	
Make the camera follow the specified squad. 

 
ScarPosition  Camera_GetCurrentTargetPos( Void  )
 	
Get the current target position for the camera. (Where the the camera currently is.) 

 
float  Camera_GetDeclination( Void  )
 	
Get the current camera declination (tilt). 

 
float  Camera_GetOrbit( Void  )
 	
Get the current camera orbit (rotation). 

 
ScarPosition  Camera_GetTargetPos( Void  )
 	
Get the desired target position for the camera. (Where the camera is trying to get to.) 

 
float  Camera_GetTuningValue( CameraOperator::TuningValue tuningValue )
 	
Get camera tuning value. 

 
float  Camera_GetZoomDist( Void  )
 	
Get the current zoom distance for the camera. 

 
bool  Camera_IsInputEnabled( Void  )
 	
Returns the enabled/disabled state of the camera input. (not strict) 

 
void  Camera_Reload( Void  )
 	
Reload all camera tuning values. 

 
void  Camera_ResetFocus( Void  )
 	
Make the camera stop following anything. 

 
void  Camera_ResetToDefault( Void  )
 	
Reset camera position to default home position 

 
void  Camera_SetDeclination( float declination )
 	
Set the current camera declination (tilt). 

 
void  Camera_SetInputEnabled( bool enabled )
 	
Enables/disables camera input. 

 
void  Camera_SetOrbit( float orbit )
 	
Set the current camera orbit (rotation). 

 
void  Camera_SetSlideTargetRate( float rate )
 	
Changes the speed of the camera blends to be newRate until the user (or some other camera call) is made. Can call this with 0 to reset to default rate. 

 
void  Camera_SetTuningValue( CameraOperator::TuningValue tuningValue, float value )
 	
Set camera tuning value. 

 
void  Camera_SetZoomDist( float distance )
 	
Set the current zoom distance for the camera. 

 
void  Camera_StopAutoRotating( Void  )
 	
Stops the camera from procedurally rotating. Input is restored. 

 
void  Camera_Unclamp( Void  )
 	
Frees up the camera (so it's not clamped to a marker anymore). 

 
Void  EGroup_CallEntityFunction( EGroupID egroup, Function entityFunction, variable!argument list )
 	
Calls an Entity_ function on every entity in an egroup 

The first parameter of the supplied function must be EntityID

 
Void  EGroup_CallEntityFunctionAllOrAny( EGroupID egroup, Boolean all, Function entityFunction, variable!argument list )
 	
Returns whether ALL or ANY entities in an egroup satisfy a condition, using an Entity_ function to perform the query on each entity 

The first parameter of the supplied function must be EntityID

 
int  fatal( lua_State* state )
 	
Throws an error to lua and print out the error message 

 
void  Game_EnableInput( bool enabled )
 	
Enables/Disables all input EXCEPT for ESC and F10. 

 
void  Game_EndSubTextFade( Void  )
 	
Removes title text displayed with Game_SubTextFade(...) immediately 

 
void  Game_EndTextTitleFade( Void  )
 	
Removes title text displayed with Game_TextTitleFade(...) immediately 

 
Player*  Game_GetLocalPlayer( Void  )
 	
Get the local player. (should only be used for UI purpose) (not strict) 

 
GameUICore::UIMode  Game_GetMode( Void  )
 	
Returns the current game screen mode. 

 
int  Game_GetSPDifficulty( Void  )
 	
Returns current single player difficulty. Values are GD_EASY, GD_NORMAL, GD_HARD, GD_EXPERT. 

 
bool  Game_HasLocalPlayer( Void  )
 	
Determine if there is a valid local player. (UI only -- nondeterminstic) (not strict) 

 
bool  Game_IsLetterboxed( Void  )
 	
Returns true if the ui is in letterbox mode . (not strict) 

 
bool  Game_IsPerformanceTest( Void  )
 	
Returns true if the we're running the performance test. 

 
bool  Game_IsRTM( Void  )
 	
Use to test whether the game is running in RTM mode or not. Using -rtm from the command line will cause this function to also return true in non-RTM builds. 

 
void  Game_Letterbox( bool on, float timeSecs )
 	
Enters/Exits letterbox mode in amount of time specified by timeSecs. 

Letterbox mode disables input

 
void  Game_LoadAtmosphere( const char* filename, float transitionTime )
 	
Transitions to another atmosphere. Overwrites current transitions. 

 
void  Game_LockRandom( Void  )
 	
If you are running something that is non-deterministic like a getlocalplayer conditional, you can lock the random to make sure no one down the callstack will throw the game random index out of sync and cause a sync error. REMEMBER TO UNLOCK WHEN YOU ARE DONE 

 
void  Game_ProfileDumpFrames( const char* name, int32_t frameCount )
 	
Dumps a profile series 

 
void  Game_QuitApp( Void  )
 	
Quits the app immediately 

 
void  Game_ScreenFade( float r, float g, float b, float a, float timeSecs )
 	
Fades the screen to a given RGBA colour over a number of seconds 

 
void  Game_SetLocalPlayer( Player* player )
 	
Sets the local player. (not strict) 

 
void  Game_SetMode( GameUICore::UIMode mode )
 	
Set the game screen mode 

UI_Normal is the regular screen with taskbar. UI_Fullscreen is the mode without any 2D UI. UI_Cinematic is the same as letter box mode.

 
void  Game_ShowPauseMenu( Void  )
 	
Brings up the pause menu. The game does not get paused until the end of the current sim tick, so anything that comes after Game_ShowPauseMenu in your function will still get executed, as well as any rules set to run during that frame. 

 
void  Game_SkipAllEvents( bool deleteQueued )
 	
Skips all events. Can either delete or skip queued events. 

 
void  Game_SkipEvent( Void  )
 	
Skips the currently playing event (and stops current sound). 

 
void  Game_StartMuted( bool startMuted )
 	
Do not unmute game sounds when the mission starts (must be called in OnInit). Use this is you transition into a NIS to prevent any audio from playing until the NIS is over. 

 
uint32_t  Game_TextTitleFade( LocString text, float fadeIn, float duration, float fadeOut )
 	
Shows title text that fades in and out over a specified durations 

Call UI_TitleDestroy to remove.

 
void  Game_TriggerLightning( Void  )
 	
Triggers lightning on the next frame 

 
void  Game_UnlockInputOnLetterBox( Void  )
 	
Unlocks user/camera input during letterbox. This should be used for debug only. 

 
void  Game_UnLockRandom( Void  )
 	
unlock the random from a previous lockrandom call only 

 
void  Ghost_DisableSpotting( Void  )
 	
Disable the spotting of enemy entities that may become ghosts in the FoW. 

 
void  Ghost_EnableSpotting( Void  )
 	
Enable the spotting of enemy entities that may become ghosts in the FoW. 

 
size_t  HintPoint_AddToEGroup( EGroup* egroup, int priority, bool visible, LuaConfig::RefFunction function, LocString hint, bool arrow, ScarPosition arrowOffset, HintPointManager::HintPointActionType actionType, const char* iconName )
 	
Deprecated. 

 
size_t  HintPoint_AddToEntity( Entity* entity, int priority, bool visible, LuaConfig::RefFunction function, LocString hint, bool arrow, ScarPosition arrowOffset, int objectiveID, HintPointManager::HintPointActionType actionType, const char* iconName )
 	
For internal use only. 

 
size_t  HintPoint_AddToPosition( ScarPosition position, int priority, bool visible, LuaConfig::RefFunction function, LocString hint, bool arrow, ScarPosition arrowOffset, int objectiveID, HintPointManager::HintPointActionType actionType, const char* iconName )
 	
For internal use only. 

 
size_t  HintPoint_AddToSGroup( SGroup* sgroup, int priority, bool visible, LuaConfig::RefFunction function, LocString hint, bool arrow, ScarPosition arrowOffset, HintPointManager::HintPointActionType actionType, const char* iconName )
 	
Deprecated. 

 
size_t  HintPoint_AddToSquad( Squad* squad, int priority, bool visible, LuaConfig::RefFunction function, LocString hint, bool arrow, ScarPosition arrowOffset, int objectiveID, HintPointManager::HintPointActionType actionType, const char* iconName )
 	
For internal use only. 

 
void  HintPoint_ClearFacing( int id )
 	
Clear the hint point arrow facing value. 

 
void  HintPoint_RemoveAll( Void  )
 	
Remove all hint points. 

 
void  HintPoint_SetDisplayOffsetInternal( int id, ScarPosition offset )
 	
Add a projected offset to the specified hint point. 

 
void  HintPoint_SetFacingEntity( int id, Entity* entity )
 	
Face the hint point arrow towards this entity. 

 
void  HintPoint_SetFacingPosition( int id, ScarPosition position )
 	
Face the hint point arrow towards this position. 

 
void  HintPoint_SetFacingSquad( int id, Squad* squad )
 	
Face the hint point arrow towards this squad. 

 
void  HintPoint_SetVisibleInternal( int id, bool visible )
 	
Show or hide the specified hint point. 

 
void  inv_dump( Void  )
 	
Dump content of inventory to a file 

 
bool  IsOfType( const PropertyBagGroup* pbg, const char* type )
 	
Returns true if this object is of the specified type 

 
bool  IsSecuringStructure( const PropertyBagGroup* pbg )
 	
Can this structure be used to secure territory 

 
bool  IsStructure( const PropertyBagGroup* pbg )
 	
Returns true if this object is a structure (something with a site_ext) 

 
bool  License_CanPlayRace( const char* raceName )
 	
Returns whether the installed version of the game allows the player to play this race 

 
LocString  LOC( const char* text )
 	
DEV ONLY: Converts ansi text to localized text. 

Your text will have to get localized properly at some point before final. When converting text with this function you will get LOC: prefixed to your text

 
LocString  Loc_ConvertNumber( int number )
 	
Returns a localized string containing the number. 

 
LocString  Loc_Empty( Void  )
 	
Empty string. 

This will create an empty localized string.

 
LocString  Loc_FormatTime( int secs, bool show_hours, bool leading_zeroes )
 	
Returns a formatted time string. can omit hours and leading zeroes (for example, 4:57 instead of 00:04:57) 

 
void  Misc_AbortToFE( Void  )
 	
Abort straight out of the game to the frontend, without asking the user 

 
void  Misc_AddRestrictCommandsMarker( ScarMarker marker )
 	
Add another marker in which commands are restricted to. 

 
void  Misc_AIControlLocalPlayer( Void  )
 	
Let AI take over local player 

 
bool  Misc_AreDefaultCommandsEnabled( Void  )
 	
Returns the enabled/disabled state of the right-click command input. (not strict) 

 
bool  Misc_DetectKeyboardInput( Void  )
 	
Returns true if the app has had any keyboard input in the last second 

 
bool  Misc_DetectMouseInput( Void  )
 	
Returns true if the app has had any mouse input in the last second 

 
void  Misc_DoWeaponHitEffectOnEntity( Entity* entity, ScarPosition pos, ScarWeaponPBG weaponPBG, bool penetrated )
 	
Do weapon hit effect on the entity from the view camera origin 

WeaponID is the property bag group id; if penetrated is set to false, deflection effect would be played instead

 
void  Misc_EnablePerformanceTest( bool toEnable )
 	
Turn on or off the performance test monitoring 

 
const char*  Misc_GetCommandLineString( const char* option )
 	
Returns the string argument for a command line option. ex: for "-init test.lua" it would return "test.lua" 

 
void  Misc_GetControlGroupContents( int groupIndex, SGroup* squads, EGroup* nonSquadEntities )
 	
Returns contents of a control group (0 to 9). Squads are put into an sgroup, and non-squad entities are put into an egroup. 

 
int  Misc_GetEntityControlGroup( Entity* entity )
 	
Returns the control group index that this entity belongs to, from 0 to 9, or -1 if none. 

 
ScarPosition  Misc_GetHiddenPositionOnPath( CheckHiddenType checkType, ScarPosition origin, ScarPosition destination, ScarEntityPBG ebp, float stepDistance, float cameraPadding, ModPlayer* fowPlayer, bool debugDisplay )
 	
Returns a hidden position on path from origin to destination. If there's none, it returns the origin position 

Possible check types are CheckHiddenFromCamera, CheckHiddenInFOW and CheckHiddenBothCameraFOW Camera check determined by the camera frustum. use cameraPadding to increase the area around the camera when doing the check FOW check requires a valid player ID passed in stepDistance is the interval along the path that the hidden points will be checked ( min is 1 metre ) If no hidden position is found, position ( 0, 0, 0 ) is returned Don't use this for multi-player SCAR script!!

 
ScarPosition  Misc_GetMouseOnTerrain( Void  )
 	
Returns the world position of the mouse on the terrain (not strict) 

 
Entity*  Misc_GetMouseOverEntity( Void  )
 	
Returns the entity under the mouse (if any) (not strict) 

 
void  Misc_GetSelectedEntities( EGroup* group, bool subselection )
 	
Clears a given group and adds the current full selection (or subselection if true) to the group. 

 
void  Misc_GetSelectedSquads( SGroup* group, bool subselection )
 	
Clears a given group and adds the current full selection (or subselection if true) to the group. 

 
int  Misc_GetSquadControlGroup( Squad* squad )
 	
Returns the control group index that this squad belongs to, from 0 to 9, or -1 if none. 

 
bool  Misc_IsCommandLineOptionSet( const char* option )
 	
Returns true if -option is specified on the command line 

 
bool  Misc_IsDevMode( Void  )
 	
Returns whether the game is running in dev mode. The rules for dev mode are a bit complicated between builds, so we cannot simply check the command line. 

 
bool  Misc_IsEntityOnScreen( Entity* entity, float percent )
 	
Check if the squad is on screen currently (not strict) 

 
bool  Misc_IsEntitySelected( Entity* entity )
 	
Returns true if the specified entity is currently selected. 

 
bool  Misc_IsMouseOverEntity( Void  )
 	
Returns true if the mouse is over an entity (not strict) 

 
bool  Misc_IsPosOnScreen( ScarPosition pos, float percent )
 	
Check if position is on screen, (1 being the entire screen, 0.5 being 50% of the screen from the center point) 

 
bool  Misc_IsSelectionInputEnabled( Void  )
 	
Returns the enabled/disabled state of the selection input. (not strict) 

 
bool  Misc_IsSquadOnScreen( Squad* squad, float percent )
 	
Check if the entity is on screen currently (not strict) 

 
bool  Misc_IsSquadSelected( Squad* squad )
 	
Returns true if the specified squad is currently selected. 

 
void  Misc_RemoveCommandRestriction( Void  )
 	
Remove all command restrictions. 

 
void  Misc_RestrictCommandsToMarker( ScarMarker marker )
 	
Set the marker in which commands are restricted to. 

 
const char*  Misc_Screenshot( Void  )
 	
Save a screenshot 

 
void  Misc_ScreenshotExt( const char* fileExtension )
 	
Set the graphic file type for screenshot (.jpg, .tga) 

 
void  Misc_SelectEntity( Entity* entity )
 	
Set the full selection to the specified entity. 

 
void  Misc_SelectSquad( Squad* squad, bool selected )
 	
Set the full selection to the specified entity. 

 
void  Misc_SetDefaultCommandsEnabled( bool enabled )
 	
Enables/disables right-click command input. 

 
void  Misc_SetDesignerSplatsVisibility( bool bVisible )
 	
Shows or hides designer splats, which are splats in the UI folder 

 
void  Misc_SetEntityControlGroup( Entity* entity, int groupIndex )
 	
Makes an entity belong to a specific control group. If it already belongs to another control group, it's removed from that one before being added to the new one. 

 
void  Misc_SetEntitySelectable( Entity* entity, bool selectable )
 	
Disable/enable selectability of the specified entity. 

 
void  Misc_SetSelectionInputEnabled( bool enabled )
 	
Enables/disables selection input. 

 
void  Misc_SetSquadControlGroup( Squad* squad, int groupIndex )
 	
Makes a squad belong to a specific control group. If it already belongs to another control group, it's removed from that one before being added to the new one. 

 
void  Misc_SetSquadSelectable( Squad* squad, bool selectable )
 	
Disable/enable selectability of the specified squad. 

 
Void  Mission_Complete( Void  )
 	
Plays the defined end cinematic and ends an SP scenario with a Victory. 

 
Void  Mission_Fail( Void  )
 	
Ends an SP scenario with a Failure. 

 
Table objective  Mission_GetSecondaryObjective( Void  )
 	
Return a reference to the Secondary Objective table. Nil if objective has not been started yet. 

 
Void  Mission_StartBonusObjective( Bool showTitle, Bool skipIntel[, Int index] )
 	
Selects a possible secondary objective and starts it. 

'index' can be used to override the random selection and load a specific secondary objective.

 	Source: [coh2\BIA\root\CoH2\Data\Scar/ScriptSetup.scar] (330) 
References: [Slottable+Secondary+Objectives]

Void  Mission_Win( Void  )
 	
Ends an SP scenario with a Victory without playing any end cinematics. 

 
uint32_t  Modifier_ApplyToEntity( const Modifier* modifier, Entity* entity )
 	
Applies an entity modifier to an entity. 

 
uint32_t  Modifier_ApplyToPlayer( const Modifier* modifier, ModPlayer* player )
 	
Applies a player modifier to a player. 

 
uint32_t  Modifier_ApplyToSquad( const Modifier* modifier, Squad* squad )
 	
Applies a squad modifier to a squad. 

 
const Modifier*  Modifier_Create( Modifier::ModifierApplicationType applicationType, const char* modtype, Modifier::ModifierUsageType usageType, bool exclusive, float value, LuaBinding::StackVar v )
 	
Returns a modifier that you can apply to stuff. 

applicationType : MAT_EntityType, MAT_Entity, MAT_Player, MAT_Squad, MAT_SquadType, or MAT_Weapon.<BR/> modtype : Name of modifier from the modifiers table in the attribute editor.<BR/> usageType : MUT_Addition, MUT_Multiplication, MUT_MultiplyAdd or MUT_Enable.<BR/> exclusive : This field is not currently used for modifiers created through script. <BR/> value : The value for the modifier.<BR/> extname : The name of the entity/squad blueprint for when the applicationType is MAT_EntityType or MAT_SquadType.

 
void  Modifier_Destroy( const Modifier* modifier )
 	
Todo. 

 
bool  Modifier_IsEnabled( Entity* pEntity, const char* modtype, bool bEnabledByDefault )
 	
Checks whether the modifier is enabled (requires an Entity and an Entity enable/disable modifier) 

 
void  nis_setintransitiontime( float numSeconds )
 	
Sets the number of seconds it takes to transition from game to nis, 0 is instantaneous 

This includes blending the camera position, fov and clip planes

 
void  nis_setouttransitionnis( const char* filename )
 	
Lets the nis system know which nis will be transitioned to when the first one ends. 

This function doesn't actually trigger a second nis to start, rather it lets the NIS system know which one will be next, so it can prevent the camera from popping back to the game camera.

 
void  nis_setouttransitiontime( float numSeconds )
 	
Sets the number of seconds it takes to transition from nis back to game, 0 is instantaneous 

This includes blending the camera position, fov and clip planes

 
int  Obj_Create( ModPlayer* player, LocString title, LocString desc, const char* icon, Objective::Type type, int parentID )
 	
Create an objective and returns the unique ID for it 

type could either be OT_Primary or OT_Secondary

 
void  Obj_Delete( int objectiveID )
 	
Delete the objective with the specified ID 

 
void  Obj_DeleteAll( Void  )
 	
Delete all objectives 

 
Objective::State  Obj_GetState( int objectiveID )
 	
Get objective state ( OS_Off, OS_Incomplete, OS_Complete, OS_Failed ) (not strict) 

 
bool  Obj_GetVisible( int objectiveID )
 	
Get objective visibility (not strict) 

 
void  Obj_HideProgress( Void  )
 	
Hide the objective progress panel. 

 
void  Obj_SetDescription( int objectiveID, LocString desc )
 	
Set description text localization ID for the objective 

 
void  Obj_SetIcon( int objectiveID, const char* icon )
 	
Set icon path for the objective 

 
void  Obj_SetObjectiveFunction( int id, Objective::ObjectiveFn fnType, LuaConfig::RefFunction f )
 	
Set callback functions for the objective. (not strict) 

FN_OnActivate is for triggering situation report. FN_OnShow is used to assign UI element when tactical map is open. FN_OnSelect is used to assign UI element when the objective is highlighted

 
void  Obj_SetProgressBlinking( bool blinking )
 	
Make the objective progress bar blink or stop blinking. 

 
void  Obj_SetState( int objectiveID, Objective::State state )
 	
Set objective state ( OS_Off, OS_Incomplete, OS_Complete, OS_Failed ) 

 
void  Obj_SetTitle( int objectiveID, LocString title )
 	
Set title text localization ID for the objective 

 
void  Obj_SetVisible( int objectiveID, bool visible )
 	
Set objective visibility 

 
void  Obj_ShowProgress( LocString title, float progress )
 	
Show the objective progress panel with a progress bar - call repeatedly to update progress. Value should be normalized between [0 - 1]. 

 
void  Obj_ShowProgress2( LocString title, float progress )
 	
Show the objective progress panel with a progress bar - call repeatedly to update progress. Value should be normalized between [0 - 1]. Appears in center of screen. 

 
void  Obj_ShowProgressTimer( LocString title, float progress )
 	
Show the objective progress panel with a timer icon - call repeatedly to update progress. Value should be in seconds. 

 
GroupTable table  OpBounty_AddRewardGroup( Table groupTable )
 	
Does things 

 
GroupTable table  OpBounty_AddRewardTable( Table groupTable )
 	
Does things 

 
Void  Order227_Init( [Integer timeLimit, Integer timeBetweenShots, Boolean noMercy] )
 	
Enable the HQ Commissar in CoH2 campaign missions. The noMercy flag allows the Commissar to execute more than one member of each squad. 

 
Void  PrintOnScreen( String text )
 	
Prints a message on the screen 

Prints the given message on the screen. It will stay there until you call PrintOnScreen_RemoveFromScreen() or print another message on the screen to replace it.

 
PrintOnScreenID  PrintOnScreen_Add( Object object, String id[, String style] )
 	
Prints the lua content of an object on the screen 

Prints the given message on the screen. If you would like to print multiple messages without clearing them you can assign them unique ID's. Must use PrintOnScreen_Remove(id) to remove each instance

 
Void  PrintOnScreen_Remove( String id )
 	
Removes the PrintOnScreen text of a given ID 

 
Void  PrintOnScreen_RemoveFromScreen( )
 	
Remove any messages from the screen 

Removes from the screen any messages put there with PrintOnScreen()

 
ResourceAmount  ResourceAmount_Add( ResourceAmount amt1, ResourceAmount amt2 )
 	
Add each element of the two passed in ResourceAmounts together 

 
ResourceAmount  ResourceAmount_ClampToZero( ResourceAmount amt )
 	
Clamps the passed in resource to zero if it has any negative numbers 

 
bool  ResourceAmount_Has( ResourceAmount amt1, ResourceAmount amt2 )
 	
Returns true if the first amount has enough resources for the second amount (amt2) 

 
ResourceAmount  ResourceAmount_Mult( ResourceAmount amt1, float mult )
 	
Take a resource amount and multiply each value inside of it by mult 

 
ResourceAmount  ResourceAmount_Subtract( ResourceAmount amt1, ResourceAmount amt2 )
 	
Subtract the second amount from the first and return the new ResourceAmount 

 
float  ResourceAmount_Sum( ResourceAmount amt1 )
 	
Add up all the numbers in the resource and return a single value 

 
ResourceAmount  ResourceAmount_Zero( Void  )
 	
Creates a new ResourceAmount all set to zero 

 
void  Scar_Autosave( Void  )
 	
Saves the game. the savegame name is built using the abbreviated mission name + checkpoint. 

 
void  Scar_CompleteIntelBulletinTask( Player* pCompleter, const char* taskId )
 	
Complete a intel bulletin task of campaign type 

 
void  Scar_DebugConsoleExecute( const char* command )
 	
execute console command string. Will only work if dev mode is enabled! (it's OFF by default in RTM builds) 

 
void  Scar_PlayNIS( const char* filename )
 	
Play NIS through SCAR. Should only be used inside a event function 

 
void  Scar_PlayNIS2( const char* filename1, const char* filename2 )
 	
Play 2 NISs through SCAR. Should only be used inside a event function 

 
void  Scar_ReloadAIScripts( Void  )
 	
Reloads AI Scripts 

 
float  Setup_GetVictoryPointTickerOption( Void  )
 	
Get the victory point ticker option selected 

 
void  Setup_SetPlayerName( ModPlayer* player, LocString name )
 	
Set the UI name of a given player. 

 
void  Setup_SetPlayerRace( ModPlayer* player, uint32_t raceIndex )
 	
Set the race for a given player. Use World_GetRaceIndex() to get the race id from the ME name. 

 
void  Setup_SetPlayerTeam( ModPlayer* p, int team_id )
 	
Put a player in a team. Use TEAM_NEUTRAL as the team_id to set the player as neutral 

 
Void  SGroup_CallEntityFunction( SGroupID sgroup, Function entityFunction )
 	
Calls an Entity_ function on every entity in an sgroup 

The first parameter of the supplied function must be EntityID

 
Void  SGroup_CallSquadFunction( SGroupID sgroup, Function squadFunction, variable!argument list )
 	
Calls a Squad_ function on every squad in an sgroup 

The first parameter of the supplied function must be SquadID

 
Void  SGroup_CallSquadFunctionAllOrAny( SGroupID sgroup, Boolean all, Function squadFunction, variable!argument list )
 	
Returns whether ALL or ANY squads in an sgroup satisfy a condition, using a Squad_ function to perform the query on each squad 

The first parameter of the supplied function must be SquadID

 
void  SitRep_PlayMovie( const char* url )
 	
Play the specified movie. 

 
uint32_t  SitRep_PlaySpeech( const char* icon, LocString loc, bool disableIconSubtitle, bool continueButton, bool blockInput, bool stickySubtitle, const char* additionalPath )
 	
Deprecated. 

Call UI_TitleDestroy to remove.

 
void  SitRep_StopMovie( Void  )
 	
Stop the currently playing movie. 

 
void  Sound_ContainerDebug( Void  )
 	
Turns container debugging on/off 

Example:<BR/><BR/> \Sound_ContainerDebug()<BR/>

 
void  Sound_DisableSpeechEvent( int event )
 	
Disables certain speech events. 

 
bool  Sound_IsPlaying( size_t handle )
 	
Returns true if the sound associated with the handle is currently playing. 

 
void  Sound_PerfTest_Play2D( const char* name, size_t instances )
 	
Starts multiple 2D instances of the same sound. 

 
size_t  Sound_Play2D( const char* name )
 	
Plays a 2D sound from the Data:Sound folder. Use the path relative to Sound folder without the file extension. Returns handle to the sound container 

The sound needs to be 2D Example:<BR/><BR/> <TAB/>Sound_Play( "Blah/Mysound" )<BR/>

 
size_t  Sound_Play3D( const char* name, Entity* actor )
 	
Plays a 3D sound from the Data:Sound folder on the entity. Use the path relative to Sound folder without the file extension. Returns handle to the sound container 

The sound needs to be 3D Example:<BR/><BR/> <TAB/>Sound_Play( "Speech/SpaceMarine/AddOnComplete", TheActor )<BR/>

 
void  Sound_PlayMusic( const char* name, float fade, float delay )
 	
Plays music from the Data:Sound folder. 

The new music will phase out the old one. There can only be one music playing at anytime besides the transition fade is the time to fade in the music; delay is the time in seconds to wait until the new music is started Example:<BR/><BR/> <TAB/>Sound_PlayMusic( "Music/GreatMusic", 0.0, 0.0 )<BR/>

 
size_t  Sound_PlayStreamed( const char* name )
 	
Plays a streaming sound from the Data:Sound folder. Use the path relative to Sound folder without the file extension. Returns handle to the sound container 

The sound needs to be 2D Example:<BR/><BR/> <TAB/>Sound_PlayStreamed( "Blah/Mysound" )<BR/>

 
void  Sound_PreCacheSinglePlayerSpeech( const char* mission )
 	
Pre-caches single player speech. For instance pre-caching mission 1 speech is done like: Sound_PreCacheSinglePlayerSpeech("mission01") 

 
void  Sound_PreCacheSound( const char* name )
 	
pre-caches a sound 

Example:<BR/><BR/> <TAB/>Sound_PreCacheSound("nis/m02_n01_full")<BR/>

 
void  Sound_PreCacheSoundFolder( const char* name )
 	
pre-caches a sound folder 

Example:<BR/><BR/> <TAB/>Sound_PreCacheSoundFolder("sp/mission1")<BR/>

 
void  Sound_SetGlobalControlSource( const char* name, float value )
 	
Sets the value for a global control source. 

Example:<BR/><BR/> \Sound_SetGlobalControlSource("GameType", 2)<BR/>

 
void  Sound_SetMusicCombatValue( float immCombatValue, float overrideTime )
 	
immCombatValue is the new music combat value. Override time is in seconds. You can call this function with 0 for both values in order to cancel the override. 

 
void  Sound_SetVolume( const char* name, float volume, float time )
 	
Sets a new volume for the group. Valid volume values are 0 to 1. 

Example:<BR/><BR/> <TAB/>Sound_Volume("Weapons", 0.5, 2)<BR/>

 
void  Sound_SetVolumeDefault( const char* name, float time )
 	
Sets the default volume for the group. 

Example:<BR/><BR/> <TAB/>Sound_SetVolumeDefault("Weapons", 2)<BR/>

 
void  Sound_SetVolumeInv( const char* name, float volume, float time )
 	
Sets the volume for all groups except the one specified. Valid volume values are 0 to 1. 

Example:<BR/><BR/> <TAB/>Sound_VolumeInv("NIS", 0.5, 2)<BR/>

 
void  Sound_StartRecording( const char* name )
 	
Starts recording the sound driver output 

Example:<BR/><BR/> <TAB/>Sound_StartRecording("Recordings/MyRecording.wav")<BR/>

 
void  Sound_Stop( size_t handle )
 	
Stops sound associated with the container handle 

 
void  Sound_StopAll( Void  )
 	
Stops all sounds associated with the container manager. 

 
void  Sound_StopMusic( float fade, float delay )
 	
Stop current playing music 

Currently playing music would be stopped. If nothing is playing, nothing will happen fade is the time to fade out the music; delay is the time in seconds wait until the new music is stopped Example:<BR/><BR/> <TAB/>Sound_StopMusic( 2.0, 0.0 )<BR/>

 
void  Sound_StopRecording( Void  )
 	
Stops recording the sound driver output 

Example:<BR/><BR/> <TAB/>Sound_StopRecording()<BR/>

 
void  Speech_SetGlobalStealthRead( float sunlightThreshold )
 	
Overrides default stealth speech auto-detect mechanism. Stealth speech will play when sunlight brightness is below the threshold, with 0 being total darkness and 1 being full brightness. Set to -1 to use the default behavior. 

 
void  statgraph( Void  )
 	
?? 

 
void  statgraph_channel( const char *channel )
 	
?? 

 
bool  statgraph_channel_get_enabled( const char *channel )
 	
?? 

 
void  statgraph_channel_set_enabled( const char *channel, bool enable )
 	
?? 

 
void  statgraph_clear( Void  )
 	
?? 

 
void  statgraph_list( Void  )
 	
?? 

 
void  statgraph_pause( Void  )
 	
?? 

 
void  Subtitle_EndAllSpeech( Void  )
 	
Prematurely finish all queued speech 

This is useful for skipping all speech events that may have been queued

 
void  Subtitle_EndCurrentSpeech( Void  )
 	
Prematurely finish currently playing speech and advance the next one in queue 

This is useful for skipping speech events

 
uint32_t  Subtitle_PlaySpeech( const char* icon, LocString loc, bool disableIconSubtitle, bool continueButton, bool blockInput, bool stickySubtitle, const char* additionalPath )
 	
Plays a global speech with subtitle and actor icon in the overlay 

Call UI_TitleDestroy to remove.

 
void  Subtitle_UnstickCurrentSpeech( Void  )
 	
Removes "sticky" state from currently playing speech (if any) 

 
Boolean  SyncWeapon_CanAttackNow( SyncWeaponID weapon, egroup/sgroup/pos/marker target )
 	
Checks whether a sync weapon can attack a target without moving or turning. 

 
Boolean  SyncWeapon_Exists( SyncWeaponID weapon )
 	
Returns true if a sync weapon still exists in the game world 

 
EntityID  SyncWeapon_GetEntity( SyncWeaponID weapon )
 	
Returns the EntityID of a sync weapon, or nil if it's been destroyed 

 
SyncWeaponID  SyncWeapon_GetFromEGroup( EGroupID egroup )
 	
Registers the sync weapon in the egroup and returns a SyncWeaponID you can use to keep track of it 

 
SyncWeaponID  SyncWeapon_GetFromSGroup( SGroupID sgroup )
 	
Registers the sync weapon in the sgroup and returns a SyncWeaponID you can use to keep track of it 

 
Position  SyncWeapon_GetPosition( SyncWeaponID weapon )
 	
Returns the position of a sync weapon, or nil if it's been destroyed 

 
Boolean  SyncWeapon_IsAttacking( SyncWeaponID weapon, Real time )
 	
Checks whether or not the actual sync weapon in a squad attacking. 

 
Boolean  SyncWeapon_IsOwnedByPlayer( SyncWeaponID weapon, [PlayerID player] )
 	
Returns true if the specified player owns the sync weapon. Use a playerid of nil to see if it's unonwed. 

If player is not specified, then the code will check to see if the SyncWeapon is owned by the world.

 
Void  SyncWeapon_SetAutoTargetting( SyncWeaponID weapon, String hardpoint, Bool enable )
 	
Sets whether a weapon to auto-target things or not 

 
bool  Taskbar_IsVisible( Void  )
 	
Returns true if the taskbar is visible. (not strict) 

 
void  Taskbar_SetVisibility( bool visible )
 	
Sets taskbar visibility. 

 
size_t  TaskCountActivePBG( AIPlayer* pPlayer, const PropertyBagGroup* pbg, ProductionItemType buildtype, bool bCheckState, bool bCheckActive )
 	
Determine how many tasks with the given PBG are of the provided active state, passing no last parameters means to check both 

 
size_t  TaskCountPBG( const AIPlayer* pPlayer, const PropertyBagGroup* pbg, ProductionItemType buildtype )
 	
Determine how many requested are currently created for this pbg 

 
void  UI_AutosaveMessageHide( Void  )
 	
Removes a message added by UI_AutosaveMessageShow. 

 
void  UI_AutosaveMessageShow( Void  )
 	
Shows a message indicating that the game is autosaving. 

Call UI_AutosaveMessageHide to remove the message.

 
void  UI_ClearEventCues( Void  )
 	
Clears all active event cues 

 
void  UI_ClearModalAbilityPhaseCallback( Void  )
 	
Clears the ability phase callback. 

 
void  UI_ClearNISEndCallback( Void  )
 	
Clears the callback function called at the current NIS. 

 
void  UI_CoverPreviewHide( Void  )
 	
Toggle off cover preview. Each call to UI_CoverPreviewHide must be matched by a call to UI_CoverPreviewShow 

 
void  UI_CoverPreviewShow( Void  )
 	
Toggle on cover preview. Each call to UI_CoverPreviewShow must be matched by a call to UI_CoverPreviewHide 

 
void  UI_CreateColouredEntityKickerMessage( ModPlayer* player, Entity* entity, LocString message, int red, int green, int blue, int alpha )
 	
Create a coloured custom kicker message on the entity and display to the player, rgb values are 0-255. 

 
void  UI_CreateColouredPositionKickerMessage( ModPlayer* player, ScarPosition position, LocString message, int red, int green, int blue, int alpha )
 	
Create a coloured custom kicker message on the entity and display to the player, rgb values are 0-255. 

 
void  UI_CreateColouredSquadKickerMessage( ModPlayer* player, Squad* squad, LocString message, int red, int green, int blue, int alpha )
 	
Create a coloured custom kicker message on the entity and display to the player, rgb values are 0-255. 

 
void  UI_CreateEntityKickerMessage( ModPlayer* player, Entity* entity, LocString message )
 	
Create a custom kicker message on the entity and display to the player. 

 
void  UI_CreatePositionKickerMessage( ModPlayer* player, ScarPosition position, LocString message )
 	
Create a custom kicker message on the entity and display to the player. 

 
void  UI_CreateSquadKickerMessage( ModPlayer* player, Squad* squad, LocString message )
 	
Create a custom kicker message on the entity and display to the player. 

 
void  UI_EnableGameEventCueType( GameEventType gameEventType, bool enable )
 	
Enables or disables event cues. 

 
void  UI_EnableResourceTypeKicker( ResourceAmount::ResourceType resourceType, bool enable )
 	
Enables or disables resource kickers. 

 
void  UI_EnableUIEventCueType( UIEventType uiEventType, bool enable )
 	
Enables or disables event cues. 

 
size_t  UI_FlashAbilityButton( ScarAbilityPBG ability, bool stopOnClick )
 	
Flash an ability command button. Pass the return value to UI_StopFlashing to stop flashing the button. 

 
size_t  UI_FlashConstructionButton( ScarEntityPBG ebp, bool stopOnClick )
 	
Flash a construction item command button. Pass the return value to UI_StopFlashing to stop flashing the button. 

 
size_t  UI_FlashConstructionMenu( const char* menuName, bool stopOnClick )
 	
Flash a construction menu command button. Pass the return value to UI_StopFlashing to stop flashing the button. 

 
void  UI_FlashEntity( Entity* entity, const char* actionOnName )
 	
Flashes the entity using attributes from [tuning][ui] 

 
size_t  UI_FlashEntityCommandButton( EntityCommandType command, bool stopOnClick )
 	
Flash an entity order command button. Pass the return value to UI_StopFlashing to stop flashing the button. 

 
size_t  UI_FlashEventCue( size_t eventCueID, bool stopOnClick )
 	
Flash an event cue item. Pass the return value to UI_StopFlashing to stop flashing the button. 

 
size_t  UI_FlashObjectiveCounter( int objectiveID )
 	
Flash an objective counter. Pass the return value to UI_StopFlashing to stop flashing the button. 

 
size_t  UI_FlashObjectiveIcon( int objectiveID, bool stopOnClick )
 	
Flash an objective. Pass the return value to UI_StopFlashing to stop flashing the button. 

 
size_t  UI_FlashProductionBuildingButton( const char* type, bool stopOnClick )
 	
Flash a production building button. Pass the return value to UI_StopFlashing to stop flashing the button. 

 
size_t  UI_FlashProductionButton( ProductionItemType type, const PropertyBagGroup* pbg, bool stopOnClick )
 	
Flash a production item command button. Pass the return value to UI_StopFlashing to stop flashing the button. 

 
size_t  UI_FlashSquadCommandButton( SquadCommandType command, bool stopOnClick )
 	
Flash a squad order command button. Pass the return value to UI_StopFlashing to stop flashing the button. 

 
bool  UI_GetDecoratorsEnabled( Void  )
 	
Returns whether all decorators are enabled or not 

 
void  UI_HideTacticalMap( Void  )
 	
Hides the tactical map 

 
void  UI_HighlightSquad( Squad* squad, float duration )
 	
Turn on squad highlight UI feature for the specified duration. 

 
bool  UI_IsTacticalMapShown( Void  )
 	
Returns whether the tactical map is being shown (not strict) 

 
void  UI_MessageBoxHide( Relic::COH2UI::ScarSystemConnector::DialogResult button )
 	
If the message box is activated, close it. The callback will receive the button parameter given. 

 
void  UI_MessageBoxSetButton( Relic::COH2UI::ScarSystemConnector::DialogResult dialogResult, LocString text, LocString tooltip, bool bEnabled )
 	
Set the text/tooltip/enabled state of a button on the dialog. 

 
void  UI_MessageBoxSetText( LocString title, LocString message )
 	
Set the title and message body of the dialog. 

 
uint32_t  UI_NewHUDFeature( GameUICore::HUDFeatureType newHUDFeature, LocString featureText, const char* featureIcon, float duration )
 	
Brings up a message and arrow pointing to a HUD feature. 

Call UI_TitleDestroy to remove.

 
void  UI_OutOfBoundsLinesHide( Void  )
 	
Toggle off terrain out of bounds lines. Each call to UI_OutOfBoundsLinesHide must be matched by a call to UI_OutOfBoundsLinesShow 

 
void  UI_OutOfBoundsLinesShow( Void  )
 	
Toggle on terrain out of bounds lines. Each call to UI_OutOfBoundsLinesShow must be matched by a call to UI_OutOfBoundsLinesShowHide 

 
void  UI_RestrictBuildingPlacement( ScarMarker marker )
 	
Only allow buildings to be placed inside a marker. 

 
uint32_t  UI_ScreenFade( float r, float g, float b, float a, float duration, bool persistent )
 	
Fades the screen to a given RGBA colour over a number of seconds. mouse input is blocked during the fade, and you can control whether the input keeps being blocked after the fade has ended (be careful!) 

Call UI_TitleDestroy to remove.

 
void  UI_SetAbilityCardVisibility( bool visible )
 	
Sets the visibility of the Commander Ability card. 

 
void  UI_SetAlliedBandBoxSelection( bool allow )
 	
Sets the game to allow allied squads to be selected at the same time as your own squads 

 
void  UI_SetCPMeterVisibility( bool visible )
 	
Sets the visibility of the Command Point meter. 

 
void  UI_SetDecoratorsEnabled( bool enabled )
 	
Enables or disables all decorators 

 
void  UI_SetForceShowSubtitles( bool forceShowSubtitles )
 	
Sets the game to force show subtitles even if the player has them turned off. 

 
void  UI_SetModalAbilityPhaseCallback( LuaConfig::RefFunction function )
 	
Sets a function to be called when the player clicks an ability and gets a targeting UI. Your function will have 2 arguments: [Blueprint] ability blueprint, [integer] phase: MAP_Placing, MAP_Facing (only if ability requires facing) or MAP_Confirmed (not strict) 

 
void  UI_SetNISEndCallback( LuaConfig::RefFunction function )
 	
Sets the callback function called at the end of an NIS, note this function is automatically cleared after being called once. 

 
void  UI_SetSoviet227Blinking( bool blinking )
 	
Blink the Soviet 227/progression UI 

 
void  UI_SetSoviet227Visibility( bool visible )
 	
Sets the visibility of the Soviet 227/progression UI 

 
void  UI_ShowTacticalMap( Void  )
 	
Shows the tactical map 

 
void  UI_StopFlashing( size_t id )
 	
Stop flashing a flash created with a previous call to UI_Flash*(). 

 
void  UI_SystemMessageHide( LocString message )
 	
Removes a message added by Game_ShowSystemMessage. 

 
void  UI_SystemMessageShow( LocString message )
 	
Shows a system message in the area where Game Paused text appears. 

Call Game_HideSystemMessage to remove the message.

 
void  UI_TerritoryHide( Void  )
 	
Toggle off territory lines. Each call to UI_TerritoryHide must be matched by a call to UI_TerritoryShow 

 
void  UI_TerritoryShow( Void  )
 	
Toggle on territory lines. Each call to UI_TerritoryShow must be matched by a call to UI_TerritoryHide 

 
void  UI_TitleDestroy( uint32_t id )
 	
Removes a title using an id returned by the title creating function. 

 
void  UI_ToggleDecorators( Void  )
 	
Toggles all decorators on or off. 

 
void  UI_UnrestrictBuildingPlacement( Void  )
 	
Removes the restriction on building placement. 

 
uint32_t  UIWarning_Show( LocString text )
 	
Displays a brief UI warning in the critical alert message area. 

Call UI_TitleDestroy to remove.

 
checkID  Util_AddProxCheck( PlayerID/SGroup element, EGroup/SGroup/Pos/MarkerID location, Boolean all, Real range, LuaFunction callback, Int delay )
 	
[DEPRECATED. Use Event_Proximity() instead.] Add a proximity check. 

Checks if ANY or ALL the units in the element are within range of the location. If location is a CIRCLE marker, default range will be max(radius, 5)

 
Void  Util_ClearProxChecks( Void  )
 	
[DEPRECATED. DO NOT USE.] Removes all existing proximity checks. 

Clears the list of prox checks that are currently active and shis down the procChecker.

 
Void  Util_CreateEntities( PlayerID player, EGroupID egroup, Integer blueprintID, MarkerID/Pos location, Integer numentities[, MarkerID/Pos toward] )
 	
Creates a given number of entities at a location and adds them to an egroup. A PlayerID of nil will create the entities as world objects. 

 
SGroup  Util_CreateSquads( PlayerID player, SGroupID/Table/String sgroup, SquadBlueprint/Table sbp, Marker/Pos/SGroup/EGroup spawn_point[, Position destination, Integer numsquads, Integer loadout, Boolean attackmove, Position dest_facing, UpgradeBlueprint/Table upgrades, Position spawn_facing] )
 	
High level function to create squads and give them basic orders upon spawning. Detailed explanation found in ScarUtil.scar 

PlayerID player - player who will own the squads SGroupID/Table/String sgroup - sgroup that receives the new squads. Can be nil if you don't need to manage the new squads or a string if you want to create a new sgroup with that name. If a table is given, the first item will be used as the return sgroup. SquadBlueprint sbp - the blueprint for the new squads. can be a table of blueprints, in which case a random blueprint will be chosen for each squad Position location - where to spawn the squads (can be any parameter type whose position can be queried) SGroup - If the sgroup is a Hold Entity then the squad is spawned inside of it. EGroup - If the egroup is a hold entity then the squad is spawned inside of it. NOTE: if the hold is destroyed, or is full, or due to any other misc. failure case, then the squad is spawned at the player's map entry point. Pos - the squad is spawned at this location. Marker - the squad is spawned at the marker and facing the direciton of the marker. Position destination - (OPTIONAL) where the squads will move to, load into, or attack SGroup can mean two different things, if the Sgroup is owned by the player and a hold then try to enter it. Or if the SGroup is an enemy squad, then the spawned squad should attack move the enemy. If neither is true, then the squad just moves to the location. EGroup should be treated the same as the SGroup. Position/Marker: the squad moves to the location. Sync weapon: the squad captures the sync weapon. Integer numsquads - (OPTIONAL) how many squads to spawn Integer loadout - (OPTIONAL) max amount of units to spawn per squad Boolean attackmove - (OPTIONAL) in cases where the squads do a simple move to their destination (not attacking or loading into anything), this determines whether they attack move or not Position facing - (OPTIONAL) in cases where the squads do a simple move to their destination, this determines their facing once they reach their destination. If facing is not specified, and the squad is moving to a marker, the marker's facing is used. UpgradeBlueprint upgrades - (OPTIONAL) upgrade(s) to instantly apply to squads when they spawn

 	Source: [coh2\BIA\root\CoH2\Data\Scar/ScarUtil.scar] (711) 
References: [Util_CreateSquads]

Real  Util_GetDistance( entity/squad/egroup/sgroup/marker/pos Object1, entity/squad/egroup/sgroup/marker/pos Object2 )
 	
Returns the distance between two objects 

 
Position  Util_GetOffsetPosition( entity/squad/egroup/sgroup/marker/position pos, Integer offset, Real distance )
 	
Returns a position relative to a entity/squad/egroup/sgroup/marker/position's current position and orientation. see LuaConsts.scar for explanation of 'offset' parameter. 

 
PlayerID  Util_GetPlayerOwner( entity/squad/egroup/sgroup/player Object )
 	
Returns the player owner for any of: entity, squad, egroup, sgroup, player. for groups, the first item is used. Returns nil for world owned or empty groups 

 
Integer --> R_ENEMY, R_ALLY, R_NEUTRAL, R_UNDEFINED, or nil (if world owned or invalid parameters)  Util_GetRelationship( entity/squad/egroup/sgroup/player Object_1, entity/squad/egroup/sgroup/player Object_2 )
 	
Gets the relationship between two of: entity, squad, egroup, sgroup, player. for groups, the first item is used. 

 
Offset  Util_GetRelativeOffset( entity/squad/egroup/sgroup/marker/position element, entity/squad/egroup/sgroup/marker/position pos )
 	
Returns a relative offset position to an element 

 
Void  Util_MonitorTerritory( Table/EGroup terrs, Float captureThreshold, Int timeoutValue, ScarFN callback, ScarFN alertIntel, Table parentObjective )
 	
Monitors a territory point and warns the player if it goes below a certain capture threshold 

Can receive a parent objective to which to attach a subobjective that displays data.

 
Void  Util_RemoveProxCheck( EGroup/SGroup/Pos/MarkerID location )
 	
[DEPRECATED. DO NOT USE.] Remove proximity checks assigned to a location.  

Removes all proximity checks associated with the defined location.

 
Void  Util_RemoveProxCheckByID( Integer checkID )
 	
[DEPRECATED. DO NOT USE.] Remove a specific proximity check based on its ID. 

 
Position, if y-height is nil, y-height = ground height, terrain ground or walkable  Util_ScarPos( Real xpos, Real zpos, Real ypos )
 	
Converts a 2D top down position to a 3D ScarPosition. 

3D ScarPositions have the x axis left to right, the z axis in to out, and the y axis down to up (y axis represents the height of the terrain). Use this function to convert a top-down 2D position to a 3D world position.<BR/><BR/> Note: (0,0) is in the center of the map.

 
Void  Util_SetPlayerOwner( entity/squad/egroup/sgroup Object, PlayerID owner[, Boolean bApplyToSquadsHeld=true] )
 	
Sets the player owner for an entity, squad, egroup or sgroup. Also sets player owner of whatever is garrisoned inside them 

 
EGroupID  Util_SpawnDemoCharge( PlayerID player, MarkerID/Pos location )
 	
Spawns a demo charge at a position and returns an egroup 

Use this instead of World_SpawnDemolitionCharge if you need to manage it

 
Void  Util_StartNIS( String/Integer/LuaFunction NIS[, LuaFunction onComplete, egroup/sgroup/Player/Table hide, LuaFunction preNIS, LuaFunction postNIS, Boolean framedump, Boolean preserveFOW] )
 	
Play an NIS. See confluence link below for more info. 

 	Source: [coh2\BIA\root\CoH2\Data\Scar/NIS.scar] (20) 
References: [Scripting+NIS+Transitions]

void  VIS_OccCullToggleOBB( Void  )
 	
toggle the visibility of occlusion culling OBB 

 
 

 

World
Functions

Void  Marker_CleanUpTheDead( PlayerID player, MarkerID marker )
 	
Kill off a specific player's dead bodies (enter ALL to clean them all up) in a marker radius 

 
void  Weather_SetType( const char* weatherLevelName )
 	
changes the weather state of all objects (options: sunny, lightrain, mediumrain, heavyrain) 

 
void  World_AddPilferLockArea( ScarPosition pos, float radius )
 	
Add an area where pilferable weapons won't disappear due to timeout 

 
Void  World_CleanUpTheDead( PlayerID player )
 	
Kill off a specific player's dead bodies (enter ALL to clean them all up) 

 
void  World_ClearCasualties( Void  )
 	
 
void  World_DamageIce( ScarPosition pos, float innerRadius, float outerRadius, float innerDamage, float outerDamage )
 	
Damage a circle of ice with a gradient 

linearly to 50 damage at 10 meters (so 75 damage at 7.5 meters)

 
void  World_DestroyWallsNearMarker( ScarMarker marker )
 	
Destroys walls (entities with a wall_ext) near a marker 

 
float  World_DistanceEGroupToPoint( EGroup* egroup, ScarPosition p1, bool closest )
 	
Get the distance between a squad group and a point. 

Pass in true for 3rd parameter to get the closest point and pass in false to get the furthest point. The closest/furthest point is calculated on a per entity basis. So the closest distance would be that of the closest entity.<BR/> Also note, it is an error to call this function with an empty group.<BR/>

 
float  World_DistancePointToPoint( ScarPosition p1, ScarPosition p2 )
 	
Get the distance between two points. 

 
float  World_DistanceSGroupToPoint( SGroup* sgroup, ScarPosition p1, bool closest )
 	
Get the distance between a squad group and a point. 

Pass in true for 3rd parameter to get the closest point and pass in false to get the furthest point. The closest/furthest point is calculated on a per squadron basis. So the closest distance would be that of the closest squadron.<BR/> It is an error to call this function with an empty group. Check the group size with SquadGroup_Count( ) first.

 
float  World_DistanceSquaredPointToPoint( ScarPosition p1, ScarPosition p2 )
 	
Get the distance squared between two points. 

 
void  World_EnableReplacementObjectForEmptyPlayers( bool enable )
 	
*** You must call this from OnGameSetup, otherwise it's too late *** Determines whether empty players get converted to null resource points. 

see Attribute Editor under tuning/player/empty_player_replacement_object

 
void  World_EnableSharedLineOfSight( ModPlayer* p0, ModPlayer* p1, bool enable )
 	
Enables or disables shared line of sight between these two players 

 
void  World_EndSP( bool win )
 	
Wins/loses a single team mission for the local teams 

 
Variable  World_GetClosest( Variable var, LuaTable items )
 	
Returns the closest object from the table of marker/pos/egroup/sgroup to the closest marker/pos/egroup/sgroup specified 

The table may mix together objects of different types.

 
int  World_GetCurrentInteractionStage( Void  )
 	
Returns the current interaction stage (areas painted at this number or lower are currently interactable) 

 
int  World_GetEntitiesNearMarker( Player* player, EGroup* egroup, ScarMarker marker, OwnerType ownerType )
 	
Find and add entities near the marker to the egroup 

Entities belonging to a squad would not be added to the egroup

 
int  World_GetEntitiesNearPoint( Player* player, EGroup* egroup, ScarPosition pos, float radius, OwnerType ownerType )
 	
Find and add entities near the point to the egroup 

Entities belonging to a squad would not be added to the egroup

 
int  World_GetEntitiesWithinTerritorySector( Player* player, EGroup* egroup, size_t sectorID, OwnerType ownerType )
 	
Find and add entities within the territory sector to the egroup 

Entities belonging to a squad would not be added to the egroup

 
Entity*  World_GetEntity( int index )
 	
Returns the UniqueID at given index, use with World_GetNumEntities() to iterate through all the entities in the world 

 
Variable  World_GetFurthest( Variable var, LuaTable items )
 	
Returns the furthest object from the table of marker/pos/egroup/sgroup to the furthest marker/pos/egroup/sgroup specified. 

The table may mix together objects of different types.

 
float  World_GetGameTime( Void  )
 	
Return the total game time in seconds. 

 
float  World_GetHeightAt( float x, float y )
 	
returns the height of ground at 2D pos x,y 

 
Position  World_GetHiddenPositionOnPath( PlayerID player, MarkerID/Pos origin, MarkerID/Pos destination, Integer checktype )
 	
Find a position on a path hidden from view, as close to the destination as possible whilst still satisfying your hidden checktype. Checktype can be either CHECK_IN_FOW, CHECK_OFFCAMERA or CHECK_BOTH. 

The path is always calculated as if it were plain infantry. This function returns nil if it can't find a suitable position, so you can do a backup plan.

 
float  World_GetLength( Void  )
 	
Returns the total playable length of the game world (z coordinate) 

Since the center of the map is 0,0 the world z range is (-l/2 -> l/2)

 
ScarPosition  World_GetNearestInteractablePoint( ScarPosition position )
 	
returns the nearest intractable position to the supplied position 

 
int  World_GetNeutralEntitiesNearMarker( EGroup* egroup, ScarMarker marker )
 	
Find and add neutral entities near the marker to the egroup 

Entities belonging to a squad would not be added to the egroup

 
int  World_GetNeutralEntitiesNearPoint( EGroup* egroup, ScarPosition pos, float radius )
 	
Find and add neutral entities near the point to the egroup 

Entities belonging to a squad would not be added to the egroup

 
int  World_GetNeutralEntitiesWithinTerritorySector( EGroup* egroup, size_t sectorID )
 	
Find and add neutral entities within the territory sector to the egroup 

Entities belonging to a squad would not be added to the egroup

 
int  World_GetNumEntities( Void  )
 	
Returns the number of spawned entities in the entire world (use sparingly and never at runtime) 

 
int  World_GetNumEntitiesNearPoint( ScarEntityPBG ebp, ScarPosition pos, float radius )
 	
Return the number of entities of the same ebp in the sphere volume 

 
int  World_GetNumStrategicPoints( Void  )
 	
Returns the number of strategic points on this map (does not count strat. objectives) 

 
int  World_GetNumVictoryPoints( Void  )
 	
Returns the number of strategic objectives on this map 

 
ScarPosition  World_GetOffsetPosition( ScarPosition position, ScarPosition heading, int offset, float distance )
 	
Returns a position that is offset a certain distance from the position/heading passed in. see LuaConsts.scar for explanation of 'offset' parameter. 

 
Player*  World_GetPlayerAt( uint32_t index )
 	
- Returns the player at a given index, numbers start at one 

 
int  World_GetPlayerCount( Void  )
 	
Return the total number of players in the world 

 
int  World_GetPlayerIndex( Player* player )
 	
- Returns the player index given the Player* 

 
ScarSquadPBG  World_GetPossibleSquadsBlueprint( int race_index, int squad_index )
 	
Returns the blueprint of a chosen squad for a race 

 
int  World_GetPossibleSquadsCount( int race_index )
 	
Returns the number of types of squads a race can build 

 
uint32_t  World_GetRaceIndex( const char* racename )
 	
Returns the race index of a race, given its name (from the ME). 

 
int  World_GetRand( int min, int max )
 	
Returns a random integer with range [min, max] 

It is recomended you use this instead of luas math.random function

 
ScarPosition  World_GetSpawnablePosition( ScarPosition around, Entity* entity )
 	
Given any position in the world, this function will return position safe for spawning a given entity 

 
int  World_GetSquadsNearMarker( Player* player, SGroup* sgroup, ScarMarker marker, OwnerType ownerType )
 	
Find and add squads near the marker to the sgroup 

This function is faster if radius is small and/or number of squads to search for is large

 
int  World_GetSquadsNearPoint( Player* player, SGroup* sgroup, ScarPosition pos, float radius, OwnerType ownerType )
 	
Find and add squads near the point to the sgroup 

This function is faster if radius is small and/or number of squads to search for is large

 
int  World_GetSquadsWithinTerritorySector( Player* player, SGroup* sgroup, size_t sectorID, OwnerType ownerType )
 	
Find and add squads within territory sector identified by sector ID 

Owner type could be OT_Player, OT_Ally, OT_Enemy or OT_Neutral

 
void  World_GetStrategyPoints( EGroup* group, bool bIncludeVP )
 	
Appends all the strategic resource points to an egroup.  

takes the egroup where you want to put the points, and 2nd parameter is a bool which indicates if you want to include VPs or not If 'group' already contains an entity from 'grouptoadd' it will not be added.<BR/> This function does not clear the contents of 'group'.<BR/> Example: World_GetStrategyPoints(mypointgroup, true) --puts all the points including vps into mypointgroup

 
bool  World_GetTeamTerritoryGaps( int sectorid1, int sectorid2, LuaBinding::StackVarTable results )
 	
Returns one or more sector IDs that would connect two unconnected pieces of territory. return value is through a table (since there can be more than one way to connect territory) - each entry in this table is a table of sector IDs. 

Currently only finds single gaps - i.e. if two territories are 'almost' connected.

 
int  World_GetTeamVictoryTicker( int teamID )
 	
Returns the number of tickets that this team has 

 
size_t  World_GetTerritorySectorID( ScarPosition pos )
 	
Return the sector ID from the position 

 
ScarPosition  World_GetTerritorySectorPosition( int sectorID )
 	
Returns the position of a sector based on the capture entity (ex: the fuel point's position) 

 
float  World_GetWidth( Void  )
 	
Returns the total playable width of the game world (x coordinate) 

Since the center of the map is 0,0 the world x range is (-w/2 -> w/2)

 
void  World_IncreaseInteractionStage( Void  )
 	
Increases current interaction stage by 1 

 
bool  World_IsGameOver( Void  )
 	
- to document 

 
bool  World_IsInSupply( const ModPlayer* player, ScarPosition pos )
 	
Returns true if position is in-supply for the given player 

 
bool  World_IsPointInPlayerTerritory( Player* player, ScarPosition position )
 	
Returns true if position if part of the entity territory 

Note that this does not care if territory is in supply or not

 
bool  World_IsTerritorySectorOwnedByPlayer( Player* player, size_t sectorID )
 	
Find if player has ownership to this territory sector. 

Other players on the same team would also have the ownership to the sector

 
Boolean  World_IsWinterMap( Void  )
 	
Returns whether the current map is set in winter. Checks if 'g_isWinterMap' is set to true. 

 
Boolean  World_OwnsEGroup( EGroupID egroup, Boolean all )
 	
Returns whether ANY or ALL of the entities in the group are owned by the world (i.e. neutral) 

 
bool  World_OwnsEntity( Entity* entity )
 	
Returns true if the squad is owned by the world 

 
Boolean  World_OwnsSGroup( SGroupID sgroup, Boolean all )
 	
Returns whether ANY or ALL of the squads in the group are owned by the world (i.e. neutral) 

 
bool  World_OwnsSquad( Squad* squad )
 	
Returns true if the squad is owned by the world 

 
bool  World_PointPointProx( ScarPosition p1, ScarPosition p2, float prox )
 	
Returns true if two world positions are in proximity to each other 

 
ScarPosition  World_Pos( float x, float y, float z )
 	
Creates a new Position object. 

A position object is basically a table with an x, y, and z attribute. You can directly access the individual components in the same way that you would access a field in a table.<BR/><BR/> Example:<BR/> --* lua script snip<BR/> local pos = World_Pos(2, 0, 0)<BR/> pos.x = pos.x + 1<BR/> print pos.x -- this will print 3<BR/> --* lua script snip<BR/>

 
void  World_RemoveAllResourcePoints( Void  )
 	
Removes all resource and strategic points but not entities with a supply ext NOTE: this could eventually be written as - RemoveAllOfType( type ) which would be more flexible. 

 
void  World_RemovePilferLockArea( ScarPosition pos, float radius )
 	
Remove a locked pilfering area, must pass the same pos and radius as when the lock area was created 

 
void  World_SetDesignerSupply( ScarPosition point, bool bSupply )
 	
Sets a particular sector in the world as a supply provider (or not) 

 
void  World_SetGameOver( Void  )
 	
- to document 

 
void  World_SetIceHealingRate( float percentPerSecond )
 	
Set what percent ice heals per second (0.05 means 5% per second) 

 
void  World_SetPlayerCustomSkin( ModPlayer* pPlayer, const char* skin )
 	
Change the player's custom skin settings, skin must exist in the AE list of DLC skins 

 
void  World_SetPlayerLose( ModPlayer* player )
 	
Sets the player to a lose state, with a reason for losing, and kills the player 

 
void  World_SetPlayerWin( ModPlayer* player )
 	
Sets the player and all the members allied to player to a win state, with a reason for winning. Also sets all other players to a lose state, and kills them (if they're not already dead) 

 
void  World_SetSnowHealingRate( float percentPerSecond )
 	
Set what percent snow heals per second (0.05 means 5% per second) 

 
void  World_SetTeamWin( int team )
 	
Sets every player on a team to a win state, with a reason for winning. Also sets all other players to a lose state, and kills them (if they're not already dead) 

 
bool  World_SpawnDemolitionCharge( Player* player, ScarPosition pos )
 	
spawn a demolitions charge at a position, 'player' is the one that owns the demolitions and can detonate them. 

 
bool  World_TeamTerritoryPointsConnected( int team_index, ScarPosition p1, ScarPosition p2 )
 	
Returns true if the two points are in the same territory region, and owned by the specified territory team, Returns false otherwise. 

 
 

 